
bin\Debug\ET-Sat-TEST2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000003a4  00800100  00002656  0000270a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002656  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000062  008004a4  008004a4  00002aae  2**0
                  ALLOC
  3 .fuse         00000003  00820000  00820000  00002aae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      00000011  00000000  00000000  00002ab1  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002ac4  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000270  00000000  00000000  00002b04  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000029ab  00000000  00000000  00002d74  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000170f  00000000  00000000  0000571f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001a52  00000000  00000000  00006e2e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000f10  00000000  00000000  00008880  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000122c  00000000  00000000  00009790  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001cbc  00000000  00000000  0000a9bc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5d 00 	jmp	0xba	; 0xba <__ctors_end>
       4:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
       8:	0c 94 50 04 	jmp	0x8a0	; 0x8a0 <__vector_2>
       c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      10:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      14:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      18:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      1c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      20:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      24:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      28:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      2c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      30:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      34:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      38:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      3c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      40:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      44:	0c 94 d5 0d 	jmp	0x1baa	; 0x1baa <__vector_17>
      48:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      4c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      50:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      54:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      58:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      5c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      60:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      64:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      68:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      6c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      70:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      74:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      78:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      7c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      80:	0c 94 f6 0e 	jmp	0x1dec	; 0x1dec <__vector_32>
      84:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      88:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      8c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      90:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      94:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      98:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      9c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      a0:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      a4:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      a8:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      ac:	47 09       	sbc	r20, r7
      ae:	57 09       	sbc	r21, r7
      b0:	67 09       	sbc	r22, r7
      b2:	77 09       	sbc	r23, r7
      b4:	77 09       	sbc	r23, r7
      b6:	77 09       	sbc	r23, r7
      b8:	77 09       	sbc	r23, r7

000000ba <__ctors_end>:
      ba:	11 24       	eor	r1, r1
      bc:	1f be       	out	0x3f, r1	; 63
      be:	cf ef       	ldi	r28, 0xFF	; 255
      c0:	da e0       	ldi	r29, 0x0A	; 10
      c2:	de bf       	out	0x3e, r29	; 62
      c4:	cd bf       	out	0x3d, r28	; 61

000000c6 <__do_copy_data>:
      c6:	14 e0       	ldi	r17, 0x04	; 4
      c8:	a0 e0       	ldi	r26, 0x00	; 0
      ca:	b1 e0       	ldi	r27, 0x01	; 1
      cc:	e6 e5       	ldi	r30, 0x56	; 86
      ce:	f6 e2       	ldi	r31, 0x26	; 38
      d0:	02 c0       	rjmp	.+4      	; 0xd6 <__do_copy_data+0x10>
      d2:	05 90       	lpm	r0, Z+
      d4:	0d 92       	st	X+, r0
      d6:	a4 3a       	cpi	r26, 0xA4	; 164
      d8:	b1 07       	cpc	r27, r17
      da:	d9 f7       	brne	.-10     	; 0xd2 <__do_copy_data+0xc>

000000dc <__do_clear_bss>:
      dc:	25 e0       	ldi	r18, 0x05	; 5
      de:	a4 ea       	ldi	r26, 0xA4	; 164
      e0:	b4 e0       	ldi	r27, 0x04	; 4
      e2:	01 c0       	rjmp	.+2      	; 0xe6 <.do_clear_bss_start>

000000e4 <.do_clear_bss_loop>:
      e4:	1d 92       	st	X+, r1

000000e6 <.do_clear_bss_start>:
      e6:	a6 30       	cpi	r26, 0x06	; 6
      e8:	b2 07       	cpc	r27, r18
      ea:	e1 f7       	brne	.-8      	; 0xe4 <.do_clear_bss_loop>
      ec:	0e 94 17 05 	call	0xa2e	; 0xa2e <main>
      f0:	0c 94 29 13 	jmp	0x2652	; 0x2652 <_exit>

000000f4 <__bad_interrupt>:
      f4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f8 <attitude_status_ok>:

PWR_STATE get_nsl_pwr_state(void){
    return nsl_power_status;
}*/

Bool attitude_status_ok(void){
      f8:	cf 93       	push	r28
      fa:	df 93       	push	r29
      fc:	cd b7       	in	r28, 0x3d	; 61
      fe:	de b7       	in	r29, 0x3e	; 62
     100:	2a 97       	sbiw	r28, 0x0a	; 10
     102:	0f b6       	in	r0, 0x3f	; 63
     104:	f8 94       	cli
     106:	de bf       	out	0x3e, r29	; 62
     108:	0f be       	out	0x3f, r0	; 63
     10a:	cd bf       	out	0x3d, r28	; 61
    //power on imu and imu_post() if not calibrated

    int roll_1 = 1;                             //placeholder values; TBD
     10c:	81 e0       	ldi	r24, 0x01	; 1
     10e:	90 e0       	ldi	r25, 0x00	; 0
     110:	9a 83       	std	Y+2, r25	; 0x02
     112:	89 83       	std	Y+1, r24	; 0x01
    int roll_2 = 2;
     114:	82 e0       	ldi	r24, 0x02	; 2
     116:	90 e0       	ldi	r25, 0x00	; 0
     118:	9c 83       	std	Y+4, r25	; 0x04
     11a:	8b 83       	std	Y+3, r24	; 0x03
    int roll_3 = 3;
     11c:	83 e0       	ldi	r24, 0x03	; 3
     11e:	90 e0       	ldi	r25, 0x00	; 0
     120:	9e 83       	std	Y+6, r25	; 0x06
     122:	8d 83       	std	Y+5, r24	; 0x05

    int attitude = roll_1 * roll_2 * roll_3;    //calculate attitude (maybe another func?)
     124:	29 81       	ldd	r18, Y+1	; 0x01
     126:	3a 81       	ldd	r19, Y+2	; 0x02
     128:	8b 81       	ldd	r24, Y+3	; 0x03
     12a:	9c 81       	ldd	r25, Y+4	; 0x04
     12c:	28 9f       	mul	r18, r24
     12e:	a0 01       	movw	r20, r0
     130:	29 9f       	mul	r18, r25
     132:	50 0d       	add	r21, r0
     134:	38 9f       	mul	r19, r24
     136:	50 0d       	add	r21, r0
     138:	11 24       	eor	r1, r1
     13a:	2d 81       	ldd	r18, Y+5	; 0x05
     13c:	3e 81       	ldd	r19, Y+6	; 0x06
     13e:	42 9f       	mul	r20, r18
     140:	c0 01       	movw	r24, r0
     142:	43 9f       	mul	r20, r19
     144:	90 0d       	add	r25, r0
     146:	52 9f       	mul	r21, r18
     148:	90 0d       	add	r25, r0
     14a:	11 24       	eor	r1, r1
     14c:	98 87       	std	Y+8, r25	; 0x08
     14e:	8f 83       	std	Y+7, r24	; 0x07
    int high_threshold = 100;                   //high_threshold = some ridiculously high roll rate that exceeds our "BAD" condition
     150:	84 e6       	ldi	r24, 0x64	; 100
     152:	90 e0       	ldi	r25, 0x00	; 0
     154:	9a 87       	std	Y+10, r25	; 0x0a
     156:	89 87       	std	Y+9, r24	; 0x09

    if ( attitude > high_threshold ) {          //spacecraft roll rate too high; MFM checks IMU for faulty reading or passive detumble
     158:	2f 81       	ldd	r18, Y+7	; 0x07
     15a:	38 85       	ldd	r19, Y+8	; 0x08
     15c:	89 85       	ldd	r24, Y+9	; 0x09
     15e:	9a 85       	ldd	r25, Y+10	; 0x0a
     160:	82 17       	cp	r24, r18
     162:	93 07       	cpc	r25, r19
     164:	14 f4       	brge	.+4      	; 0x16a <attitude_status_ok+0x72>
        return FALSE;
     166:	80 e0       	ldi	r24, 0x00	; 0
     168:	01 c0       	rjmp	.+2      	; 0x16c <attitude_status_ok+0x74>
    }
    return TRUE;
     16a:	81 e0       	ldi	r24, 0x01	; 1

}
     16c:	2a 96       	adiw	r28, 0x0a	; 10
     16e:	0f b6       	in	r0, 0x3f	; 63
     170:	f8 94       	cli
     172:	de bf       	out	0x3e, r29	; 62
     174:	0f be       	out	0x3f, r0	; 63
     176:	cd bf       	out	0x3d, r28	; 61
     178:	df 91       	pop	r29
     17a:	cf 91       	pop	r28
     17c:	08 95       	ret

0000017e <tether_status_ok>:

Bool tether_status_ok(void){
     17e:	cf 93       	push	r28
     180:	df 93       	push	r29
     182:	cd b7       	in	r28, 0x3d	; 61
     184:	de b7       	in	r29, 0x3e	; 62
    //idk my bff tiff
    return TRUE;
     186:	81 e0       	ldi	r24, 0x01	; 1
}
     188:	df 91       	pop	r29
     18a:	cf 91       	pop	r28
     18c:	08 95       	ret

0000018e <tus_power_status_ok>:

Bool tus_power_status_ok(void) {
     18e:	cf 93       	push	r28
     190:	df 93       	push	r29
     192:	00 d0       	rcall	.+0      	; 0x194 <tus_power_status_ok+0x6>
     194:	00 d0       	rcall	.+0      	; 0x196 <tus_power_status_ok+0x8>
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
    int power = 100;                        //placeholder; TBD
     19a:	84 e6       	ldi	r24, 0x64	; 100
     19c:	90 e0       	ldi	r25, 0x00	; 0
     19e:	9a 83       	std	Y+2, r25	; 0x02
     1a0:	89 83       	std	Y+1, r24	; 0x01
    int low_threshold = 25;                 //placeholder; TBD
     1a2:	89 e1       	ldi	r24, 0x19	; 25
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	9c 83       	std	Y+4, r25	; 0x04
     1a8:	8b 83       	std	Y+3, r24	; 0x03

    if ( power < low_threshold ) {          //emitter battery level too low, need to wait to solar charge
     1aa:	29 81       	ldd	r18, Y+1	; 0x01
     1ac:	3a 81       	ldd	r19, Y+2	; 0x02
     1ae:	8b 81       	ldd	r24, Y+3	; 0x03
     1b0:	9c 81       	ldd	r25, Y+4	; 0x04
     1b2:	28 17       	cp	r18, r24
     1b4:	39 07       	cpc	r19, r25
     1b6:	14 f4       	brge	.+4      	; 0x1bc <tus_power_status_ok+0x2e>
        return FALSE;
     1b8:	80 e0       	ldi	r24, 0x00	; 0
     1ba:	01 c0       	rjmp	.+2      	; 0x1be <tus_power_status_ok+0x30>
    }                                       //add if power too high (in the case of a faulty read?)
    return TRUE;
     1bc:	81 e0       	ldi	r24, 0x01	; 1
}
     1be:	0f 90       	pop	r0
     1c0:	0f 90       	pop	r0
     1c2:	0f 90       	pop	r0
     1c4:	0f 90       	pop	r0
     1c6:	df 91       	pop	r29
     1c8:	cf 91       	pop	r28
     1ca:	08 95       	ret

000001cc <flag_status>:

/*Bool communication_status_ok(void){           //TUS doesn't care? TUS interrupts PGS to go into whatever mode. PGS has to know which mode op to rely on: time, interrupt.
}*/

void flag_status( Bool conditional_val, int error_val ) {
     1cc:	cf 93       	push	r28
     1ce:	df 93       	push	r29
     1d0:	00 d0       	rcall	.+0      	; 0x1d2 <flag_status+0x6>
     1d2:	1f 92       	push	r1
     1d4:	cd b7       	in	r28, 0x3d	; 61
     1d6:	de b7       	in	r29, 0x3e	; 62
     1d8:	89 83       	std	Y+1, r24	; 0x01
     1da:	7b 83       	std	Y+3, r23	; 0x03
     1dc:	6a 83       	std	Y+2, r22	; 0x02
    if ( conditional_val == FALSE ) {
     1de:	89 81       	ldd	r24, Y+1	; 0x01
     1e0:	88 23       	and	r24, r24
     1e2:	59 f4       	brne	.+22     	; 0x1fa <flag_status+0x2e>
//        run_malfunction_mode( error_val );              //send to Malfunction Mode w/error code
        printf("condition value was false");
     1e4:	8d e0       	ldi	r24, 0x0D	; 13
     1e6:	91 e0       	ldi	r25, 0x01	; 1
     1e8:	89 2f       	mov	r24, r25
     1ea:	8f 93       	push	r24
     1ec:	8d e0       	ldi	r24, 0x0D	; 13
     1ee:	91 e0       	ldi	r25, 0x01	; 1
     1f0:	8f 93       	push	r24
     1f2:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <printf>
     1f6:	0f 90       	pop	r0
     1f8:	0f 90       	pop	r0
    }
}
     1fa:	0f 90       	pop	r0
     1fc:	0f 90       	pop	r0
     1fe:	0f 90       	pop	r0
     200:	df 91       	pop	r29
     202:	cf 91       	pop	r28
     204:	08 95       	ret

00000206 <mode_test_init>:

void mode_test_init(void){
     206:	cf 93       	push	r28
     208:	df 93       	push	r29
     20a:	cd b7       	in	r28, 0x3d	; 61
     20c:	de b7       	in	r29, 0x3e	; 62
    /**
    DDRB |= (1<<PB0)|(1<<PB1)|(1<<PB6)|(1<<PB7);//|(1<<PB2)|(1<<PB3)|(1<<PB4)|(1<<PB5);
    //DDRC |= (1<<PC0)|(1<<PC1)|(1<<PC2)|(1<<PC3)|(1<<PC4)|(1<<PC5)|(1<<PC6);
    DDRD |= (1<<PD0)|(1<<PD1)|(1<<PD4)|(1<<PD5)|(1<<PD6)|(1<<PD7); //|(1<<PD2)|(1<<PD3);
     */
}
     20e:	df 91       	pop	r29
     210:	cf 91       	pop	r28
     212:	08 95       	ret

00000214 <led_clear>:

void led_clear(void){
     214:	cf 93       	push	r28
     216:	df 93       	push	r29
     218:	cd b7       	in	r28, 0x3d	; 61
     21a:	de b7       	in	r29, 0x3e	; 62
    /*****************************
    PORTB &= 0;
    PORTC &= 0;
    PORTD &= 0;
     */
}
     21c:	df 91       	pop	r29
     21e:	cf 91       	pop	r28
     220:	08 95       	ret

00000222 <run_health_safety_check>:

void run_health_safety_check(void){
     222:	cf 93       	push	r28
     224:	df 93       	push	r29
     226:	cd b7       	in	r28, 0x3d	; 61
     228:	de b7       	in	r29, 0x3e	; 62
    printf("Running Health and Safety Checks\n\n");
     22a:	87 e2       	ldi	r24, 0x27	; 39
     22c:	91 e0       	ldi	r25, 0x01	; 1
     22e:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
    switch ( HEALTH_SAFETY_STATUS ) {
     232:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__data_end>
     236:	90 91 a5 04 	lds	r25, 0x04A5	; 0x8004a5 <__data_end+0x1>
     23a:	81 30       	cpi	r24, 0x01	; 1
     23c:	91 05       	cpc	r25, r1
     23e:	61 f0       	breq	.+24     	; 0x258 <run_health_safety_check+0x36>
     240:	81 30       	cpi	r24, 0x01	; 1
     242:	91 05       	cpc	r25, r1
     244:	18 f0       	brcs	.+6      	; 0x24c <run_health_safety_check+0x2a>
     246:	02 97       	sbiw	r24, 0x02	; 2
     248:	69 f0       	breq	.+26     	; 0x264 <run_health_safety_check+0x42>
     24a:	13 c0       	rjmp	.+38     	; 0x272 <run_health_safety_check+0x50>
        case ATTITUDE_STATUS :                          //if true, move to next health check. if false, go to malfunction mode(error_code).
            //led_clear();
            //PORTC |= (1<<PC4);
            //_delay_ms(100);         //delay 100 ms*/

            flag_status( attitude_status_ok(), 0 );
     24c:	0e 94 7c 00 	call	0xf8	; 0xf8 <attitude_status_ok>
     250:	60 e0       	ldi	r22, 0x00	; 0
     252:	70 e0       	ldi	r23, 0x00	; 0
     254:	0e 94 e6 00 	call	0x1cc	; 0x1cc <flag_status>
        case TETHER_STATUS :
            //led_clear();
            //PORTC |= (1<<PC3);
            //_delay_ms(100);

            flag_status( tether_status_ok(), 1 );
     258:	0e 94 bf 00 	call	0x17e	; 0x17e <tether_status_ok>
     25c:	61 e0       	ldi	r22, 0x01	; 1
     25e:	70 e0       	ldi	r23, 0x00	; 0
     260:	0e 94 e6 00 	call	0x1cc	; 0x1cc <flag_status>
        case TUS_POWER_STATUS :
            //led_clear();
            //PORTC |= (1<<PC2);
            //_delay_ms(100);

            flag_status( tus_power_status_ok(), 2 );
     264:	0e 94 c7 00 	call	0x18e	; 0x18e <tus_power_status_ok>
     268:	62 e0       	ldi	r22, 0x02	; 2
     26a:	70 e0       	ldi	r23, 0x00	; 0
     26c:	0e 94 e6 00 	call	0x1cc	; 0x1cc <flag_status>

        //case COMMUNICATION_STATUS :
            //flag_status( communication_status_ok(), 3 );
            break;
     270:	00 00       	nop
    }
}
     272:	df 91       	pop	r29
     274:	cf 91       	pop	r28
     276:	08 95       	ret

00000278 <getAckWaitTime>:
static volatile int k;
static Bool sendAck = TRUE;


//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
int getAckWaitTime(void){
     278:	cf 93       	push	r28
     27a:	df 93       	push	r29
     27c:	00 d0       	rcall	.+0      	; 0x27e <getAckWaitTime+0x6>
     27e:	00 d0       	rcall	.+0      	; 0x280 <getAckWaitTime+0x8>
     280:	1f 92       	push	r1
     282:	cd b7       	in	r28, 0x3d	; 61
     284:	de b7       	in	r29, 0x3e	; 62
    unsigned int data;
    char currentBit;
    int ackTransmissionLength = 0;
     286:	1c 82       	std	Y+4, r1	; 0x04
     288:	1b 82       	std	Y+3, r1	; 0x03

    data = RECEIVE_SUCCESSFUL;
     28a:	8c ef       	ldi	r24, 0xFC	; 252
     28c:	90 e0       	ldi	r25, 0x00	; 0
     28e:	9a 83       	std	Y+2, r25	; 0x02
     290:	89 83       	std	Y+1, r24	; 0x01
    while(data != 0){
     292:	13 c0       	rjmp	.+38     	; 0x2ba <getAckWaitTime+0x42>
        currentBit = data & 0b01;
     294:	89 81       	ldd	r24, Y+1	; 0x01
     296:	81 70       	andi	r24, 0x01	; 1
     298:	8d 83       	std	Y+5, r24	; 0x05
        ackTransmissionLength += get_bit_value_length(currentBit);
     29a:	8d 81       	ldd	r24, Y+5	; 0x05
     29c:	0e 94 43 02 	call	0x486	; 0x486 <get_bit_value_length>
     2a0:	9c 01       	movw	r18, r24
     2a2:	8b 81       	ldd	r24, Y+3	; 0x03
     2a4:	9c 81       	ldd	r25, Y+4	; 0x04
     2a6:	82 0f       	add	r24, r18
     2a8:	93 1f       	adc	r25, r19
     2aa:	9c 83       	std	Y+4, r25	; 0x04
     2ac:	8b 83       	std	Y+3, r24	; 0x03
        data = data >> 1;
     2ae:	89 81       	ldd	r24, Y+1	; 0x01
     2b0:	9a 81       	ldd	r25, Y+2	; 0x02
     2b2:	96 95       	lsr	r25
     2b4:	87 95       	ror	r24
     2b6:	9a 83       	std	Y+2, r25	; 0x02
     2b8:	89 83       	std	Y+1, r24	; 0x01
    unsigned int data;
    char currentBit;
    int ackTransmissionLength = 0;

    data = RECEIVE_SUCCESSFUL;
    while(data != 0){
     2ba:	89 81       	ldd	r24, Y+1	; 0x01
     2bc:	9a 81       	ldd	r25, Y+2	; 0x02
     2be:	89 2b       	or	r24, r25
     2c0:	49 f7       	brne	.-46     	; 0x294 <getAckWaitTime+0x1c>
        currentBit = data & 0b01;
        ackTransmissionLength += get_bit_value_length(currentBit);
        data = data >> 1;
    }
    ackTransmissionLength += preamble_Length;
     2c2:	8b 81       	ldd	r24, Y+3	; 0x03
     2c4:	9c 81       	ldd	r25, Y+4	; 0x04
     2c6:	0a 96       	adiw	r24, 0x0a	; 10
     2c8:	9c 83       	std	Y+4, r25	; 0x04
     2ca:	8b 83       	std	Y+3, r24	; 0x03
    ackTransmissionLength += end_Transmission_Length;
     2cc:	8b 81       	ldd	r24, Y+3	; 0x03
     2ce:	9c 81       	ldd	r25, Y+4	; 0x04
     2d0:	0e 96       	adiw	r24, 0x0e	; 14
     2d2:	9c 83       	std	Y+4, r25	; 0x04
     2d4:	8b 83       	std	Y+3, r24	; 0x03
    ackTransmissionLength += END_OF_MESSAGE_BUFFER;
     2d6:	8b 81       	ldd	r24, Y+3	; 0x03
     2d8:	9c 81       	ldd	r25, Y+4	; 0x04
     2da:	0a 96       	adiw	r24, 0x0a	; 10
     2dc:	9c 83       	std	Y+4, r25	; 0x04
     2de:	8b 83       	std	Y+3, r24	; 0x03

    return ackTransmissionLength;
     2e0:	8b 81       	ldd	r24, Y+3	; 0x03
     2e2:	9c 81       	ldd	r25, Y+4	; 0x04
}
     2e4:	0f 90       	pop	r0
     2e6:	0f 90       	pop	r0
     2e8:	0f 90       	pop	r0
     2ea:	0f 90       	pop	r0
     2ec:	0f 90       	pop	r0
     2ee:	df 91       	pop	r29
     2f0:	cf 91       	pop	r28
     2f2:	08 95       	ret

000002f4 <IR_Communication_System_Init>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
void IR_Communication_System_Init(SysTmr_GetTicksFunc_hook_t getticks_func){
     2f4:	cf 93       	push	r28
     2f6:	df 93       	push	r29
     2f8:	00 d0       	rcall	.+0      	; 0x2fa <IR_Communication_System_Init+0x6>
     2fa:	cd b7       	in	r28, 0x3d	; 61
     2fc:	de b7       	in	r29, 0x3e	; 62
     2fe:	9a 83       	std	Y+2, r25	; 0x02
     300:	89 83       	std	Y+1, r24	; 0x01
//----------------------------------------------------------
/*This will set up the timer that the satellite will wait for an acknowledgment before trying again
  We are going to wait the length that it should take to send the ack message before checking to see if
  the message was received... the ackWaitTime variable will be used.
*/
    ackWaitTime = getAckWaitTime();
     302:	0e 94 3c 01 	call	0x278	; 0x278 <getAckWaitTime>
     306:	90 93 d5 04 	sts	0x04D5, r25	; 0x8004d5 <ackWaitTime+0x1>
     30a:	80 93 d4 04 	sts	0x04D4, r24	; 0x8004d4 <ackWaitTime>
//----------------------------------------------------------
/*This portion is going to be used to initialize LEDs that will be used for debugging*/
    DDRB |= (1 << PORTB3);
     30e:	84 e2       	ldi	r24, 0x24	; 36
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	24 e2       	ldi	r18, 0x24	; 36
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	f9 01       	movw	r30, r18
     318:	20 81       	ld	r18, Z
     31a:	28 60       	ori	r18, 0x08	; 8
     31c:	fc 01       	movw	r30, r24
     31e:	20 83       	st	Z, r18
    PORTB &= ~(1<<PORTB3);
     320:	85 e2       	ldi	r24, 0x25	; 37
     322:	90 e0       	ldi	r25, 0x00	; 0
     324:	25 e2       	ldi	r18, 0x25	; 37
     326:	30 e0       	ldi	r19, 0x00	; 0
     328:	f9 01       	movw	r30, r18
     32a:	20 81       	ld	r18, Z
     32c:	27 7f       	andi	r18, 0xF7	; 247
     32e:	fc 01       	movw	r30, r24
     330:	20 83       	st	Z, r18
//----------------------------------------------------------

    cli();
     332:	f8 94       	cli
    //IR_getData = getByteOfData;
    systmr_Init(&IR_Transmitter_Timer,getticks_func);
     334:	89 81       	ldd	r24, Y+1	; 0x01
     336:	9a 81       	ldd	r25, Y+2	; 0x02
     338:	bc 01       	movw	r22, r24
     33a:	86 ea       	ldi	r24, 0xA6	; 166
     33c:	94 e0       	ldi	r25, 0x04	; 4
     33e:	0e 94 39 0a 	call	0x1472	; 0x1472 <systmr_Init>
    systmr_Init(&IR_Receiver_Timer,getticks_func);
     342:	89 81       	ldd	r24, Y+1	; 0x01
     344:	9a 81       	ldd	r25, Y+2	; 0x02
     346:	bc 01       	movw	r22, r24
     348:	8f ea       	ldi	r24, 0xAF	; 175
     34a:	94 e0       	ldi	r25, 0x04	; 4
     34c:	0e 94 39 0a 	call	0x1472	; 0x1472 <systmr_Init>
    systmr_Init(&IR_Timeout_Timer,getticks_func);
     350:	89 81       	ldd	r24, Y+1	; 0x01
     352:	9a 81       	ldd	r25, Y+2	; 0x02
     354:	bc 01       	movw	r22, r24
     356:	88 eb       	ldi	r24, 0xB8	; 184
     358:	94 e0       	ldi	r25, 0x04	; 4
     35a:	0e 94 39 0a 	call	0x1472	; 0x1472 <systmr_Init>

    //enable external interrupt pin for the receiver
    DDRD &= ~(1 << DDD1);     // Clear the PD1 pin
     35e:	8a e2       	ldi	r24, 0x2A	; 42
     360:	90 e0       	ldi	r25, 0x00	; 0
     362:	2a e2       	ldi	r18, 0x2A	; 42
     364:	30 e0       	ldi	r19, 0x00	; 0
     366:	f9 01       	movw	r30, r18
     368:	20 81       	ld	r18, Z
     36a:	2d 7f       	andi	r18, 0xFD	; 253
     36c:	fc 01       	movw	r30, r24
     36e:	20 83       	st	Z, r18
    PORTD |= (1 << PORTD1);    // turn On the Pull-up
     370:	8b e2       	ldi	r24, 0x2B	; 43
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	2b e2       	ldi	r18, 0x2B	; 43
     376:	30 e0       	ldi	r19, 0x00	; 0
     378:	f9 01       	movw	r30, r18
     37a:	20 81       	ld	r18, Z
     37c:	22 60       	ori	r18, 0x02	; 2
     37e:	fc 01       	movw	r30, r24
     380:	20 83       	st	Z, r18

    DDRD &= ~(1 << DDD0);     // Clear the PD1 pin
     382:	8a e2       	ldi	r24, 0x2A	; 42
     384:	90 e0       	ldi	r25, 0x00	; 0
     386:	2a e2       	ldi	r18, 0x2A	; 42
     388:	30 e0       	ldi	r19, 0x00	; 0
     38a:	f9 01       	movw	r30, r18
     38c:	20 81       	ld	r18, Z
     38e:	2e 7f       	andi	r18, 0xFE	; 254
     390:	fc 01       	movw	r30, r24
     392:	20 83       	st	Z, r18
    PORTD |= (1 << PORTD0);    // turn On the Pull-up
     394:	8b e2       	ldi	r24, 0x2B	; 43
     396:	90 e0       	ldi	r25, 0x00	; 0
     398:	2b e2       	ldi	r18, 0x2B	; 43
     39a:	30 e0       	ldi	r19, 0x00	; 0
     39c:	f9 01       	movw	r30, r18
     39e:	20 81       	ld	r18, Z
     3a0:	21 60       	ori	r18, 0x01	; 1
     3a2:	fc 01       	movw	r30, r24
     3a4:	20 83       	st	Z, r18

    EICRA |= (1 << ISC10);    // set INT1 to trigger on ANY logic change
     3a6:	89 e6       	ldi	r24, 0x69	; 105
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	29 e6       	ldi	r18, 0x69	; 105
     3ac:	30 e0       	ldi	r19, 0x00	; 0
     3ae:	f9 01       	movw	r30, r18
     3b0:	20 81       	ld	r18, Z
     3b2:	24 60       	ori	r18, 0x04	; 4
     3b4:	fc 01       	movw	r30, r24
     3b6:	20 83       	st	Z, r18
    EIMSK |= (1 << INT1);     // Turns on INT1
     3b8:	8d e3       	ldi	r24, 0x3D	; 61
     3ba:	90 e0       	ldi	r25, 0x00	; 0
     3bc:	2d e3       	ldi	r18, 0x3D	; 61
     3be:	30 e0       	ldi	r19, 0x00	; 0
     3c0:	f9 01       	movw	r30, r18
     3c2:	20 81       	ld	r18, Z
     3c4:	22 60       	ori	r18, 0x02	; 2
     3c6:	fc 01       	movw	r30, r24
     3c8:	20 83       	st	Z, r18
    sei();
     3ca:	78 94       	sei

}
     3cc:	0f 90       	pop	r0
     3ce:	0f 90       	pop	r0
     3d0:	df 91       	pop	r29
     3d2:	cf 91       	pop	r28
     3d4:	08 95       	ret

000003d6 <disable_IR_Interrupt>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
void disable_IR_Interrupt(void){
     3d6:	cf 93       	push	r28
     3d8:	df 93       	push	r29
     3da:	cd b7       	in	r28, 0x3d	; 61
     3dc:	de b7       	in	r29, 0x3e	; 62
    cli();
     3de:	f8 94       	cli
    EIMSK &= ~(1 << INT1);     // Turns off INT1
     3e0:	8d e3       	ldi	r24, 0x3D	; 61
     3e2:	90 e0       	ldi	r25, 0x00	; 0
     3e4:	2d e3       	ldi	r18, 0x3D	; 61
     3e6:	30 e0       	ldi	r19, 0x00	; 0
     3e8:	f9 01       	movw	r30, r18
     3ea:	20 81       	ld	r18, Z
     3ec:	2d 7f       	andi	r18, 0xFD	; 253
     3ee:	fc 01       	movw	r30, r24
     3f0:	20 83       	st	Z, r18
    sei();
     3f2:	78 94       	sei
}
     3f4:	df 91       	pop	r29
     3f6:	cf 91       	pop	r28
     3f8:	08 95       	ret

000003fa <enable_IR_Interrupt>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
void enable_IR_Interrupt(void){
     3fa:	cf 93       	push	r28
     3fc:	df 93       	push	r29
     3fe:	cd b7       	in	r28, 0x3d	; 61
     400:	de b7       	in	r29, 0x3e	; 62
    cli();
     402:	f8 94       	cli
    DDRD &= ~(1 << DDD1);     // Clear the PD2 pin
     404:	8a e2       	ldi	r24, 0x2A	; 42
     406:	90 e0       	ldi	r25, 0x00	; 0
     408:	2a e2       	ldi	r18, 0x2A	; 42
     40a:	30 e0       	ldi	r19, 0x00	; 0
     40c:	f9 01       	movw	r30, r18
     40e:	20 81       	ld	r18, Z
     410:	2d 7f       	andi	r18, 0xFD	; 253
     412:	fc 01       	movw	r30, r24
     414:	20 83       	st	Z, r18
    EIMSK |= (1 << INT1);     // Turns on INT1
     416:	8d e3       	ldi	r24, 0x3D	; 61
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	2d e3       	ldi	r18, 0x3D	; 61
     41c:	30 e0       	ldi	r19, 0x00	; 0
     41e:	f9 01       	movw	r30, r18
     420:	20 81       	ld	r18, Z
     422:	22 60       	ori	r18, 0x02	; 2
     424:	fc 01       	movw	r30, r24
     426:	20 83       	st	Z, r18
    reset_IR_Interrupt();
     428:	0e 94 dd 03 	call	0x7ba	; 0x7ba <reset_IR_Interrupt>
    sei();
     42c:	78 94       	sei
}
     42e:	df 91       	pop	r29
     430:	cf 91       	pop	r28
     432:	08 95       	ret

00000434 <isMessageExecuted>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Bool isMessageExecuted(void){
     434:	cf 93       	push	r28
     436:	df 93       	push	r29
     438:	cd b7       	in	r28, 0x3d	; 61
     43a:	de b7       	in	r29, 0x3e	; 62
    return messageExecuted;
     43c:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
}
     440:	df 91       	pop	r29
     442:	cf 91       	pop	r28
     444:	08 95       	ret

00000446 <setMessageAsExecuted>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
void setMessageAsExecuted(void){
     446:	cf 93       	push	r28
     448:	df 93       	push	r29
     44a:	cd b7       	in	r28, 0x3d	; 61
     44c:	de b7       	in	r29, 0x3e	; 62
    messageExecuted = TRUE;
     44e:	81 e0       	ldi	r24, 0x01	; 1
     450:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
}
     454:	df 91       	pop	r29
     456:	cf 91       	pop	r28
     458:	08 95       	ret

0000045a <setTotalBitsReceived>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
void setTotalBitsReceived(char value){
     45a:	cf 93       	push	r28
     45c:	df 93       	push	r29
     45e:	1f 92       	push	r1
     460:	cd b7       	in	r28, 0x3d	; 61
     462:	de b7       	in	r29, 0x3e	; 62
     464:	89 83       	std	Y+1, r24	; 0x01
	totalBits = value;
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	80 93 d3 04 	sts	0x04D3, r24	; 0x8004d3 <totalBits>
}
     46c:	0f 90       	pop	r0
     46e:	df 91       	pop	r29
     470:	cf 91       	pop	r28
     472:	08 95       	ret

00000474 <getTotalNumOfBitsReceived>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
char getTotalNumOfBitsReceived(void){
     474:	cf 93       	push	r28
     476:	df 93       	push	r29
     478:	cd b7       	in	r28, 0x3d	; 61
     47a:	de b7       	in	r29, 0x3e	; 62
	return totalBits;
     47c:	80 91 d3 04 	lds	r24, 0x04D3	; 0x8004d3 <totalBits>
}
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	08 95       	ret

00000486 <get_bit_value_length>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
int get_bit_value_length(Bool value){
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	1f 92       	push	r1
     48c:	cd b7       	in	r28, 0x3d	; 61
     48e:	de b7       	in	r29, 0x3e	; 62
     490:	89 83       	std	Y+1, r24	; 0x01
    if(value){
     492:	89 81       	ldd	r24, Y+1	; 0x01
     494:	88 23       	and	r24, r24
     496:	19 f0       	breq	.+6      	; 0x49e <get_bit_value_length+0x18>
        return bit_value_high;
     498:	86 e0       	ldi	r24, 0x06	; 6
     49a:	90 e0       	ldi	r25, 0x00	; 0
     49c:	02 c0       	rjmp	.+4      	; 0x4a2 <get_bit_value_length+0x1c>
    }
    else{
        return bit_value_low;
     49e:	82 e0       	ldi	r24, 0x02	; 2
     4a0:	90 e0       	ldi	r25, 0x00	; 0
    }
}
     4a2:	0f 90       	pop	r0
     4a4:	df 91       	pop	r29
     4a6:	cf 91       	pop	r28
     4a8:	08 95       	ret

000004aa <isWithinErrorMargin>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Bool isWithinErrorMargin(char temp, char bit_value){ //returns whtether the time received can be translated into a bit value
     4aa:	cf 93       	push	r28
     4ac:	df 93       	push	r29
     4ae:	00 d0       	rcall	.+0      	; 0x4b0 <isWithinErrorMargin+0x6>
     4b0:	cd b7       	in	r28, 0x3d	; 61
     4b2:	de b7       	in	r29, 0x3e	; 62
     4b4:	89 83       	std	Y+1, r24	; 0x01
     4b6:	6a 83       	std	Y+2, r22	; 0x02
	 if((temp > (bit_value - ERROR_MARGIN)) && (temp < (bit_value + ERROR_MARGIN))){
     4b8:	89 81       	ldd	r24, Y+1	; 0x01
     4ba:	28 2f       	mov	r18, r24
     4bc:	88 0f       	add	r24, r24
     4be:	33 0b       	sbc	r19, r19
     4c0:	8a 81       	ldd	r24, Y+2	; 0x02
     4c2:	08 2e       	mov	r0, r24
     4c4:	00 0c       	add	r0, r0
     4c6:	99 0b       	sbc	r25, r25
     4c8:	02 97       	sbiw	r24, 0x02	; 2
     4ca:	82 17       	cp	r24, r18
     4cc:	93 07       	cpc	r25, r19
     4ce:	74 f4       	brge	.+28     	; 0x4ec <isWithinErrorMargin+0x42>
     4d0:	89 81       	ldd	r24, Y+1	; 0x01
     4d2:	28 2f       	mov	r18, r24
     4d4:	88 0f       	add	r24, r24
     4d6:	33 0b       	sbc	r19, r19
     4d8:	8a 81       	ldd	r24, Y+2	; 0x02
     4da:	08 2e       	mov	r0, r24
     4dc:	00 0c       	add	r0, r0
     4de:	99 0b       	sbc	r25, r25
     4e0:	02 96       	adiw	r24, 0x02	; 2
     4e2:	28 17       	cp	r18, r24
     4e4:	39 07       	cpc	r19, r25
     4e6:	14 f4       	brge	.+4      	; 0x4ec <isWithinErrorMargin+0x42>
		 return TRUE;
     4e8:	81 e0       	ldi	r24, 0x01	; 1
     4ea:	01 c0       	rjmp	.+2      	; 0x4ee <isWithinErrorMargin+0x44>
	 }
	 else{
		 return FALSE;
     4ec:	80 e0       	ldi	r24, 0x00	; 0
	 }
}
     4ee:	0f 90       	pop	r0
     4f0:	0f 90       	pop	r0
     4f2:	df 91       	pop	r29
     4f4:	cf 91       	pop	r28
     4f6:	08 95       	ret

000004f8 <get_Bit_Value_From_Length>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
char get_Bit_Value_From_Length(char length){
     4f8:	cf 93       	push	r28
     4fa:	df 93       	push	r29
     4fc:	00 d0       	rcall	.+0      	; 0x4fe <get_Bit_Value_From_Length+0x6>
     4fe:	cd b7       	in	r28, 0x3d	; 61
     500:	de b7       	in	r29, 0x3e	; 62
     502:	8a 83       	std	Y+2, r24	; 0x02
    char newData;

    if( isWithinErrorMargin(length,bit_value_low) ){
     504:	62 e0       	ldi	r22, 0x02	; 2
     506:	8a 81       	ldd	r24, Y+2	; 0x02
     508:	0e 94 55 02 	call	0x4aa	; 0x4aa <isWithinErrorMargin>
     50c:	88 23       	and	r24, r24
     50e:	11 f0       	breq	.+4      	; 0x514 <get_Bit_Value_From_Length+0x1c>
        newData = 0;
     510:	19 82       	std	Y+1, r1	; 0x01
     512:	0b c0       	rjmp	.+22     	; 0x52a <get_Bit_Value_From_Length+0x32>
    }
    else if( isWithinErrorMargin(length,bit_value_high) ){
     514:	66 e0       	ldi	r22, 0x06	; 6
     516:	8a 81       	ldd	r24, Y+2	; 0x02
     518:	0e 94 55 02 	call	0x4aa	; 0x4aa <isWithinErrorMargin>
     51c:	88 23       	and	r24, r24
     51e:	19 f0       	breq	.+6      	; 0x526 <get_Bit_Value_From_Length+0x2e>
        newData = 1;
     520:	81 e0       	ldi	r24, 0x01	; 1
     522:	89 83       	std	Y+1, r24	; 0x01
     524:	02 c0       	rjmp	.+4      	; 0x52a <get_Bit_Value_From_Length+0x32>
    }
    else{ //if we have no idea what the data received is
        newData = ERROR;
     526:	84 e6       	ldi	r24, 0x64	; 100
     528:	89 83       	std	Y+1, r24	; 0x01
    }

    return newData;
     52a:	89 81       	ldd	r24, Y+1	; 0x01
}
     52c:	0f 90       	pop	r0
     52e:	0f 90       	pop	r0
     530:	df 91       	pop	r29
     532:	cf 91       	pop	r28
     534:	08 95       	ret

00000536 <send_Message>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
void send_Message(int data){
     536:	cf 93       	push	r28
     538:	df 93       	push	r29
     53a:	cd b7       	in	r28, 0x3d	; 61
     53c:	de b7       	in	r29, 0x3e	; 62
     53e:	2c 97       	sbiw	r28, 0x0c	; 12
     540:	0f b6       	in	r0, 0x3f	; 63
     542:	f8 94       	cli
     544:	de bf       	out	0x3e, r29	; 62
     546:	0f be       	out	0x3f, r0	; 63
     548:	cd bf       	out	0x3d, r28	; 61
     54a:	9c 87       	std	Y+12, r25	; 0x0c
     54c:	8b 87       	std	Y+11, r24	; 0x0b
    //******Note****** this send_message assumes that no unsigned values are sent. This is because we are >> the data, and assuming that the bits added on the left hand side are all '0'

    disable_IR_Interrupt();
     54e:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <disable_IR_Interrupt>
    //Create the packet that contains the information that we are going to be sending
    Data_Packet message;

    //assign the correct values to their placeholder
    message.preamble = preamble_Length;
     552:	8a e0       	ldi	r24, 0x0A	; 10
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	9c 83       	std	Y+4, r25	; 0x04
     558:	8b 83       	std	Y+3, r24	; 0x03
    message.end_Transmission = end_Transmission_Length;
     55a:	8e e0       	ldi	r24, 0x0E	; 14
     55c:	90 e0       	ldi	r25, 0x00	; 0
     55e:	98 87       	std	Y+8, r25	; 0x08
     560:	8f 83       	std	Y+7, r24	; 0x07
    message.delay = intermittent_Delay_Length;
     562:	84 e0       	ldi	r24, 0x04	; 4
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	9a 87       	std	Y+10, r25	; 0x0a
     568:	89 87       	std	Y+9, r24	; 0x09

    //Finally, since the message is assembled, transmit the message through the IR Emitter
    //Send the preamble
	systmr_Load(&IR_Transmitter_Timer);
     56a:	86 ea       	ldi	r24, 0xA6	; 166
     56c:	94 e0       	ldi	r25, 0x04	; 4
     56e:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <systmr_Load>
    IR_LED_ON();
     572:	8f e8       	ldi	r24, 0x8F	; 143
     574:	0e 94 80 0c 	call	0x1900	; 0x1900 <tmr0_PwmB>
    while(!systmr_Elapsed(&IR_Transmitter_Timer, message.preamble/2, SYSTMR_RELOAD));
     578:	00 00       	nop
     57a:	8b 81       	ldd	r24, Y+3	; 0x03
     57c:	9c 81       	ldd	r25, Y+4	; 0x04
     57e:	96 95       	lsr	r25
     580:	87 95       	ror	r24
     582:	41 e0       	ldi	r20, 0x01	; 1
     584:	bc 01       	movw	r22, r24
     586:	86 ea       	ldi	r24, 0xA6	; 166
     588:	94 e0       	ldi	r25, 0x04	; 4
     58a:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <systmr_Elapsed>
     58e:	88 23       	and	r24, r24
     590:	a1 f3       	breq	.-24     	; 0x57a <send_Message+0x44>

    IR_LED_OFF();
     592:	80 e0       	ldi	r24, 0x00	; 0
     594:	0e 94 80 0c 	call	0x1900	; 0x1900 <tmr0_PwmB>
    while(!systmr_Elapsed(&IR_Transmitter_Timer, message.delay/2, SYSTMR_RELOAD));
     598:	00 00       	nop
     59a:	89 85       	ldd	r24, Y+9	; 0x09
     59c:	9a 85       	ldd	r25, Y+10	; 0x0a
     59e:	96 95       	lsr	r25
     5a0:	87 95       	ror	r24
     5a2:	41 e0       	ldi	r20, 0x01	; 1
     5a4:	bc 01       	movw	r22, r24
     5a6:	86 ea       	ldi	r24, 0xA6	; 166
     5a8:	94 e0       	ldi	r25, 0x04	; 4
     5aa:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <systmr_Elapsed>
     5ae:	88 23       	and	r24, r24
     5b0:	a1 f3       	breq	.-24     	; 0x59a <send_Message+0x64>
//---------------------------------------------------------------------------------------------
    //Send data
    char currentBit;
    char bitTransmissionLength;

        while(data != 0){
     5b2:	31 c0       	rjmp	.+98     	; 0x616 <send_Message+0xe0>
            currentBit = data & 0b1;
     5b4:	8b 85       	ldd	r24, Y+11	; 0x0b
     5b6:	81 70       	andi	r24, 0x01	; 1
     5b8:	89 83       	std	Y+1, r24	; 0x01
            data = data >> 1;
     5ba:	8b 85       	ldd	r24, Y+11	; 0x0b
     5bc:	9c 85       	ldd	r25, Y+12	; 0x0c
     5be:	95 95       	asr	r25
     5c0:	87 95       	ror	r24
     5c2:	9c 87       	std	Y+12, r25	; 0x0c
     5c4:	8b 87       	std	Y+11, r24	; 0x0b
            bitTransmissionLength = get_bit_value_length(currentBit);
     5c6:	89 81       	ldd	r24, Y+1	; 0x01
     5c8:	0e 94 43 02 	call	0x486	; 0x486 <get_bit_value_length>
     5cc:	8a 83       	std	Y+2, r24	; 0x02

            IR_LED_ON();
     5ce:	8f e8       	ldi	r24, 0x8F	; 143
     5d0:	0e 94 80 0c 	call	0x1900	; 0x1900 <tmr0_PwmB>
            while(!systmr_Elapsed(&IR_Transmitter_Timer, bitTransmissionLength/2, SYSTMR_RELOAD));
     5d4:	00 00       	nop
     5d6:	8a 81       	ldd	r24, Y+2	; 0x02
     5d8:	88 23       	and	r24, r24
     5da:	0c f4       	brge	.+2      	; 0x5de <send_Message+0xa8>
     5dc:	8f 5f       	subi	r24, 0xFF	; 255
     5de:	85 95       	asr	r24
     5e0:	08 2e       	mov	r0, r24
     5e2:	00 0c       	add	r0, r0
     5e4:	99 0b       	sbc	r25, r25
     5e6:	41 e0       	ldi	r20, 0x01	; 1
     5e8:	bc 01       	movw	r22, r24
     5ea:	86 ea       	ldi	r24, 0xA6	; 166
     5ec:	94 e0       	ldi	r25, 0x04	; 4
     5ee:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <systmr_Elapsed>
     5f2:	88 23       	and	r24, r24
     5f4:	81 f3       	breq	.-32     	; 0x5d6 <send_Message+0xa0>

            IR_LED_OFF();
     5f6:	80 e0       	ldi	r24, 0x00	; 0
     5f8:	0e 94 80 0c 	call	0x1900	; 0x1900 <tmr0_PwmB>
            while(!systmr_Elapsed(&IR_Transmitter_Timer, message.delay/2, SYSTMR_RELOAD));
     5fc:	00 00       	nop
     5fe:	89 85       	ldd	r24, Y+9	; 0x09
     600:	9a 85       	ldd	r25, Y+10	; 0x0a
     602:	96 95       	lsr	r25
     604:	87 95       	ror	r24
     606:	41 e0       	ldi	r20, 0x01	; 1
     608:	bc 01       	movw	r22, r24
     60a:	86 ea       	ldi	r24, 0xA6	; 166
     60c:	94 e0       	ldi	r25, 0x04	; 4
     60e:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <systmr_Elapsed>
     612:	88 23       	and	r24, r24
     614:	a1 f3       	breq	.-24     	; 0x5fe <send_Message+0xc8>
//---------------------------------------------------------------------------------------------
    //Send data
    char currentBit;
    char bitTransmissionLength;

        while(data != 0){
     616:	8b 85       	ldd	r24, Y+11	; 0x0b
     618:	9c 85       	ldd	r25, Y+12	; 0x0c
     61a:	89 2b       	or	r24, r25
     61c:	59 f6       	brne	.-106    	; 0x5b4 <send_Message+0x7e>
            while(!systmr_Elapsed(&IR_Transmitter_Timer, message.delay/2, SYSTMR_RELOAD));
        }

//---------------------------------------------------------------------------------------------
        //Send end_Transmission
    IR_LED_ON();
     61e:	8f e8       	ldi	r24, 0x8F	; 143
     620:	0e 94 80 0c 	call	0x1900	; 0x1900 <tmr0_PwmB>
    while(!systmr_Elapsed(&IR_Transmitter_Timer, message.end_Transmission/2, SYSTMR_RELOAD));
     624:	00 00       	nop
     626:	8f 81       	ldd	r24, Y+7	; 0x07
     628:	98 85       	ldd	r25, Y+8	; 0x08
     62a:	96 95       	lsr	r25
     62c:	87 95       	ror	r24
     62e:	41 e0       	ldi	r20, 0x01	; 1
     630:	bc 01       	movw	r22, r24
     632:	86 ea       	ldi	r24, 0xA6	; 166
     634:	94 e0       	ldi	r25, 0x04	; 4
     636:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <systmr_Elapsed>
     63a:	88 23       	and	r24, r24
     63c:	a1 f3       	breq	.-24     	; 0x626 <send_Message+0xf0>

    IR_LED_OFF();
     63e:	80 e0       	ldi	r24, 0x00	; 0
     640:	0e 94 80 0c 	call	0x1900	; 0x1900 <tmr0_PwmB>
    while(!systmr_Elapsed(&IR_Transmitter_Timer, END_OF_MESSAGE_BUFFER/2, SYSTMR_RELOAD)); //Padding that will be used as a buffer
     644:	00 00       	nop
     646:	41 e0       	ldi	r20, 0x01	; 1
     648:	65 e0       	ldi	r22, 0x05	; 5
     64a:	70 e0       	ldi	r23, 0x00	; 0
     64c:	86 ea       	ldi	r24, 0xA6	; 166
     64e:	94 e0       	ldi	r25, 0x04	; 4
     650:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <systmr_Elapsed>
     654:	88 23       	and	r24, r24
     656:	b9 f3       	breq	.-18     	; 0x646 <send_Message+0x110>

    enable_IR_Interrupt();
     658:	0e 94 fd 01 	call	0x3fa	; 0x3fa <enable_IR_Interrupt>
    reset_IR_Interrupt();
     65c:	0e 94 dd 03 	call	0x7ba	; 0x7ba <reset_IR_Interrupt>
}
     660:	2c 96       	adiw	r28, 0x0c	; 12
     662:	0f b6       	in	r0, 0x3f	; 63
     664:	f8 94       	cli
     666:	de bf       	out	0x3e, r29	; 62
     668:	0f be       	out	0x3f, r0	; 63
     66a:	cd bf       	out	0x3d, r28	; 61
     66c:	df 91       	pop	r29
     66e:	cf 91       	pop	r28
     670:	08 95       	ret

00000672 <send_Message_wait_for_ack>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Bool send_Message_wait_for_ack(int data){
     672:	cf 93       	push	r28
     674:	df 93       	push	r29
     676:	00 d0       	rcall	.+0      	; 0x678 <send_Message_wait_for_ack+0x6>
     678:	00 d0       	rcall	.+0      	; 0x67a <send_Message_wait_for_ack+0x8>
     67a:	00 d0       	rcall	.+0      	; 0x67c <send_Message_wait_for_ack+0xa>
     67c:	cd b7       	in	r28, 0x3d	; 61
     67e:	de b7       	in	r29, 0x3e	; 62
     680:	9e 83       	std	Y+6, r25	; 0x06
     682:	8d 83       	std	Y+5, r24	; 0x05
    char i;
    int ack;
    Bool isSuccessfullySent = FALSE;
     684:	1a 82       	std	Y+2, r1	; 0x02

    sendAck = FALSE;
     686:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <sendAck>

    for(i = 0; i < NUMBER_OF_ATTEMPTS; i++){
     68a:	19 82       	std	Y+1, r1	; 0x01
     68c:	29 c0       	rjmp	.+82     	; 0x6e0 <send_Message_wait_for_ack+0x6e>
        if(!isSuccessfullySent){
     68e:	8a 81       	ldd	r24, Y+2	; 0x02
     690:	88 23       	and	r24, r24
     692:	61 f4       	brne	.+24     	; 0x6ac <send_Message_wait_for_ack+0x3a>
            send_Message(data);
     694:	8d 81       	ldd	r24, Y+5	; 0x05
     696:	9e 81       	ldd	r25, Y+6	; 0x06
     698:	0e 94 9b 02 	call	0x536	; 0x536 <send_Message>
            delay_ms(ackWaitTime+ISR_TIMEOUT_AMOUNT);
     69c:	80 91 d4 04 	lds	r24, 0x04D4	; 0x8004d4 <ackWaitTime>
     6a0:	90 91 d5 04 	lds	r25, 0x04D5	; 0x8004d5 <ackWaitTime+0x1>
     6a4:	8c 59       	subi	r24, 0x9C	; 156
     6a6:	9f 4f       	sbci	r25, 0xFF	; 255
     6a8:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <delay_ms>
        }

        ack = IR_checkForNewMessage();
     6ac:	0e 94 06 04 	call	0x80c	; 0x80c <IR_checkForNewMessage>
     6b0:	9c 83       	std	Y+4, r25	; 0x04
     6b2:	8b 83       	std	Y+3, r24	; 0x03

        if(ack == RECEIVE_SUCCESSFUL){
     6b4:	8b 81       	ldd	r24, Y+3	; 0x03
     6b6:	9c 81       	ldd	r25, Y+4	; 0x04
     6b8:	8c 3f       	cpi	r24, 0xFC	; 252
     6ba:	91 05       	cpc	r25, r1
     6bc:	71 f4       	brne	.+28     	; 0x6da <send_Message_wait_for_ack+0x68>
            PORTB ^= (1 << PORTB1);
     6be:	85 e2       	ldi	r24, 0x25	; 37
     6c0:	90 e0       	ldi	r25, 0x00	; 0
     6c2:	25 e2       	ldi	r18, 0x25	; 37
     6c4:	30 e0       	ldi	r19, 0x00	; 0
     6c6:	f9 01       	movw	r30, r18
     6c8:	30 81       	ld	r19, Z
     6ca:	22 e0       	ldi	r18, 0x02	; 2
     6cc:	23 27       	eor	r18, r19
     6ce:	fc 01       	movw	r30, r24
     6d0:	20 83       	st	Z, r18
            i = NUMBER_OF_ATTEMPTS; //If we have received the ack, then we can exit the for loop
     6d2:	8a e0       	ldi	r24, 0x0A	; 10
     6d4:	89 83       	std	Y+1, r24	; 0x01
            isSuccessfullySent = TRUE;
     6d6:	81 e0       	ldi	r24, 0x01	; 1
     6d8:	8a 83       	std	Y+2, r24	; 0x02
    int ack;
    Bool isSuccessfullySent = FALSE;

    sendAck = FALSE;

    for(i = 0; i < NUMBER_OF_ATTEMPTS; i++){
     6da:	89 81       	ldd	r24, Y+1	; 0x01
     6dc:	8f 5f       	subi	r24, 0xFF	; 255
     6de:	89 83       	std	Y+1, r24	; 0x01
     6e0:	89 81       	ldd	r24, Y+1	; 0x01
     6e2:	8a 30       	cpi	r24, 0x0A	; 10
     6e4:	a4 f2       	brlt	.-88     	; 0x68e <send_Message_wait_for_ack+0x1c>
            i = NUMBER_OF_ATTEMPTS; //If we have received the ack, then we can exit the for loop
            isSuccessfullySent = TRUE;
        }
    }

    sendAck = TRUE;
     6e6:	81 e0       	ldi	r24, 0x01	; 1
     6e8:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <sendAck>
    return isSuccessfullySent;
     6ec:	8a 81       	ldd	r24, Y+2	; 0x02

}
     6ee:	26 96       	adiw	r28, 0x06	; 6
     6f0:	0f b6       	in	r0, 0x3f	; 63
     6f2:	f8 94       	cli
     6f4:	de bf       	out	0x3e, r29	; 62
     6f6:	0f be       	out	0x3f, r0	; 63
     6f8:	cd bf       	out	0x3d, r28	; 61
     6fa:	df 91       	pop	r29
     6fc:	cf 91       	pop	r28
     6fe:	08 95       	ret

00000700 <assembleMessage>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
int assembleMessage(){
     700:	cf 93       	push	r28
     702:	df 93       	push	r29
     704:	00 d0       	rcall	.+0      	; 0x706 <assembleMessage+0x6>
     706:	00 d0       	rcall	.+0      	; 0x708 <assembleMessage+0x8>
     708:	00 d0       	rcall	.+0      	; 0x70a <assembleMessage+0xa>
     70a:	cd b7       	in	r28, 0x3d	; 61
     70c:	de b7       	in	r29, 0x3e	; 62
		char total,temp;
		int j;
		int final_data = 0b00000000;
     70e:	1c 82       	std	Y+4, r1	; 0x04
     710:	1b 82       	std	Y+3, r1	; 0x03
		total = getTotalNumOfBitsReceived();
     712:	0e 94 3a 02 	call	0x474	; 0x474 <getTotalNumOfBitsReceived>
     716:	8d 83       	std	Y+5, r24	; 0x05


        for(j = 0; j < total; j++){
     718:	1a 82       	std	Y+2, r1	; 0x02
     71a:	19 82       	std	Y+1, r1	; 0x01
     71c:	2d c0       	rjmp	.+90     	; 0x778 <assembleMessage+0x78>
            temp = incomingData[j];
     71e:	89 81       	ldd	r24, Y+1	; 0x01
     720:	9a 81       	ldd	r25, Y+2	; 0x02
     722:	8f 53       	subi	r24, 0x3F	; 63
     724:	9b 4f       	sbci	r25, 0xFB	; 251
     726:	fc 01       	movw	r30, r24
     728:	80 81       	ld	r24, Z
     72a:	8e 83       	std	Y+6, r24	; 0x06

            if(temp == 1 || temp == 0){
     72c:	8e 81       	ldd	r24, Y+6	; 0x06
     72e:	81 30       	cpi	r24, 0x01	; 1
     730:	19 f0       	breq	.+6      	; 0x738 <assembleMessage+0x38>
     732:	8e 81       	ldd	r24, Y+6	; 0x06
     734:	88 23       	and	r24, r24
     736:	89 f4       	brne	.+34     	; 0x75a <assembleMessage+0x5a>
                final_data |= (temp << j);
     738:	8e 81       	ldd	r24, Y+6	; 0x06
     73a:	08 2e       	mov	r0, r24
     73c:	00 0c       	add	r0, r0
     73e:	99 0b       	sbc	r25, r25
     740:	09 80       	ldd	r0, Y+1	; 0x01
     742:	02 c0       	rjmp	.+4      	; 0x748 <assembleMessage+0x48>
     744:	88 0f       	add	r24, r24
     746:	99 1f       	adc	r25, r25
     748:	0a 94       	dec	r0
     74a:	e2 f7       	brpl	.-8      	; 0x744 <assembleMessage+0x44>
     74c:	2b 81       	ldd	r18, Y+3	; 0x03
     74e:	3c 81       	ldd	r19, Y+4	; 0x04
     750:	82 2b       	or	r24, r18
     752:	93 2b       	or	r25, r19
     754:	9c 83       	std	Y+4, r25	; 0x04
     756:	8b 83       	std	Y+3, r24	; 0x03
     758:	0a c0       	rjmp	.+20     	; 0x76e <assembleMessage+0x6e>

            }
            else{
                final_data = ERROR;
     75a:	84 e6       	ldi	r24, 0x64	; 100
     75c:	90 e0       	ldi	r25, 0x00	; 0
     75e:	9c 83       	std	Y+4, r25	; 0x04
     760:	8b 83       	std	Y+3, r24	; 0x03
                j = total;
     762:	8d 81       	ldd	r24, Y+5	; 0x05
     764:	08 2e       	mov	r0, r24
     766:	00 0c       	add	r0, r0
     768:	99 0b       	sbc	r25, r25
     76a:	9a 83       	std	Y+2, r25	; 0x02
     76c:	89 83       	std	Y+1, r24	; 0x01
		int j;
		int final_data = 0b00000000;
		total = getTotalNumOfBitsReceived();


        for(j = 0; j < total; j++){
     76e:	89 81       	ldd	r24, Y+1	; 0x01
     770:	9a 81       	ldd	r25, Y+2	; 0x02
     772:	01 96       	adiw	r24, 0x01	; 1
     774:	9a 83       	std	Y+2, r25	; 0x02
     776:	89 83       	std	Y+1, r24	; 0x01
     778:	8d 81       	ldd	r24, Y+5	; 0x05
     77a:	28 2f       	mov	r18, r24
     77c:	88 0f       	add	r24, r24
     77e:	33 0b       	sbc	r19, r19
     780:	89 81       	ldd	r24, Y+1	; 0x01
     782:	9a 81       	ldd	r25, Y+2	; 0x02
     784:	82 17       	cp	r24, r18
     786:	93 07       	cpc	r25, r19
     788:	54 f2       	brlt	.-108    	; 0x71e <assembleMessage+0x1e>
                final_data = ERROR;
                j = total;
            }
        }

        setMessageAsExecuted(); //Now that we have dealt with our data, we do not have a new message anymore
     78a:	0e 94 23 02 	call	0x446	; 0x446 <setMessageAsExecuted>

        return final_data;
     78e:	8b 81       	ldd	r24, Y+3	; 0x03
     790:	9c 81       	ldd	r25, Y+4	; 0x04

}
     792:	26 96       	adiw	r28, 0x06	; 6
     794:	0f b6       	in	r0, 0x3f	; 63
     796:	f8 94       	cli
     798:	de bf       	out	0x3e, r29	; 62
     79a:	0f be       	out	0x3f, r0	; 63
     79c:	cd bf       	out	0x3d, r28	; 61
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	08 95       	ret

000007a4 <last_received_message>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
int last_received_message(void){
     7a4:	cf 93       	push	r28
     7a6:	df 93       	push	r29
     7a8:	cd b7       	in	r28, 0x3d	; 61
     7aa:	de b7       	in	r29, 0x3e	; 62
    return messageStatus;
     7ac:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <messageStatus>
     7b0:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <messageStatus+0x1>
}
     7b4:	df 91       	pop	r29
     7b6:	cf 91       	pop	r28
     7b8:	08 95       	ret

000007ba <reset_IR_Interrupt>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
void reset_IR_Interrupt(void){
     7ba:	cf 93       	push	r28
     7bc:	df 93       	push	r29
     7be:	cd b7       	in	r28, 0x3d	; 61
     7c0:	de b7       	in	r29, 0x3e	; 62
    timerStarted = FALSE;
     7c2:	10 92 d2 04 	sts	0x04D2, r1	; 0x8004d2 <timerStarted>
    preambleSuccessful = FALSE;
     7c6:	10 92 d1 04 	sts	0x04D1, r1	; 0x8004d1 <preambleSuccessful>
    PORTB &= ~(1 << PORTB3);
     7ca:	85 e2       	ldi	r24, 0x25	; 37
     7cc:	90 e0       	ldi	r25, 0x00	; 0
     7ce:	25 e2       	ldi	r18, 0x25	; 37
     7d0:	30 e0       	ldi	r19, 0x00	; 0
     7d2:	f9 01       	movw	r30, r18
     7d4:	20 81       	ld	r18, Z
     7d6:	27 7f       	andi	r18, 0xF7	; 247
     7d8:	fc 01       	movw	r30, r24
     7da:	20 83       	st	Z, r18
}
     7dc:	df 91       	pop	r29
     7de:	cf 91       	pop	r28
     7e0:	08 95       	ret

000007e2 <is_ISR_timed_out>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Bool is_ISR_timed_out(void){ //used to make sure that the ISR is functioning properly
     7e2:	cf 93       	push	r28
     7e4:	df 93       	push	r29
     7e6:	cd b7       	in	r28, 0x3d	; 61
     7e8:	de b7       	in	r29, 0x3e	; 62

    if(systmr_Elapsed(&IR_Timeout_Timer, (ISR_TIMEOUT_AMOUNT/2), SYSTMR_DO_NOT_RELOAD)){ //this is just testing if the message sending works properly
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	62 e3       	ldi	r22, 0x32	; 50
     7ee:	70 e0       	ldi	r23, 0x00	; 0
     7f0:	88 eb       	ldi	r24, 0xB8	; 184
     7f2:	94 e0       	ldi	r25, 0x04	; 4
     7f4:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <systmr_Elapsed>
     7f8:	88 23       	and	r24, r24
     7fa:	21 f0       	breq	.+8      	; 0x804 <is_ISR_timed_out+0x22>
        reset_IR_Interrupt();
     7fc:	0e 94 dd 03 	call	0x7ba	; 0x7ba <reset_IR_Interrupt>
        return TRUE;
     800:	81 e0       	ldi	r24, 0x01	; 1
     802:	01 c0       	rjmp	.+2      	; 0x806 <is_ISR_timed_out+0x24>
    }

    return FALSE;
     804:	80 e0       	ldi	r24, 0x00	; 0

}
     806:	df 91       	pop	r29
     808:	cf 91       	pop	r28
     80a:	08 95       	ret

0000080c <IR_checkForNewMessage>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
int IR_checkForNewMessage(void){
     80c:	cf 93       	push	r28
     80e:	df 93       	push	r29
     810:	00 d0       	rcall	.+0      	; 0x812 <IR_checkForNewMessage+0x6>
     812:	cd b7       	in	r28, 0x3d	; 61
     814:	de b7       	in	r29, 0x3e	; 62
    int receivedMessage;

    while(!is_ISR_timed_out()){
     816:	00 00       	nop
     818:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <is_ISR_timed_out>
     81c:	88 23       	and	r24, r24
     81e:	e1 f3       	breq	.-8      	; 0x818 <IR_checkForNewMessage+0xc>
        //do nothing because we are in the middle of receiving a message
		//If there is an incoming message, then we are going to want to assemble it.

    }

    if(!isMessageExecuted()){
     820:	0e 94 1a 02 	call	0x434	; 0x434 <isMessageExecuted>
     824:	88 23       	and	r24, r24
     826:	81 f4       	brne	.+32     	; 0x848 <IR_checkForNewMessage+0x3c>
        receivedMessage = assembleMessage();
     828:	0e 94 80 03 	call	0x700	; 0x700 <assembleMessage>
     82c:	9a 83       	std	Y+2, r25	; 0x02
     82e:	89 83       	std	Y+1, r24	; 0x01
        if(receivedMessage != RECEIVE_SUCCESSFUL){
     830:	89 81       	ldd	r24, Y+1	; 0x01
     832:	9a 81       	ldd	r25, Y+2	; 0x02
     834:	8c 3f       	cpi	r24, 0xFC	; 252
     836:	91 05       	cpc	r25, r1
     838:	59 f0       	breq	.+22     	; 0x850 <IR_checkForNewMessage+0x44>
            messageStatus = receivedMessage;
     83a:	89 81       	ldd	r24, Y+1	; 0x01
     83c:	9a 81       	ldd	r25, Y+2	; 0x02
     83e:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <messageStatus+0x1>
     842:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <messageStatus>
     846:	04 c0       	rjmp	.+8      	; 0x850 <IR_checkForNewMessage+0x44>
        }
    }
    else{
        receivedMessage = NO_NEW_MESSAGE;
     848:	8c ec       	ldi	r24, 0xCC	; 204
     84a:	90 e0       	ldi	r25, 0x00	; 0
     84c:	9a 83       	std	Y+2, r25	; 0x02
     84e:	89 83       	std	Y+1, r24	; 0x01
    }

    return receivedMessage;
     850:	89 81       	ldd	r24, Y+1	; 0x01
     852:	9a 81       	ldd	r25, Y+2	; 0x02

}
     854:	0f 90       	pop	r0
     856:	0f 90       	pop	r0
     858:	df 91       	pop	r29
     85a:	cf 91       	pop	r28
     85c:	08 95       	ret

0000085e <send_Acknowledgement>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
void send_Acknowledgement(void){
     85e:	cf 93       	push	r28
     860:	df 93       	push	r29
     862:	cd b7       	in	r28, 0x3d	; 61
     864:	de b7       	in	r29, 0x3e	; 62
    send_Message(RECEIVE_SUCCESSFUL);
     866:	8c ef       	ldi	r24, 0xFC	; 252
     868:	90 e0       	ldi	r25, 0x00	; 0
     86a:	0e 94 9b 02 	call	0x536	; 0x536 <send_Message>
}
     86e:	df 91       	pop	r29
     870:	cf 91       	pop	r28
     872:	08 95       	ret

00000874 <setData>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
void setData(int position, char data){
     874:	cf 93       	push	r28
     876:	df 93       	push	r29
     878:	00 d0       	rcall	.+0      	; 0x87a <setData+0x6>
     87a:	1f 92       	push	r1
     87c:	cd b7       	in	r28, 0x3d	; 61
     87e:	de b7       	in	r29, 0x3e	; 62
     880:	9a 83       	std	Y+2, r25	; 0x02
     882:	89 83       	std	Y+1, r24	; 0x01
     884:	6b 83       	std	Y+3, r22	; 0x03
    incomingData[position] = data;
     886:	89 81       	ldd	r24, Y+1	; 0x01
     888:	9a 81       	ldd	r25, Y+2	; 0x02
     88a:	8f 53       	subi	r24, 0x3F	; 63
     88c:	9b 4f       	sbci	r25, 0xFB	; 251
     88e:	2b 81       	ldd	r18, Y+3	; 0x03
     890:	fc 01       	movw	r30, r24
     892:	20 83       	st	Z, r18
}
     894:	0f 90       	pop	r0
     896:	0f 90       	pop	r0
     898:	0f 90       	pop	r0
     89a:	df 91       	pop	r29
     89c:	cf 91       	pop	r28
     89e:	08 95       	ret

000008a0 <__vector_2>:

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
ISR(INT1_vect) { //what happens when we receive an IR signal from the other satellite. This interupt will only store the data that it received. What happens to the data will be decided in main()
     8a0:	1f 92       	push	r1
     8a2:	0f 92       	push	r0
     8a4:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
     8a8:	0f 92       	push	r0
     8aa:	11 24       	eor	r1, r1
     8ac:	2f 93       	push	r18
     8ae:	3f 93       	push	r19
     8b0:	4f 93       	push	r20
     8b2:	5f 93       	push	r21
     8b4:	6f 93       	push	r22
     8b6:	7f 93       	push	r23
     8b8:	8f 93       	push	r24
     8ba:	9f 93       	push	r25
     8bc:	af 93       	push	r26
     8be:	bf 93       	push	r27
     8c0:	ef 93       	push	r30
     8c2:	ff 93       	push	r31
     8c4:	cf 93       	push	r28
     8c6:	df 93       	push	r29
     8c8:	cd b7       	in	r28, 0x3d	; 61
     8ca:	de b7       	in	r29, 0x3e	; 62
    PORTB ^= (1 << PORTB3);
     8cc:	85 e2       	ldi	r24, 0x25	; 37
     8ce:	90 e0       	ldi	r25, 0x00	; 0
     8d0:	25 e2       	ldi	r18, 0x25	; 37
     8d2:	30 e0       	ldi	r19, 0x00	; 0
     8d4:	f9 01       	movw	r30, r18
     8d6:	30 81       	ld	r19, Z
     8d8:	28 e0       	ldi	r18, 0x08	; 8
     8da:	23 27       	eor	r18, r19
     8dc:	fc 01       	movw	r30, r24
     8de:	20 83       	st	Z, r18
    static SysTicks_t elapsedTime;

    if( !timerStarted){
     8e0:	80 91 d2 04 	lds	r24, 0x04D2	; 0x8004d2 <timerStarted>
     8e4:	88 23       	and	r24, r24
     8e6:	61 f4       	brne	.+24     	; 0x900 <__vector_2+0x60>
        systmr_Load(&IR_Receiver_Timer); //start the timer
     8e8:	8f ea       	ldi	r24, 0xAF	; 175
     8ea:	94 e0       	ldi	r25, 0x04	; 4
     8ec:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <systmr_Load>
        timerStarted = TRUE;
     8f0:	81 e0       	ldi	r24, 0x01	; 1
     8f2:	80 93 d2 04 	sts	0x04D2, r24	; 0x8004d2 <timerStarted>
        systmr_Load(&IR_Timeout_Timer);
     8f6:	88 eb       	ldi	r24, 0xB8	; 184
     8f8:	94 e0       	ldi	r25, 0x04	; 4
     8fa:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <systmr_Load>
     8fe:	83 c0       	rjmp	.+262    	; 0xa06 <__vector_2+0x166>
    }

    else{

        //Stop the timer and decypher the data
        elapsedTime = systmr_Time(&IR_Receiver_Timer);
     900:	8f ea       	ldi	r24, 0xAF	; 175
     902:	94 e0       	ldi	r25, 0x04	; 4
     904:	0e 94 5f 0b 	call	0x16be	; 0x16be <systmr_Time>
     908:	90 93 d9 04 	sts	0x04D9, r25	; 0x8004d9 <elapsedTime.1870+0x1>
     90c:	80 93 d8 04 	sts	0x04D8, r24	; 0x8004d8 <elapsedTime.1870>
        elapsedTime = 2 * elapsedTime; //we have to multiply by two since systmr_Time returns amount of ticks, and each tick = 2 ms (not one)
     910:	80 91 d8 04 	lds	r24, 0x04D8	; 0x8004d8 <elapsedTime.1870>
     914:	90 91 d9 04 	lds	r25, 0x04D9	; 0x8004d9 <elapsedTime.1870+0x1>
     918:	88 0f       	add	r24, r24
     91a:	99 1f       	adc	r25, r25
     91c:	90 93 d9 04 	sts	0x04D9, r25	; 0x8004d9 <elapsedTime.1870+0x1>
     920:	80 93 d8 04 	sts	0x04D8, r24	; 0x8004d8 <elapsedTime.1870>

        //Now we decide what to do with the data...
		if( isWithinErrorMargin(elapsedTime,bit_value_low) ){
     924:	80 91 d8 04 	lds	r24, 0x04D8	; 0x8004d8 <elapsedTime.1870>
     928:	90 91 d9 04 	lds	r25, 0x04D9	; 0x8004d9 <elapsedTime.1870+0x1>
     92c:	62 e0       	ldi	r22, 0x02	; 2
     92e:	0e 94 55 02 	call	0x4aa	; 0x4aa <isWithinErrorMargin>
     932:	88 23       	and	r24, r24
     934:	91 f0       	breq	.+36     	; 0x95a <__vector_2+0xba>
            k++;
     936:	80 91 d6 04 	lds	r24, 0x04D6	; 0x8004d6 <k>
     93a:	90 91 d7 04 	lds	r25, 0x04D7	; 0x8004d7 <k+0x1>
     93e:	01 96       	adiw	r24, 0x01	; 1
     940:	90 93 d7 04 	sts	0x04D7, r25	; 0x8004d7 <k+0x1>
     944:	80 93 d6 04 	sts	0x04D6, r24	; 0x8004d6 <k>
			setData(k-1,0);
     948:	80 91 d6 04 	lds	r24, 0x04D6	; 0x8004d6 <k>
     94c:	90 91 d7 04 	lds	r25, 0x04D7	; 0x8004d7 <k+0x1>
     950:	01 97       	sbiw	r24, 0x01	; 1
     952:	60 e0       	ldi	r22, 0x00	; 0
     954:	0e 94 3a 04 	call	0x874	; 0x874 <setData>
     958:	54 c0       	rjmp	.+168    	; 0xa02 <__vector_2+0x162>

		}
		else if( isWithinErrorMargin(elapsedTime,bit_value_high) ){
     95a:	80 91 d8 04 	lds	r24, 0x04D8	; 0x8004d8 <elapsedTime.1870>
     95e:	90 91 d9 04 	lds	r25, 0x04D9	; 0x8004d9 <elapsedTime.1870+0x1>
     962:	66 e0       	ldi	r22, 0x06	; 6
     964:	0e 94 55 02 	call	0x4aa	; 0x4aa <isWithinErrorMargin>
     968:	88 23       	and	r24, r24
     96a:	91 f0       	breq	.+36     	; 0x990 <__vector_2+0xf0>
		    k++;
     96c:	80 91 d6 04 	lds	r24, 0x04D6	; 0x8004d6 <k>
     970:	90 91 d7 04 	lds	r25, 0x04D7	; 0x8004d7 <k+0x1>
     974:	01 96       	adiw	r24, 0x01	; 1
     976:	90 93 d7 04 	sts	0x04D7, r25	; 0x8004d7 <k+0x1>
     97a:	80 93 d6 04 	sts	0x04D6, r24	; 0x8004d6 <k>
			setData(k-1,1);
     97e:	80 91 d6 04 	lds	r24, 0x04D6	; 0x8004d6 <k>
     982:	90 91 d7 04 	lds	r25, 0x04D7	; 0x8004d7 <k+0x1>
     986:	01 97       	sbiw	r24, 0x01	; 1
     988:	61 e0       	ldi	r22, 0x01	; 1
     98a:	0e 94 3a 04 	call	0x874	; 0x874 <setData>
     98e:	39 c0       	rjmp	.+114    	; 0xa02 <__vector_2+0x162>

		}

        else if( isWithinErrorMargin(elapsedTime,preamble_Length) ){
     990:	80 91 d8 04 	lds	r24, 0x04D8	; 0x8004d8 <elapsedTime.1870>
     994:	90 91 d9 04 	lds	r25, 0x04D9	; 0x8004d9 <elapsedTime.1870+0x1>
     998:	6a e0       	ldi	r22, 0x0A	; 10
     99a:	0e 94 55 02 	call	0x4aa	; 0x4aa <isWithinErrorMargin>
     99e:	88 23       	and	r24, r24
     9a0:	41 f0       	breq	.+16     	; 0x9b2 <__vector_2+0x112>
			//setTotalBitsReceived(0); //reset the counter
            preambleSuccessful = TRUE;
     9a2:	81 e0       	ldi	r24, 0x01	; 1
     9a4:	80 93 d1 04 	sts	0x04D1, r24	; 0x8004d1 <preambleSuccessful>
            k = 0;
     9a8:	10 92 d7 04 	sts	0x04D7, r1	; 0x8004d7 <k+0x1>
     9ac:	10 92 d6 04 	sts	0x04D6, r1	; 0x8004d6 <k>
     9b0:	28 c0       	rjmp	.+80     	; 0xa02 <__vector_2+0x162>
        }

        else if( isWithinErrorMargin(elapsedTime, end_Transmission_Length) ){
     9b2:	80 91 d8 04 	lds	r24, 0x04D8	; 0x8004d8 <elapsedTime.1870>
     9b6:	90 91 d9 04 	lds	r25, 0x04D9	; 0x8004d9 <elapsedTime.1870+0x1>
     9ba:	6e e0       	ldi	r22, 0x0E	; 14
     9bc:	0e 94 55 02 	call	0x4aa	; 0x4aa <isWithinErrorMargin>
     9c0:	88 23       	and	r24, r24
     9c2:	f9 f0       	breq	.+62     	; 0xa02 <__vector_2+0x162>
            PORTB &= ~(1 << PORTB3);
     9c4:	85 e2       	ldi	r24, 0x25	; 37
     9c6:	90 e0       	ldi	r25, 0x00	; 0
     9c8:	25 e2       	ldi	r18, 0x25	; 37
     9ca:	30 e0       	ldi	r19, 0x00	; 0
     9cc:	f9 01       	movw	r30, r18
     9ce:	20 81       	ld	r18, Z
     9d0:	27 7f       	andi	r18, 0xF7	; 247
     9d2:	fc 01       	movw	r30, r24
     9d4:	20 83       	st	Z, r18
            messageExecuted = FALSE;
     9d6:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__data_start>
			setTotalBitsReceived(k);
     9da:	80 91 d6 04 	lds	r24, 0x04D6	; 0x8004d6 <k>
     9de:	90 91 d7 04 	lds	r25, 0x04D7	; 0x8004d7 <k+0x1>
     9e2:	0e 94 2d 02 	call	0x45a	; 0x45a <setTotalBitsReceived>
            if(preambleSuccessful){ //If this satellite received both the preamble and the end_transmission successfully, then it is safe to assume that the data was a success
     9e6:	80 91 d1 04 	lds	r24, 0x04D1	; 0x8004d1 <preambleSuccessful>
     9ea:	88 23       	and	r24, r24
     9ec:	51 f0       	breq	.+20     	; 0xa02 <__vector_2+0x162>
                delay_ms(50);
     9ee:	82 e3       	ldi	r24, 0x32	; 50
     9f0:	90 e0       	ldi	r25, 0x00	; 0
     9f2:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <delay_ms>
                if(sendAck == TRUE){
     9f6:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <sendAck>
     9fa:	81 30       	cpi	r24, 0x01	; 1
     9fc:	11 f4       	brne	.+4      	; 0xa02 <__vector_2+0x162>
                    send_Acknowledgement();
     9fe:	0e 94 2f 04 	call	0x85e	; 0x85e <send_Acknowledgement>
                }
            }
        }
        timerStarted = FALSE; //so we will start the timer the next time the interrupt is triggered
     a02:	10 92 d2 04 	sts	0x04D2, r1	; 0x8004d2 <timerStarted>
    }

}
     a06:	df 91       	pop	r29
     a08:	cf 91       	pop	r28
     a0a:	ff 91       	pop	r31
     a0c:	ef 91       	pop	r30
     a0e:	bf 91       	pop	r27
     a10:	af 91       	pop	r26
     a12:	9f 91       	pop	r25
     a14:	8f 91       	pop	r24
     a16:	7f 91       	pop	r23
     a18:	6f 91       	pop	r22
     a1a:	5f 91       	pop	r21
     a1c:	4f 91       	pop	r20
     a1e:	3f 91       	pop	r19
     a20:	2f 91       	pop	r18
     a22:	0f 90       	pop	r0
     a24:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
     a28:	0f 90       	pop	r0
     a2a:	1f 90       	pop	r1
     a2c:	18 95       	reti

00000a2e <main>:


//Gloabal variables
static char recievedMessage = NO_NEW_MESSAGE;

int main(void) {
     a2e:	cf 93       	push	r28
     a30:	df 93       	push	r29
     a32:	cd b7       	in	r28, 0x3d	; 61
     a34:	de b7       	in	r29, 0x3e	; 62
     a36:	29 97       	sbiw	r28, 0x09	; 9
     a38:	0f b6       	in	r0, 0x3f	; 63
     a3a:	f8 94       	cli
     a3c:	de bf       	out	0x3e, r29	; 62
     a3e:	0f be       	out	0x3f, r0	; 63
     a40:	cd bf       	out	0x3d, r28	; 61
    //Setup starts here!
    // initialize the system
    tmr0_Init(); //This is used for IR communication
     a42:	0e 94 0d 0c 	call	0x181a	; 0x181a <tmr0_Init>
    tmr3_Init(); //This is used as the systmr
     a46:	0e 94 62 0e 	call	0x1cc4	; 0x1cc4 <tmr3_Init>
    IR_Communication_System_Init(tmr3_Get2msTicks_u16);
     a4a:	8d e1       	ldi	r24, 0x1D	; 29
     a4c:	9e e0       	ldi	r25, 0x0E	; 14
     a4e:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <IR_Communication_System_Init>


    //This following is just a setup for timer. This is not currently used, and therefore it is commented out
    SysTimer_t timer1; //Declares an instance of a new timer
    systmr_Init(&timer1, tmr3_Get2msTicks_u16); //We are using 16 bits, so that the timer may count to a higher value
     a52:	6d e1       	ldi	r22, 0x1D	; 29
     a54:	7e e0       	ldi	r23, 0x0E	; 14
     a56:	ce 01       	movw	r24, r28
     a58:	01 96       	adiw	r24, 0x01	; 1
     a5a:	0e 94 39 0a 	call	0x1472	; 0x1472 <systmr_Init>
    systmr_Load(&timer1); //Load the timer before starting. This is used as a referenece point.
     a5e:	ce 01       	movw	r24, r28
     a60:	01 96       	adiw	r24, 0x01	; 1
     a62:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <systmr_Load>

    //init test LED
    DDRD |= (1 << PORTD7);
     a66:	8a e2       	ldi	r24, 0x2A	; 42
     a68:	90 e0       	ldi	r25, 0x00	; 0
     a6a:	2a e2       	ldi	r18, 0x2A	; 42
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	f9 01       	movw	r30, r18
     a70:	20 81       	ld	r18, Z
     a72:	20 68       	ori	r18, 0x80	; 128
     a74:	fc 01       	movw	r30, r24
     a76:	20 83       	st	Z, r18
    //PORTD &= ~(1<<PORTD7);

    SCM_Init();
     a78:	0e 94 42 06 	call	0xc84	; 0xc84 <SCM_Init>
    while (1) {
        if(systmr_Elapsed(&timer1, (1000/2), SYSTMR_RELOAD)){ //this is just testing if the message sending works properly
     a7c:	41 e0       	ldi	r20, 0x01	; 1
     a7e:	64 ef       	ldi	r22, 0xF4	; 244
     a80:	71 e0       	ldi	r23, 0x01	; 1
     a82:	ce 01       	movw	r24, r28
     a84:	01 96       	adiw	r24, 0x01	; 1
     a86:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <systmr_Elapsed>
     a8a:	88 23       	and	r24, r24
     a8c:	51 f0       	breq	.+20     	; 0xaa2 <main+0x74>
            //send_Message(5);
            PORTD ^= (1<<PORTD7);
     a8e:	8b e2       	ldi	r24, 0x2B	; 43
     a90:	90 e0       	ldi	r25, 0x00	; 0
     a92:	2b e2       	ldi	r18, 0x2B	; 43
     a94:	30 e0       	ldi	r19, 0x00	; 0
     a96:	f9 01       	movw	r30, r18
     a98:	30 81       	ld	r19, Z
     a9a:	20 e8       	ldi	r18, 0x80	; 128
     a9c:	23 27       	eor	r18, r19
     a9e:	fc 01       	movw	r30, r24
     aa0:	20 83       	st	Z, r18
        }
    }
     aa2:	ec cf       	rjmp	.-40     	; 0xa7c <main+0x4e>

00000aa4 <obc_post>:

//Static Global Variables-----------------------------------------------------------------------------------------------------


//Functions-------------------------------------------------------------------------------------------------------------------
void obc_post(void) {
     aa4:	cf 93       	push	r28
     aa6:	df 93       	push	r29
     aa8:	cd b7       	in	r28, 0x3d	; 61
     aaa:	de b7       	in	r29, 0x3e	; 62

}
     aac:	df 91       	pop	r29
     aae:	cf 91       	pop	r28
     ab0:	08 95       	ret

00000ab2 <power_on>:

Bool power_on( void ) {
     ab2:	cf 93       	push	r28
     ab4:	df 93       	push	r29
     ab6:	00 d0       	rcall	.+0      	; 0xab8 <power_on+0x6>
     ab8:	cd b7       	in	r28, 0x3d	; 61
     aba:	de b7       	in	r29, 0x3e	; 62
    //switch parts on
    //if part not on immediately, try 3x
    int x = 1;
     abc:	81 e0       	ldi	r24, 0x01	; 1
     abe:	90 e0       	ldi	r25, 0x00	; 0
     ac0:	9a 83       	std	Y+2, r25	; 0x02
     ac2:	89 83       	std	Y+1, r24	; 0x01
    printf("init power_on ");
     ac4:	89 e4       	ldi	r24, 0x49	; 73
     ac6:	91 e0       	ldi	r25, 0x01	; 1
     ac8:	89 2f       	mov	r24, r25
     aca:	8f 93       	push	r24
     acc:	89 e4       	ldi	r24, 0x49	; 73
     ace:	91 e0       	ldi	r25, 0x01	; 1
     ad0:	8f 93       	push	r24
     ad2:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <printf>
     ad6:	0f 90       	pop	r0
     ad8:	0f 90       	pop	r0
    if (x == 1 ) {
     ada:	89 81       	ldd	r24, Y+1	; 0x01
     adc:	9a 81       	ldd	r25, Y+2	; 0x02
     ade:	01 97       	sbiw	r24, 0x01	; 1
     ae0:	11 f4       	brne	.+4      	; 0xae6 <power_on+0x34>
        return TRUE;
     ae2:	81 e0       	ldi	r24, 0x01	; 1
     ae4:	01 c0       	rjmp	.+2      	; 0xae8 <power_on+0x36>
    } else {
        return FALSE;
     ae6:	80 e0       	ldi	r24, 0x00	; 0
    }

}
     ae8:	0f 90       	pop	r0
     aea:	0f 90       	pop	r0
     aec:	df 91       	pop	r29
     aee:	cf 91       	pop	r28
     af0:	08 95       	ret

00000af2 <imu_post>:

void imu_post(void) {
     af2:	cf 93       	push	r28
     af4:	df 93       	push	r29
     af6:	cd b7       	in	r28, 0x3d	; 61
     af8:	de b7       	in	r29, 0x3e	; 62
    /*if ( power_on(void) = TRUE ){            //NOT YET DEFINED
        //calibrate imu
        return;
    }*/
    printf("init imu_post ");
     afa:	88 e5       	ldi	r24, 0x58	; 88
     afc:	91 e0       	ldi	r25, 0x01	; 1
     afe:	89 2f       	mov	r24, r25
     b00:	8f 93       	push	r24
     b02:	88 e5       	ldi	r24, 0x58	; 88
     b04:	91 e0       	ldi	r25, 0x01	; 1
     b06:	8f 93       	push	r24
     b08:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <printf>
     b0c:	0f 90       	pop	r0
     b0e:	0f 90       	pop	r0
    return;
     b10:	00 00       	nop

}
     b12:	df 91       	pop	r29
     b14:	cf 91       	pop	r28
     b16:	08 95       	ret

00000b18 <run_lvsm>:

void run_lvsm (void) {
     b18:	cf 93       	push	r28
     b1a:	df 93       	push	r29
     b1c:	cd b7       	in	r28, 0x3d	; 61
     b1e:	de b7       	in	r29, 0x3e	; 62
    //wait for some time here...tbd by nsl
    //imu_post(void);     //imu calibrated
    //enable_IR_interrupt(void);
    //data sent to simplex
    //NOTE: RUN HEALTH AND SAFETY ONLY AFTER LVSM OP DONE
    power_on();
     b20:	0e 94 59 05 	call	0xab2	; 0xab2 <power_on>
    imu_post();
     b24:	0e 94 79 05 	call	0xaf2	; 0xaf2 <imu_post>
    printf("LVSM is running\n\n");
     b28:	87 e6       	ldi	r24, 0x67	; 103
     b2a:	91 e0       	ldi	r25, 0x01	; 1
     b2c:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
}
     b30:	df 91       	pop	r29
     b32:	cf 91       	pop	r28
     b34:	08 95       	ret

00000b36 <power_loop_on>:
//Functions-------------------------------------------------------------------------------------------------------------------
/**
 * initalizes phantom loop current
 * @return
 */
bool power_loop_on(void) {
     b36:	cf 93       	push	r28
     b38:	df 93       	push	r29
     b3a:	cd b7       	in	r28, 0x3d	; 61
     b3c:	de b7       	in	r29, 0x3e	; 62
    initialize_phantom_loop_current();
     b3e:	0e 94 ef 05 	call	0xbde	; 0xbde <initialize_phantom_loop_current>
    if (current > 0) {
     b42:	80 91 da 04 	lds	r24, 0x04DA	; 0x8004da <current>
     b46:	90 91 db 04 	lds	r25, 0x04DB	; 0x8004db <current+0x1>
     b4a:	18 16       	cp	r1, r24
     b4c:	19 06       	cpc	r1, r25
     b4e:	b4 f4       	brge	.+44     	; 0xb7c <power_loop_on+0x46>
        get_phantom_loop_current();
     b50:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <get_phantom_loop_current>
        printf("Current was: %d\n", get_phantom_loop_current());
     b54:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <get_phantom_loop_current>
     b58:	29 2f       	mov	r18, r25
     b5a:	2f 93       	push	r18
     b5c:	8f 93       	push	r24
     b5e:	88 e7       	ldi	r24, 0x78	; 120
     b60:	91 e0       	ldi	r25, 0x01	; 1
     b62:	89 2f       	mov	r24, r25
     b64:	8f 93       	push	r24
     b66:	88 e7       	ldi	r24, 0x78	; 120
     b68:	91 e0       	ldi	r25, 0x01	; 1
     b6a:	8f 93       	push	r24
     b6c:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <printf>
     b70:	0f 90       	pop	r0
     b72:	0f 90       	pop	r0
     b74:	0f 90       	pop	r0
     b76:	0f 90       	pop	r0
        return true;
     b78:	81 e0       	ldi	r24, 0x01	; 1
     b7a:	02 c0       	rjmp	.+4      	; 0xb80 <power_loop_on+0x4a>
    } else {
        return handle_phantom_loop_error();
     b7c:	0e 94 d5 05 	call	0xbaa	; 0xbaa <handle_phantom_loop_error>
    }
}
     b80:	df 91       	pop	r29
     b82:	cf 91       	pop	r28
     b84:	08 95       	ret

00000b86 <power_loop_off>:

bool power_loop_off(void) {
     b86:	cf 93       	push	r28
     b88:	df 93       	push	r29
     b8a:	cd b7       	in	r28, 0x3d	; 61
     b8c:	de b7       	in	r29, 0x3e	; 62
    kill_current();
     b8e:	0e 94 08 06 	call	0xc10	; 0xc10 <kill_current>
    if (current == 0) return true;
     b92:	80 91 da 04 	lds	r24, 0x04DA	; 0x8004da <current>
     b96:	90 91 db 04 	lds	r25, 0x04DB	; 0x8004db <current+0x1>
     b9a:	89 2b       	or	r24, r25
     b9c:	11 f4       	brne	.+4      	; 0xba2 <power_loop_off+0x1c>
     b9e:	81 e0       	ldi	r24, 0x01	; 1
     ba0:	01 c0       	rjmp	.+2      	; 0xba4 <power_loop_off+0x1e>
    return false;
     ba2:	80 e0       	ldi	r24, 0x00	; 0
}
     ba4:	df 91       	pop	r29
     ba6:	cf 91       	pop	r28
     ba8:	08 95       	ret

00000baa <handle_phantom_loop_error>:

bool handle_phantom_loop_error(void) {
     baa:	cf 93       	push	r28
     bac:	df 93       	push	r29
     bae:	cd b7       	in	r28, 0x3d	; 61
     bb0:	de b7       	in	r29, 0x3e	; 62
    if (get_phantom_loop_current() > 0) return true; //try turning on again
     bb2:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <get_phantom_loop_current>
     bb6:	18 16       	cp	r1, r24
     bb8:	19 06       	cpc	r1, r25
     bba:	14 f4       	brge	.+4      	; 0xbc0 <handle_phantom_loop_error+0x16>
     bbc:	81 e0       	ldi	r24, 0x01	; 1
     bbe:	01 c0       	rjmp	.+2      	; 0xbc2 <handle_phantom_loop_error+0x18>
    return false;
     bc0:	80 e0       	ldi	r24, 0x00	; 0
}
     bc2:	df 91       	pop	r29
     bc4:	cf 91       	pop	r28
     bc6:	08 95       	ret

00000bc8 <get_phantom_loop_current>:

int get_phantom_loop_current(void) {
     bc8:	cf 93       	push	r28
     bca:	df 93       	push	r29
     bcc:	cd b7       	in	r28, 0x3d	; 61
     bce:	de b7       	in	r29, 0x3e	; 62
    return current;
     bd0:	80 91 da 04 	lds	r24, 0x04DA	; 0x8004da <current>
     bd4:	90 91 db 04 	lds	r25, 0x04DB	; 0x8004db <current+0x1>
}
     bd8:	df 91       	pop	r29
     bda:	cf 91       	pop	r28
     bdc:	08 95       	ret

00000bde <initialize_phantom_loop_current>:

int initialize_phantom_loop_current(void) {
     bde:	cf 93       	push	r28
     be0:	df 93       	push	r29
     be2:	00 d0       	rcall	.+0      	; 0xbe4 <initialize_phantom_loop_current+0x6>
     be4:	cd b7       	in	r28, 0x3d	; 61
     be6:	de b7       	in	r29, 0x3e	; 62
    current = rand()% 100;
     be8:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <rand>
     bec:	24 e6       	ldi	r18, 0x64	; 100
     bee:	30 e0       	ldi	r19, 0x00	; 0
     bf0:	b9 01       	movw	r22, r18
     bf2:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <__divmodhi4>
     bf6:	90 93 db 04 	sts	0x04DB, r25	; 0x8004db <current+0x1>
     bfa:	80 93 da 04 	sts	0x04DA, r24	; 0x8004da <current>
    return current;
     bfe:	80 91 da 04 	lds	r24, 0x04DA	; 0x8004da <current>
     c02:	90 91 db 04 	lds	r25, 0x04DB	; 0x8004db <current+0x1>
}
     c06:	0f 90       	pop	r0
     c08:	0f 90       	pop	r0
     c0a:	df 91       	pop	r29
     c0c:	cf 91       	pop	r28
     c0e:	08 95       	ret

00000c10 <kill_current>:

void kill_current() { current = 0; }
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	cd b7       	in	r28, 0x3d	; 61
     c16:	de b7       	in	r29, 0x3e	; 62
     c18:	10 92 db 04 	sts	0x04DB, r1	; 0x8004db <current+0x1>
     c1c:	10 92 da 04 	sts	0x04DA, r1	; 0x8004da <current>
     c20:	df 91       	pop	r29
     c22:	cf 91       	pop	r28
     c24:	08 95       	ret

00000c26 <measure_current>:

void measure_current(void) {
     c26:	cf 93       	push	r28
     c28:	df 93       	push	r29
     c2a:	cd b7       	in	r28, 0x3d	; 61
     c2c:	de b7       	in	r29, 0x3e	; 62
    printf("measure_current() ");
     c2e:	89 e8       	ldi	r24, 0x89	; 137
     c30:	91 e0       	ldi	r25, 0x01	; 1
     c32:	89 2f       	mov	r24, r25
     c34:	8f 93       	push	r24
     c36:	89 e8       	ldi	r24, 0x89	; 137
     c38:	91 e0       	ldi	r25, 0x01	; 1
     c3a:	8f 93       	push	r24
     c3c:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <printf>
     c40:	0f 90       	pop	r0
     c42:	0f 90       	pop	r0

}
     c44:	df 91       	pop	r29
     c46:	cf 91       	pop	r28
     c48:	08 95       	ret

00000c4a <run_plm>:

void run_plm(void) {
     c4a:	cf 93       	push	r28
     c4c:	df 93       	push	r29
     c4e:	cd b7       	in	r28, 0x3d	; 61
     c50:	de b7       	in	r29, 0x3e	; 62
    printf("Initalizing Phantom Loop Management\n");
     c52:	8c e9       	ldi	r24, 0x9C	; 156
     c54:	91 e0       	ldi	r25, 0x01	; 1
     c56:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
    if (power_loop_on()) printf("Phantom Loop started successfully\n");
     c5a:	0e 94 9b 05 	call	0xb36	; 0xb36 <power_loop_on>
     c5e:	88 23       	and	r24, r24
     c60:	21 f0       	breq	.+8      	; 0xc6a <run_plm+0x20>
     c62:	80 ec       	ldi	r24, 0xC0	; 192
     c64:	91 e0       	ldi	r25, 0x01	; 1
     c66:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
    get_phantom_loop_current();
     c6a:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <get_phantom_loop_current>
    if (power_loop_off()) printf("Phantom Loop ended successfully\n");
     c6e:	0e 94 c3 05 	call	0xb86	; 0xb86 <power_loop_off>
     c72:	88 23       	and	r24, r24
     c74:	21 f0       	breq	.+8      	; 0xc7e <run_plm+0x34>
     c76:	82 ee       	ldi	r24, 0xE2	; 226
     c78:	91 e0       	ldi	r25, 0x01	; 1
     c7a:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
}
     c7e:	df 91       	pop	r29
     c80:	cf 91       	pop	r28
     c82:	08 95       	ret

00000c84 <SCM_Init>:
static MODE last_recorded_mode = SEND_TO_SIMPLEX; //I only chose this mode because we will never start in this mode, and therefore it will not conflict when the satellite is first turned on.
static Bool enterHealthSafetyCheck = TRUE;
static Bool runRoutineOp = TRUE;
static MODE previousNonRoutineOpMode = LVSM;

void SCM_Init(void) {
     c84:	cf 93       	push	r28
     c86:	df 93       	push	r29
     c88:	cd b7       	in	r28, 0x3d	; 61
     c8a:	de b7       	in	r29, 0x3e	; 62
    //LVSM will be the first mode that each satellite enters, and therefore they should beinitialized this way.
    TUS.currentMode = LVSM;
     c8c:	10 92 f9 04 	sts	0x04F9, r1	; 0x8004f9 <TUS+0x1>
     c90:	10 92 f8 04 	sts	0x04F8, r1	; 0x8004f8 <TUS>
    PGS.currentMode = LVSM;
     c94:	10 92 f1 04 	sts	0x04F1, r1	; 0x8004f1 <PGS+0x1>
     c98:	10 92 f0 04 	sts	0x04F0, r1	; 0x8004f0 <PGS>
}
     c9c:	df 91       	pop	r29
     c9e:	cf 91       	pop	r28
     ca0:	08 95       	ret

00000ca2 <scm_change_current_mode>:
        runRoutineOp = TRUE;
    }
}
 */

void scm_change_current_mode(void) {
     ca2:	cf 93       	push	r28
     ca4:	df 93       	push	r29
     ca6:	cd b7       	in	r28, 0x3d	; 61
     ca8:	de b7       	in	r29, 0x3e	; 62
    switch(TUS.currentMode) {
     caa:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <TUS>
     cae:	90 91 f9 04 	lds	r25, 0x04F9	; 0x8004f9 <TUS+0x1>
     cb2:	82 30       	cpi	r24, 0x02	; 2
     cb4:	91 05       	cpc	r25, r1
     cb6:	31 f1       	breq	.+76     	; 0xd04 <scm_change_current_mode+0x62>
     cb8:	83 30       	cpi	r24, 0x03	; 3
     cba:	91 05       	cpc	r25, r1
     cbc:	28 f4       	brcc	.+10     	; 0xcc8 <scm_change_current_mode+0x26>
     cbe:	00 97       	sbiw	r24, 0x00	; 0
     cc0:	61 f0       	breq	.+24     	; 0xcda <scm_change_current_mode+0x38>
     cc2:	01 97       	sbiw	r24, 0x01	; 1
     cc4:	c1 f0       	breq	.+48     	; 0xcf6 <scm_change_current_mode+0x54>
     cc6:	30 c0       	rjmp	.+96     	; 0xd28 <scm_change_current_mode+0x86>
     cc8:	84 30       	cpi	r24, 0x04	; 4
     cca:	91 05       	cpc	r25, r1
     ccc:	11 f1       	breq	.+68     	; 0xd12 <scm_change_current_mode+0x70>
     cce:	84 30       	cpi	r24, 0x04	; 4
     cd0:	91 05       	cpc	r25, r1
     cd2:	50 f0       	brcs	.+20     	; 0xce8 <scm_change_current_mode+0x46>
     cd4:	05 97       	sbiw	r24, 0x05	; 5
     cd6:	21 f1       	breq	.+72     	; 0xd20 <scm_change_current_mode+0x7e>
     cd8:	27 c0       	rjmp	.+78     	; 0xd28 <scm_change_current_mode+0x86>
        case LVSM:
            TUS.currentMode = PLM;
     cda:	83 e0       	ldi	r24, 0x03	; 3
     cdc:	90 e0       	ldi	r25, 0x00	; 0
     cde:	90 93 f9 04 	sts	0x04F9, r25	; 0x8004f9 <TUS+0x1>
     ce2:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <TUS>
            break;
     ce6:	20 c0       	rjmp	.+64     	; 0xd28 <scm_change_current_mode+0x86>
        case PLM:
            TUS.currentMode = SMM;
     ce8:	81 e0       	ldi	r24, 0x01	; 1
     cea:	90 e0       	ldi	r25, 0x00	; 0
     cec:	90 93 f9 04 	sts	0x04F9, r25	; 0x8004f9 <TUS+0x1>
     cf0:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <TUS>
            break;
     cf4:	19 c0       	rjmp	.+50     	; 0xd28 <scm_change_current_mode+0x86>
        case SMM:
            TUS.currentMode = TMM;
     cf6:	82 e0       	ldi	r24, 0x02	; 2
     cf8:	90 e0       	ldi	r25, 0x00	; 0
     cfa:	90 93 f9 04 	sts	0x04F9, r25	; 0x8004f9 <TUS+0x1>
     cfe:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <TUS>
            //SendData();
            break;
     d02:	12 c0       	rjmp	.+36     	; 0xd28 <scm_change_current_mode+0x86>
        case TMM:
            TUS.currentMode = HEALTH_SAFETY_CHECK;
     d04:	84 e0       	ldi	r24, 0x04	; 4
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	90 93 f9 04 	sts	0x04F9, r25	; 0x8004f9 <TUS+0x1>
     d0c:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <TUS>
            break;
     d10:	0b c0       	rjmp	.+22     	; 0xd28 <scm_change_current_mode+0x86>
        case HEALTH_SAFETY_CHECK:
            TUS.currentMode = SEND_TO_SIMPLEX;
     d12:	85 e0       	ldi	r24, 0x05	; 5
     d14:	90 e0       	ldi	r25, 0x00	; 0
     d16:	90 93 f9 04 	sts	0x04F9, r25	; 0x8004f9 <TUS+0x1>
     d1a:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <TUS>
            break;
     d1e:	04 c0       	rjmp	.+8      	; 0xd28 <scm_change_current_mode+0x86>
        case SEND_TO_SIMPLEX:
            TUS.currentMode = LVSM;
     d20:	10 92 f9 04 	sts	0x04F9, r1	; 0x8004f9 <TUS+0x1>
     d24:	10 92 f8 04 	sts	0x04F8, r1	; 0x8004f8 <TUS>
    }
    send_Message(TUS.currentMode);
     d28:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <TUS>
     d2c:	90 91 f9 04 	lds	r25, 0x04F9	; 0x8004f9 <TUS+0x1>
     d30:	0e 94 9b 02 	call	0x536	; 0x536 <send_Message>
}
     d34:	df 91       	pop	r29
     d36:	cf 91       	pop	r28
     d38:	08 95       	ret

00000d3a <SCM_Set_Current_Mode>:

void SCM_Set_Current_Mode(SATELLITE *sat, char message) {
     d3a:	cf 93       	push	r28
     d3c:	df 93       	push	r29
     d3e:	00 d0       	rcall	.+0      	; 0xd40 <SCM_Set_Current_Mode+0x6>
     d40:	1f 92       	push	r1
     d42:	cd b7       	in	r28, 0x3d	; 61
     d44:	de b7       	in	r29, 0x3e	; 62
     d46:	9a 83       	std	Y+2, r25	; 0x02
     d48:	89 83       	std	Y+1, r24	; 0x01
     d4a:	6b 83       	std	Y+3, r22	; 0x03
    //We now determine what to do with the message that has been sent to us from the other satellite
    if (message != NO_NEW_MESSAGE && message != RECEIVE_SUCCESSFUL) {
        last_recorded_mode = sat->currentMode;
     d4c:	89 81       	ldd	r24, Y+1	; 0x01
     d4e:	9a 81       	ldd	r25, Y+2	; 0x02
     d50:	fc 01       	movw	r30, r24
     d52:	80 81       	ld	r24, Z
     d54:	91 81       	ldd	r25, Z+1	; 0x01
     d56:	90 93 06 01 	sts	0x0106, r25	; 0x800106 <last_recorded_mode+0x1>
     d5a:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <last_recorded_mode>
        sat->currentMode = message;
     d5e:	8b 81       	ldd	r24, Y+3	; 0x03
     d60:	28 2f       	mov	r18, r24
     d62:	88 0f       	add	r24, r24
     d64:	33 0b       	sbc	r19, r19
     d66:	89 81       	ldd	r24, Y+1	; 0x01
     d68:	9a 81       	ldd	r25, Y+2	; 0x02
     d6a:	fc 01       	movw	r30, r24
     d6c:	31 83       	std	Z+1, r19	; 0x01
     d6e:	20 83       	st	Z, r18
    }
    //else don't do anything
}
     d70:	0f 90       	pop	r0
     d72:	0f 90       	pop	r0
     d74:	0f 90       	pop	r0
     d76:	df 91       	pop	r29
     d78:	cf 91       	pop	r28
     d7a:	08 95       	ret

00000d7c <eat_time>:

void eat_time(void) {
     d7c:	cf 93       	push	r28
     d7e:	df 93       	push	r29
     d80:	00 d0       	rcall	.+0      	; 0xd82 <eat_time+0x6>
     d82:	00 d0       	rcall	.+0      	; 0xd84 <eat_time+0x8>
     d84:	00 d0       	rcall	.+0      	; 0xd86 <eat_time+0xa>
     d86:	cd b7       	in	r28, 0x3d	; 61
     d88:	de b7       	in	r29, 0x3e	; 62
    int k = 0;
     d8a:	1e 82       	std	Y+6, r1	; 0x06
     d8c:	1d 82       	std	Y+5, r1	; 0x05
    int i = 0;
     d8e:	1a 82       	std	Y+2, r1	; 0x02
     d90:	19 82       	std	Y+1, r1	; 0x01
    int j = 0;
     d92:	1c 82       	std	Y+4, r1	; 0x04
     d94:	1b 82       	std	Y+3, r1	; 0x03
    for (i=0 ; i < 100000; i++) {
     d96:	1a 82       	std	Y+2, r1	; 0x02
     d98:	19 82       	std	Y+1, r1	; 0x01
        for (j = 0; j < 10000; j++) {
     d9a:	1c 82       	std	Y+4, r1	; 0x04
     d9c:	1b 82       	std	Y+3, r1	; 0x03
     d9e:	0d c0       	rjmp	.+26     	; 0xdba <eat_time+0x3e>
            k = i + j;
     da0:	29 81       	ldd	r18, Y+1	; 0x01
     da2:	3a 81       	ldd	r19, Y+2	; 0x02
     da4:	8b 81       	ldd	r24, Y+3	; 0x03
     da6:	9c 81       	ldd	r25, Y+4	; 0x04
     da8:	82 0f       	add	r24, r18
     daa:	93 1f       	adc	r25, r19
     dac:	9e 83       	std	Y+6, r25	; 0x06
     dae:	8d 83       	std	Y+5, r24	; 0x05
void eat_time(void) {
    int k = 0;
    int i = 0;
    int j = 0;
    for (i=0 ; i < 100000; i++) {
        for (j = 0; j < 10000; j++) {
     db0:	8b 81       	ldd	r24, Y+3	; 0x03
     db2:	9c 81       	ldd	r25, Y+4	; 0x04
     db4:	01 96       	adiw	r24, 0x01	; 1
     db6:	9c 83       	std	Y+4, r25	; 0x04
     db8:	8b 83       	std	Y+3, r24	; 0x03
     dba:	8b 81       	ldd	r24, Y+3	; 0x03
     dbc:	9c 81       	ldd	r25, Y+4	; 0x04
     dbe:	80 31       	cpi	r24, 0x10	; 16
     dc0:	97 42       	sbci	r25, 0x27	; 39
     dc2:	74 f3       	brlt	.-36     	; 0xda0 <eat_time+0x24>

void eat_time(void) {
    int k = 0;
    int i = 0;
    int j = 0;
    for (i=0 ; i < 100000; i++) {
     dc4:	89 81       	ldd	r24, Y+1	; 0x01
     dc6:	9a 81       	ldd	r25, Y+2	; 0x02
     dc8:	01 96       	adiw	r24, 0x01	; 1
     dca:	9a 83       	std	Y+2, r25	; 0x02
     dcc:	89 83       	std	Y+1, r24	; 0x01
        for (j = 0; j < 10000; j++) {
            k = i + j;
        }
    }
     dce:	e5 cf       	rjmp	.-54     	; 0xd9a <eat_time+0x1e>

00000dd0 <SCM_Run_Current_Mode>:
}

void SCM_Run_Current_Mode(SATELLITE thisSatellite) {
     dd0:	cf 93       	push	r28
     dd2:	df 93       	push	r29
     dd4:	cd b7       	in	r28, 0x3d	; 61
     dd6:	de b7       	in	r29, 0x3e	; 62
     dd8:	28 97       	sbiw	r28, 0x08	; 8
     dda:	0f b6       	in	r0, 0x3f	; 63
     ddc:	f8 94       	cli
     dde:	de bf       	out	0x3e, r29	; 62
     de0:	0f be       	out	0x3f, r0	; 63
     de2:	cd bf       	out	0x3d, r28	; 61
     de4:	29 83       	std	Y+1, r18	; 0x01
     de6:	3a 83       	std	Y+2, r19	; 0x02
     de8:	4b 83       	std	Y+3, r20	; 0x03
     dea:	5c 83       	std	Y+4, r21	; 0x04
     dec:	6d 83       	std	Y+5, r22	; 0x05
     dee:	7e 83       	std	Y+6, r23	; 0x06
     df0:	8f 83       	std	Y+7, r24	; 0x07
     df2:	98 87       	std	Y+8, r25	; 0x08
//This describes what happens within each mode
//Each of these modes contains it's own .c and .h file. The plan is to call a function within this switch statement. The function is going to be declared in
//the individual .c and .h files
    switch (thisSatellite.currentMode) {
     df4:	89 81       	ldd	r24, Y+1	; 0x01
     df6:	9a 81       	ldd	r25, Y+2	; 0x02
     df8:	82 30       	cpi	r24, 0x02	; 2
     dfa:	91 05       	cpc	r25, r1
     dfc:	21 f1       	breq	.+72     	; 0xe46 <SCM_Run_Current_Mode+0x76>
     dfe:	83 30       	cpi	r24, 0x03	; 3
     e00:	91 05       	cpc	r25, r1
     e02:	28 f4       	brcc	.+10     	; 0xe0e <SCM_Run_Current_Mode+0x3e>
     e04:	00 97       	sbiw	r24, 0x00	; 0
     e06:	61 f0       	breq	.+24     	; 0xe20 <SCM_Run_Current_Mode+0x50>
     e08:	01 97       	sbiw	r24, 0x01	; 1
     e0a:	79 f0       	breq	.+30     	; 0xe2a <SCM_Run_Current_Mode+0x5a>
     e0c:	31 c0       	rjmp	.+98     	; 0xe70 <SCM_Run_Current_Mode+0xa0>
     e0e:	84 30       	cpi	r24, 0x04	; 4
     e10:	91 05       	cpc	r25, r1
     e12:	01 f1       	breq	.+64     	; 0xe54 <SCM_Run_Current_Mode+0x84>
     e14:	84 30       	cpi	r24, 0x04	; 4
     e16:	91 05       	cpc	r25, r1
     e18:	78 f0       	brcs	.+30     	; 0xe38 <SCM_Run_Current_Mode+0x68>
     e1a:	05 97       	sbiw	r24, 0x05	; 5
     e1c:	01 f1       	breq	.+64     	; 0xe5e <SCM_Run_Current_Mode+0x8e>
     e1e:	28 c0       	rjmp	.+80     	; 0xe70 <SCM_Run_Current_Mode+0xa0>
        case LVSM : //Launch Vehicle Separation Mode #0
            printf("RUN LVSM\n");
     e20:	82 e0       	ldi	r24, 0x02	; 2
     e22:	92 e0       	ldi	r25, 0x02	; 2
     e24:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
//            run_lvsm();
            break;
     e28:	23 c0       	rjmp	.+70     	; 0xe70 <SCM_Run_Current_Mode+0xa0>

        case SMM : //Science Measurement Mode #1
            printf("RUN SMM\n");
     e2a:	8b e0       	ldi	r24, 0x0B	; 11
     e2c:	92 e0       	ldi	r25, 0x02	; 2
     e2e:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
            run_smm();
     e32:	0e 94 67 08 	call	0x10ce	; 0x10ce <run_smm>
            break;
     e36:	1c c0       	rjmp	.+56     	; 0xe70 <SCM_Run_Current_Mode+0xa0>

        case PLM : // #3
            printf("RUN PLM\n\n");
     e38:	83 e1       	ldi	r24, 0x13	; 19
     e3a:	92 e0       	ldi	r25, 0x02	; 2
     e3c:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
            run_plm();
     e40:	0e 94 25 06 	call	0xc4a	; 0xc4a <run_plm>
            break;
     e44:	15 c0       	rjmp	.+42     	; 0xe70 <SCM_Run_Current_Mode+0xa0>

            case TMM : //Tether Measurement Mode #2
            printf("RUN TMM\n");
     e46:	8c e1       	ldi	r24, 0x1C	; 28
     e48:	92 e0       	ldi	r25, 0x02	; 2
     e4a:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
            run_tmm();
     e4e:	0e 94 9c 08 	call	0x1138	; 0x1138 <run_tmm>
            break;
     e52:	0e c0       	rjmp	.+28     	; 0xe70 <SCM_Run_Current_Mode+0xa0>

        case HEALTH_SAFETY_CHECK : // Health and safety #4
            printf("RUN HEALTH_AND_SAFETY\n");
     e54:	84 e2       	ldi	r24, 0x24	; 36
     e56:	92 e0       	ldi	r25, 0x02	; 2
     e58:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
//            run_health_safety_check();
            break;
     e5c:	09 c0       	rjmp	.+18     	; 0xe70 <SCM_Run_Current_Mode+0xa0>

        case SEND_TO_SIMPLEX : // #5
            printf("RUN SEND_TO_SIMPLEX\n");
     e5e:	8a e3       	ldi	r24, 0x3A	; 58
     e60:	92 e0       	ldi	r25, 0x02	; 2
     e62:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
            printf("Running SEND_TO_SIMPLEX\n\n");
     e66:	8e e4       	ldi	r24, 0x4E	; 78
     e68:	92 e0       	ldi	r25, 0x02	; 2
     e6a:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
            break;
     e6e:	00 00       	nop
    }

    eat_time();
     e70:	0e 94 be 06 	call	0xd7c	; 0xd7c <eat_time>
    printf("::CHANGING MODE::\n\n");
     e74:	87 e6       	ldi	r24, 0x67	; 103
     e76:	92 e0       	ldi	r25, 0x02	; 2
     e78:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
    scm_change_current_mode();
     e7c:	0e 94 51 06 	call	0xca2	; 0xca2 <scm_change_current_mode>
    eat_time();
     e80:	0e 94 be 06 	call	0xd7c	; 0xd7c <eat_time>
}
     e84:	28 96       	adiw	r28, 0x08	; 8
     e86:	0f b6       	in	r0, 0x3f	; 63
     e88:	f8 94       	cli
     e8a:	de bf       	out	0x3e, r29	; 62
     e8c:	0f be       	out	0x3f, r0	; 63
     e8e:	cd bf       	out	0x3d, r28	; 61
     e90:	df 91       	pop	r29
     e92:	cf 91       	pop	r28
     e94:	08 95       	ret

00000e96 <measure_light>:


//Functions-------------------------------------------------------------------------------------------------------------------


unsigned short measure_light(void) {              //are we measuring light intensity or presence?
     e96:	cf 93       	push	r28
     e98:	df 93       	push	r29
     e9a:	00 d0       	rcall	.+0      	; 0xe9c <measure_light+0x6>
     e9c:	cd b7       	in	r28, 0x3d	; 61
     e9e:	de b7       	in	r29, 0x3e	; 62
    unsigned short lightValue = Get_Ambient_Light();
     ea0:	0e 94 a2 09 	call	0x1344	; 0x1344 <Get_Ambient_Light>
     ea4:	9a 83       	std	Y+2, r25	; 0x02
     ea6:	89 83       	std	Y+1, r24	; 0x01
    if (lightValue == 0) return 0;// Handle Error Here
     ea8:	89 81       	ldd	r24, Y+1	; 0x01
     eaa:	9a 81       	ldd	r25, Y+2	; 0x02
     eac:	89 2b       	or	r24, r25
     eae:	19 f4       	brne	.+6      	; 0xeb6 <measure_light+0x20>
     eb0:	80 e0       	ldi	r24, 0x00	; 0
     eb2:	90 e0       	ldi	r25, 0x00	; 0
     eb4:	02 c0       	rjmp	.+4      	; 0xeba <measure_light+0x24>
    return lightValue;
     eb6:	89 81       	ldd	r24, Y+1	; 0x01
     eb8:	9a 81       	ldd	r25, Y+2	; 0x02

}
     eba:	0f 90       	pop	r0
     ebc:	0f 90       	pop	r0
     ebe:	df 91       	pop	r29
     ec0:	cf 91       	pop	r28
     ec2:	08 95       	ret

00000ec4 <measure_em>:

unsigned short measure_em(void) {
     ec4:	cf 93       	push	r28
     ec6:	df 93       	push	r29
     ec8:	00 d0       	rcall	.+0      	; 0xeca <measure_em+0x6>
     eca:	cd b7       	in	r28, 0x3d	; 61
     ecc:	de b7       	in	r29, 0x3e	; 62
    unsigned short emMeasure = getEmField();
     ece:	0e 94 7d 09 	call	0x12fa	; 0x12fa <getEmField>
     ed2:	9a 83       	std	Y+2, r25	; 0x02
     ed4:	89 83       	std	Y+1, r24	; 0x01
    if (emMeasure == 0)  return 0;// Handle Error Here
     ed6:	89 81       	ldd	r24, Y+1	; 0x01
     ed8:	9a 81       	ldd	r25, Y+2	; 0x02
     eda:	89 2b       	or	r24, r25
     edc:	19 f4       	brne	.+6      	; 0xee4 <measure_em+0x20>
     ede:	80 e0       	ldi	r24, 0x00	; 0
     ee0:	90 e0       	ldi	r25, 0x00	; 0
     ee2:	02 c0       	rjmp	.+4      	; 0xee8 <measure_em+0x24>
    return emMeasure;
     ee4:	89 81       	ldd	r24, Y+1	; 0x01
     ee6:	9a 81       	ldd	r25, Y+2	; 0x02

}
     ee8:	0f 90       	pop	r0
     eea:	0f 90       	pop	r0
     eec:	df 91       	pop	r29
     eee:	cf 91       	pop	r28
     ef0:	08 95       	ret

00000ef2 <measure_RotationX>:
short measure_RotationX(void) {
     ef2:	cf 93       	push	r28
     ef4:	df 93       	push	r29
     ef6:	00 d0       	rcall	.+0      	; 0xef8 <measure_RotationX+0x6>
     ef8:	cd b7       	in	r28, 0x3d	; 61
     efa:	de b7       	in	r29, 0x3e	; 62
    short rotationX = getRotationX();
     efc:	0e 94 c7 09 	call	0x138e	; 0x138e <getRotationX>
     f00:	9a 83       	std	Y+2, r25	; 0x02
     f02:	89 83       	std	Y+1, r24	; 0x01
   if (rotationX == 0) return 0; //ErrorHandling
     f04:	89 81       	ldd	r24, Y+1	; 0x01
     f06:	9a 81       	ldd	r25, Y+2	; 0x02
     f08:	89 2b       	or	r24, r25
     f0a:	19 f4       	brne	.+6      	; 0xf12 <measure_RotationX+0x20>
     f0c:	80 e0       	ldi	r24, 0x00	; 0
     f0e:	90 e0       	ldi	r25, 0x00	; 0
     f10:	02 c0       	rjmp	.+4      	; 0xf16 <measure_RotationX+0x24>
    return rotationX;
     f12:	89 81       	ldd	r24, Y+1	; 0x01
     f14:	9a 81       	ldd	r25, Y+2	; 0x02
}
     f16:	0f 90       	pop	r0
     f18:	0f 90       	pop	r0
     f1a:	df 91       	pop	r29
     f1c:	cf 91       	pop	r28
     f1e:	08 95       	ret

00000f20 <measure_RotationY>:
short measure_RotationY(void) {
     f20:	cf 93       	push	r28
     f22:	df 93       	push	r29
     f24:	00 d0       	rcall	.+0      	; 0xf26 <measure_RotationY+0x6>
     f26:	cd b7       	in	r28, 0x3d	; 61
     f28:	de b7       	in	r29, 0x3e	; 62
    short rotationY = getRotationY();
     f2a:	0e 94 dd 09 	call	0x13ba	; 0x13ba <getRotationY>
     f2e:	9a 83       	std	Y+2, r25	; 0x02
     f30:	89 83       	std	Y+1, r24	; 0x01
    if (rotationY == 0) return 0; //ErrorHandling
     f32:	89 81       	ldd	r24, Y+1	; 0x01
     f34:	9a 81       	ldd	r25, Y+2	; 0x02
     f36:	89 2b       	or	r24, r25
     f38:	19 f4       	brne	.+6      	; 0xf40 <measure_RotationY+0x20>
     f3a:	80 e0       	ldi	r24, 0x00	; 0
     f3c:	90 e0       	ldi	r25, 0x00	; 0
     f3e:	02 c0       	rjmp	.+4      	; 0xf44 <measure_RotationY+0x24>
    return rotationY;
     f40:	89 81       	ldd	r24, Y+1	; 0x01
     f42:	9a 81       	ldd	r25, Y+2	; 0x02
}
     f44:	0f 90       	pop	r0
     f46:	0f 90       	pop	r0
     f48:	df 91       	pop	r29
     f4a:	cf 91       	pop	r28
     f4c:	08 95       	ret

00000f4e <measure_RotationZ>:
short measure_RotationZ(void) {
     f4e:	cf 93       	push	r28
     f50:	df 93       	push	r29
     f52:	00 d0       	rcall	.+0      	; 0xf54 <measure_RotationZ+0x6>
     f54:	cd b7       	in	r28, 0x3d	; 61
     f56:	de b7       	in	r29, 0x3e	; 62
    short rotationZ = getRotationZ();
     f58:	0e 94 f5 09 	call	0x13ea	; 0x13ea <getRotationZ>
     f5c:	9a 83       	std	Y+2, r25	; 0x02
     f5e:	89 83       	std	Y+1, r24	; 0x01
    if (rotationZ == 0) return 0; //ErrorHandling
     f60:	89 81       	ldd	r24, Y+1	; 0x01
     f62:	9a 81       	ldd	r25, Y+2	; 0x02
     f64:	89 2b       	or	r24, r25
     f66:	19 f4       	brne	.+6      	; 0xf6e <measure_RotationZ+0x20>
     f68:	80 e0       	ldi	r24, 0x00	; 0
     f6a:	90 e0       	ldi	r25, 0x00	; 0
     f6c:	02 c0       	rjmp	.+4      	; 0xf72 <measure_RotationZ+0x24>
    return rotationZ;
     f6e:	89 81       	ldd	r24, Y+1	; 0x01
     f70:	9a 81       	ldd	r25, Y+2	; 0x02
}
     f72:	0f 90       	pop	r0
     f74:	0f 90       	pop	r0
     f76:	df 91       	pop	r29
     f78:	cf 91       	pop	r28
     f7a:	08 95       	ret

00000f7c <sendScienceMeasurements>:


void sendScienceMeasurements(void){
     f7c:	cf 93       	push	r28
     f7e:	df 93       	push	r29
     f80:	cd b7       	in	r28, 0x3d	; 61
     f82:	de b7       	in	r29, 0x3e	; 62
     f84:	2a 97       	sbiw	r28, 0x0a	; 10
     f86:	0f b6       	in	r0, 0x3f	; 63
     f88:	f8 94       	cli
     f8a:	de bf       	out	0x3e, r29	; 62
     f8c:	0f be       	out	0x3f, r0	; 63
     f8e:	cd bf       	out	0x3d, r28	; 61
    unsigned short light = measure_light();
     f90:	0e 94 4b 07 	call	0xe96	; 0xe96 <measure_light>
     f94:	9a 83       	std	Y+2, r25	; 0x02
     f96:	89 83       	std	Y+1, r24	; 0x01
    unsigned short emField =measure_em();
     f98:	0e 94 62 07 	call	0xec4	; 0xec4 <measure_em>
     f9c:	9c 83       	std	Y+4, r25	; 0x04
     f9e:	8b 83       	std	Y+3, r24	; 0x03
    short rotationX = measure_RotationX();
     fa0:	0e 94 79 07 	call	0xef2	; 0xef2 <measure_RotationX>
     fa4:	9e 83       	std	Y+6, r25	; 0x06
     fa6:	8d 83       	std	Y+5, r24	; 0x05
    short rotationY = measure_RotationY();
     fa8:	0e 94 90 07 	call	0xf20	; 0xf20 <measure_RotationY>
     fac:	98 87       	std	Y+8, r25	; 0x08
     fae:	8f 83       	std	Y+7, r24	; 0x07
    short rotationZ = measure_RotationZ();
     fb0:	0e 94 a7 07 	call	0xf4e	; 0xf4e <measure_RotationZ>
     fb4:	9a 87       	std	Y+10, r25	; 0x0a
     fb6:	89 87       	std	Y+9, r24	; 0x09

    if (light == 0){  //Testing Ambient Light
     fb8:	89 81       	ldd	r24, Y+1	; 0x01
     fba:	9a 81       	ldd	r25, Y+2	; 0x02
     fbc:	89 2b       	or	r24, r25
     fbe:	29 f4       	brne	.+10     	; 0xfca <sendScienceMeasurements+0x4e>
        printf("%s","There was an error in getting the ambient light \n");
     fc0:	8a e7       	ldi	r24, 0x7A	; 122
     fc2:	92 e0       	ldi	r25, 0x02	; 2
     fc4:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
     fc8:	11 c0       	rjmp	.+34     	; 0xfec <sendScienceMeasurements+0x70>
    } else{
        printf("Ambient light= %d\n", light);
     fca:	8a 81       	ldd	r24, Y+2	; 0x02
     fcc:	8f 93       	push	r24
     fce:	89 81       	ldd	r24, Y+1	; 0x01
     fd0:	8f 93       	push	r24
     fd2:	8b ea       	ldi	r24, 0xAB	; 171
     fd4:	92 e0       	ldi	r25, 0x02	; 2
     fd6:	89 2f       	mov	r24, r25
     fd8:	8f 93       	push	r24
     fda:	8b ea       	ldi	r24, 0xAB	; 171
     fdc:	92 e0       	ldi	r25, 0x02	; 2
     fde:	8f 93       	push	r24
     fe0:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <printf>
     fe4:	0f 90       	pop	r0
     fe6:	0f 90       	pop	r0
     fe8:	0f 90       	pop	r0
     fea:	0f 90       	pop	r0
    }
    if (emField == 0){  //TestingElectric Field
     fec:	8b 81       	ldd	r24, Y+3	; 0x03
     fee:	9c 81       	ldd	r25, Y+4	; 0x04
     ff0:	89 2b       	or	r24, r25
     ff2:	29 f4       	brne	.+10     	; 0xffe <sendScienceMeasurements+0x82>
        printf("%s","There was an error in getting the ElectroMagnetic Field \n");
     ff4:	8e eb       	ldi	r24, 0xBE	; 190
     ff6:	92 e0       	ldi	r25, 0x02	; 2
     ff8:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
     ffc:	11 c0       	rjmp	.+34     	; 0x1020 <sendScienceMeasurements+0xa4>
    } else{
        printf("Electric Field = %d\n", emField);
     ffe:	8c 81       	ldd	r24, Y+4	; 0x04
    1000:	8f 93       	push	r24
    1002:	8b 81       	ldd	r24, Y+3	; 0x03
    1004:	8f 93       	push	r24
    1006:	87 ef       	ldi	r24, 0xF7	; 247
    1008:	92 e0       	ldi	r25, 0x02	; 2
    100a:	89 2f       	mov	r24, r25
    100c:	8f 93       	push	r24
    100e:	87 ef       	ldi	r24, 0xF7	; 247
    1010:	92 e0       	ldi	r25, 0x02	; 2
    1012:	8f 93       	push	r24
    1014:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <printf>
    1018:	0f 90       	pop	r0
    101a:	0f 90       	pop	r0
    101c:	0f 90       	pop	r0
    101e:	0f 90       	pop	r0
    }
    if (rotationX == 0){  // Testing Rotation X
    1020:	8d 81       	ldd	r24, Y+5	; 0x05
    1022:	9e 81       	ldd	r25, Y+6	; 0x06
    1024:	89 2b       	or	r24, r25
    1026:	29 f4       	brne	.+10     	; 0x1032 <sendScienceMeasurements+0xb6>
        printf("%s","There was an error in getting rotation X \n");
    1028:	8c e0       	ldi	r24, 0x0C	; 12
    102a:	93 e0       	ldi	r25, 0x03	; 3
    102c:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
    1030:	11 c0       	rjmp	.+34     	; 0x1054 <sendScienceMeasurements+0xd8>
    } else{
        printf("Rotation X= %d\n", rotationX);
    1032:	8e 81       	ldd	r24, Y+6	; 0x06
    1034:	8f 93       	push	r24
    1036:	8d 81       	ldd	r24, Y+5	; 0x05
    1038:	8f 93       	push	r24
    103a:	86 e3       	ldi	r24, 0x36	; 54
    103c:	93 e0       	ldi	r25, 0x03	; 3
    103e:	89 2f       	mov	r24, r25
    1040:	8f 93       	push	r24
    1042:	86 e3       	ldi	r24, 0x36	; 54
    1044:	93 e0       	ldi	r25, 0x03	; 3
    1046:	8f 93       	push	r24
    1048:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <printf>
    104c:	0f 90       	pop	r0
    104e:	0f 90       	pop	r0
    1050:	0f 90       	pop	r0
    1052:	0f 90       	pop	r0
    }
    if (rotationY == 0){  //Testing Rotation Y
    1054:	8f 81       	ldd	r24, Y+7	; 0x07
    1056:	98 85       	ldd	r25, Y+8	; 0x08
    1058:	89 2b       	or	r24, r25
    105a:	29 f4       	brne	.+10     	; 0x1066 <sendScienceMeasurements+0xea>
        printf("There was an error in getting rotation Y \n");
    105c:	86 e4       	ldi	r24, 0x46	; 70
    105e:	93 e0       	ldi	r25, 0x03	; 3
    1060:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
    1064:	11 c0       	rjmp	.+34     	; 0x1088 <sendScienceMeasurements+0x10c>
    } else{
        printf("Rotation Y= %d\n", rotationY);
    1066:	88 85       	ldd	r24, Y+8	; 0x08
    1068:	8f 93       	push	r24
    106a:	8f 81       	ldd	r24, Y+7	; 0x07
    106c:	8f 93       	push	r24
    106e:	80 e7       	ldi	r24, 0x70	; 112
    1070:	93 e0       	ldi	r25, 0x03	; 3
    1072:	89 2f       	mov	r24, r25
    1074:	8f 93       	push	r24
    1076:	80 e7       	ldi	r24, 0x70	; 112
    1078:	93 e0       	ldi	r25, 0x03	; 3
    107a:	8f 93       	push	r24
    107c:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <printf>
    1080:	0f 90       	pop	r0
    1082:	0f 90       	pop	r0
    1084:	0f 90       	pop	r0
    1086:	0f 90       	pop	r0
    }
    if (rotationZ == 0){  //Testing Rotation Z
    1088:	89 85       	ldd	r24, Y+9	; 0x09
    108a:	9a 85       	ldd	r25, Y+10	; 0x0a
    108c:	89 2b       	or	r24, r25
    108e:	29 f4       	brne	.+10     	; 0x109a <sendScienceMeasurements+0x11e>
        printf("%s","There was an error in getting rotation Z \n");
    1090:	80 e8       	ldi	r24, 0x80	; 128
    1092:	93 e0       	ldi	r25, 0x03	; 3
    1094:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
    1098:	11 c0       	rjmp	.+34     	; 0x10bc <sendScienceMeasurements+0x140>
    } else{
        printf("Rotation Z= %d\n", rotationZ);
    109a:	8a 85       	ldd	r24, Y+10	; 0x0a
    109c:	8f 93       	push	r24
    109e:	89 85       	ldd	r24, Y+9	; 0x09
    10a0:	8f 93       	push	r24
    10a2:	8a ea       	ldi	r24, 0xAA	; 170
    10a4:	93 e0       	ldi	r25, 0x03	; 3
    10a6:	89 2f       	mov	r24, r25
    10a8:	8f 93       	push	r24
    10aa:	8a ea       	ldi	r24, 0xAA	; 170
    10ac:	93 e0       	ldi	r25, 0x03	; 3
    10ae:	8f 93       	push	r24
    10b0:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <printf>
    10b4:	0f 90       	pop	r0
    10b6:	0f 90       	pop	r0
    10b8:	0f 90       	pop	r0
    10ba:	0f 90       	pop	r0
    }
}
    10bc:	2a 96       	adiw	r28, 0x0a	; 10
    10be:	0f b6       	in	r0, 0x3f	; 63
    10c0:	f8 94       	cli
    10c2:	de bf       	out	0x3e, r29	; 62
    10c4:	0f be       	out	0x3f, r0	; 63
    10c6:	cd bf       	out	0x3d, r28	; 61
    10c8:	df 91       	pop	r29
    10ca:	cf 91       	pop	r28
    10cc:	08 95       	ret

000010ce <run_smm>:
void run_smm()
{
    10ce:	cf 93       	push	r28
    10d0:	df 93       	push	r29
    10d2:	cd b7       	in	r28, 0x3d	; 61
    10d4:	de b7       	in	r29, 0x3e	; 62
    send_Message("Start Measurements");
    10d6:	8a eb       	ldi	r24, 0xBA	; 186
    10d8:	93 e0       	ldi	r25, 0x03	; 3
    10da:	0e 94 9b 02 	call	0x536	; 0x536 <send_Message>
	sendScienceMeasurements();
    10de:	0e 94 be 07 	call	0xf7c	; 0xf7c <sendScienceMeasurements>
	send_Message("Stop Measurements");
    10e2:	8d ec       	ldi	r24, 0xCD	; 205
    10e4:	93 e0       	ldi	r25, 0x03	; 3
    10e6:	0e 94 9b 02 	call	0x536	; 0x536 <send_Message>
}
    10ea:	df 91       	pop	r29
    10ec:	cf 91       	pop	r28
    10ee:	08 95       	ret

000010f0 <measure_strain>:
const int lengthToExtendTether = 5;


//Functions-------------------------------------------------------------------------------------------------------------------

void measure_strain(void) {
    10f0:	cf 93       	push	r28
    10f2:	df 93       	push	r29
    10f4:	cd b7       	in	r28, 0x3d	; 61
    10f6:	de b7       	in	r29, 0x3e	; 62
	printf("init measure_strain() ");
    10f8:	81 ee       	ldi	r24, 0xE1	; 225
    10fa:	93 e0       	ldi	r25, 0x03	; 3
    10fc:	89 2f       	mov	r24, r25
    10fe:	8f 93       	push	r24
    1100:	81 ee       	ldi	r24, 0xE1	; 225
    1102:	93 e0       	ldi	r25, 0x03	; 3
    1104:	8f 93       	push	r24
    1106:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <printf>
    110a:	0f 90       	pop	r0
    110c:	0f 90       	pop	r0
}
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	08 95       	ret

00001114 <check_buffer>:

void check_buffer() {
    1114:	cf 93       	push	r28
    1116:	df 93       	push	r29
    1118:	cd b7       	in	r28, 0x3d	; 61
    111a:	de b7       	in	r29, 0x3e	; 62
	printf("init check_buffer() ");
    111c:	88 ef       	ldi	r24, 0xF8	; 248
    111e:	93 e0       	ldi	r25, 0x03	; 3
    1120:	89 2f       	mov	r24, r25
    1122:	8f 93       	push	r24
    1124:	88 ef       	ldi	r24, 0xF8	; 248
    1126:	93 e0       	ldi	r25, 0x03	; 3
    1128:	8f 93       	push	r24
    112a:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <printf>
    112e:	0f 90       	pop	r0
    1130:	0f 90       	pop	r0
}
    1132:	df 91       	pop	r29
    1134:	cf 91       	pop	r28
    1136:	08 95       	ret

00001138 <run_tmm>:

void run_tmm() {
    1138:	cf 93       	push	r28
    113a:	df 93       	push	r29
    113c:	cd b7       	in	r28, 0x3d	; 61
    113e:	de b7       	in	r29, 0x3e	; 62
	measure_strain();
    1140:	0e 94 78 08 	call	0x10f0	; 0x10f0 <measure_strain>
	check_buffer();
    1144:	0e 94 8a 08 	call	0x1114	; 0x1114 <check_buffer>
	printf("TMM is running\n\n");
    1148:	8d e0       	ldi	r24, 0x0D	; 13
    114a:	94 e0       	ldi	r25, 0x04	; 4
    114c:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
	sendTetherExtensionSignal(lengthToExtendTether);
    1150:	85 e0       	ldi	r24, 0x05	; 5
    1152:	90 e0       	ldi	r25, 0x00	; 0
    1154:	0e 94 c7 08 	call	0x118e	; 0x118e <sendTetherExtensionSignal>
}
    1158:	df 91       	pop	r29
    115a:	cf 91       	pop	r28
    115c:	08 95       	ret

0000115e <getCommunicationStatus>:

int getCommunicationStatus() {
    115e:	cf 93       	push	r28
    1160:	df 93       	push	r29
    1162:	00 d0       	rcall	.+0      	; 0x1164 <getCommunicationStatus+0x6>
    1164:	00 d0       	rcall	.+0      	; 0x1166 <getCommunicationStatus+0x8>
    1166:	cd b7       	in	r28, 0x3d	; 61
    1168:	de b7       	in	r29, 0x3e	; 62
	// return GetPing(); // 0 if no connection, big ping means good connection
	int randnum = rand() % 100;
    116a:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <rand>
    116e:	24 e6       	ldi	r18, 0x64	; 100
    1170:	30 e0       	ldi	r19, 0x00	; 0
    1172:	b9 01       	movw	r22, r18
    1174:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <__divmodhi4>
    1178:	9a 83       	std	Y+2, r25	; 0x02
    117a:	89 83       	std	Y+1, r24	; 0x01
	return randnum; // TEST
    117c:	89 81       	ldd	r24, Y+1	; 0x01
    117e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1180:	0f 90       	pop	r0
    1182:	0f 90       	pop	r0
    1184:	0f 90       	pop	r0
    1186:	0f 90       	pop	r0
    1188:	df 91       	pop	r29
    118a:	cf 91       	pop	r28
    118c:	08 95       	ret

0000118e <sendTetherExtensionSignal>:

int sendTetherExtensionSignal(int lengthToExtend) {
    118e:	cf 93       	push	r28
    1190:	df 93       	push	r29
    1192:	00 d0       	rcall	.+0      	; 0x1194 <sendTetherExtensionSignal+0x6>
    1194:	00 d0       	rcall	.+0      	; 0x1196 <sendTetherExtensionSignal+0x8>
    1196:	00 d0       	rcall	.+0      	; 0x1198 <sendTetherExtensionSignal+0xa>
    1198:	cd b7       	in	r28, 0x3d	; 61
    119a:	de b7       	in	r29, 0x3e	; 62
    119c:	9e 83       	std	Y+6, r25	; 0x06
    119e:	8d 83       	std	Y+5, r24	; 0x05
	int status = getCommunicationStatus();
    11a0:	0e 94 af 08 	call	0x115e	; 0x115e <getCommunicationStatus>
    11a4:	9a 83       	std	Y+2, r25	; 0x02
    11a6:	89 83       	std	Y+1, r24	; 0x01
	if (status != 0) // if there is connection
    11a8:	89 81       	ldd	r24, Y+1	; 0x01
    11aa:	9a 81       	ldd	r25, Y+2	; 0x02
    11ac:	89 2b       	or	r24, r25
    11ae:	c1 f0       	breq	.+48     	; 0x11e0 <sendTetherExtensionSignal+0x52>
	{
		int sendResult = sendSignal(lengthToExtend);
    11b0:	8d 81       	ldd	r24, Y+5	; 0x05
    11b2:	9e 81       	ldd	r25, Y+6	; 0x06
    11b4:	0e 94 ff 08 	call	0x11fe	; 0x11fe <sendSignal>
    11b8:	9c 83       	std	Y+4, r25	; 0x04
    11ba:	8b 83       	std	Y+3, r24	; 0x03
		if (sendResult != 0) // if succeeded
    11bc:	8b 81       	ldd	r24, Y+3	; 0x03
    11be:	9c 81       	ldd	r25, Y+4	; 0x04
    11c0:	89 2b       	or	r24, r25
    11c2:	39 f0       	breq	.+14     	; 0x11d2 <sendTetherExtensionSignal+0x44>
		{
			printf("Tether Extension Signal: 1-- succeeded\n"); // TEST
    11c4:	8d e1       	ldi	r24, 0x1D	; 29
    11c6:	94 e0       	ldi	r25, 0x04	; 4
    11c8:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
			return 1;
    11cc:	81 e0       	ldi	r24, 0x01	; 1
    11ce:	90 e0       	ldi	r25, 0x00	; 0
    11d0:	0d c0       	rjmp	.+26     	; 0x11ec <sendTetherExtensionSignal+0x5e>
		}
		else // if not succeed
		{
			printf("Tether Extension Signal: -2-- failed to send signal\n"); // TEST
    11d2:	84 e4       	ldi	r24, 0x44	; 68
    11d4:	94 e0       	ldi	r25, 0x04	; 4
    11d6:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
			return -2;
    11da:	8e ef       	ldi	r24, 0xFE	; 254
    11dc:	9f ef       	ldi	r25, 0xFF	; 255
    11de:	06 c0       	rjmp	.+12     	; 0x11ec <sendTetherExtensionSignal+0x5e>
		}
	}
	else // if there is no connection
	{
		printf("Tether Extension Signal: -1-- no connection\n"); // TEST
    11e0:	88 e7       	ldi	r24, 0x78	; 120
    11e2:	94 e0       	ldi	r25, 0x04	; 4
    11e4:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <puts>
		return -1;
    11e8:	8f ef       	ldi	r24, 0xFF	; 255
    11ea:	9f ef       	ldi	r25, 0xFF	; 255
	}
}
    11ec:	26 96       	adiw	r28, 0x06	; 6
    11ee:	0f b6       	in	r0, 0x3f	; 63
    11f0:	f8 94       	cli
    11f2:	de bf       	out	0x3e, r29	; 62
    11f4:	0f be       	out	0x3f, r0	; 63
    11f6:	cd bf       	out	0x3d, r28	; 61
    11f8:	df 91       	pop	r29
    11fa:	cf 91       	pop	r28
    11fc:	08 95       	ret

000011fe <sendSignal>:

int sendSignal(int length){
    11fe:	cf 93       	push	r28
    1200:	df 93       	push	r29
    1202:	00 d0       	rcall	.+0      	; 0x1204 <sendSignal+0x6>
    1204:	00 d0       	rcall	.+0      	; 0x1206 <sendSignal+0x8>
    1206:	00 d0       	rcall	.+0      	; 0x1208 <sendSignal+0xa>
    1208:	cd b7       	in	r28, 0x3d	; 61
    120a:	de b7       	in	r29, 0x3e	; 62
    120c:	9c 83       	std	Y+4, r25	; 0x04
    120e:	8b 83       	std	Y+3, r24	; 0x03
	// int result = send(length);
	int result = rand() % 3; // TEST get either 0 or 1 or 2
    1210:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <rand>
    1214:	23 e0       	ldi	r18, 0x03	; 3
    1216:	30 e0       	ldi	r19, 0x00	; 0
    1218:	b9 01       	movw	r22, r18
    121a:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <__divmodhi4>
    121e:	9a 83       	std	Y+2, r25	; 0x02
    1220:	89 83       	std	Y+1, r24	; 0x01
	return result;
    1222:	89 81       	ldd	r24, Y+1	; 0x01
    1224:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1226:	26 96       	adiw	r28, 0x06	; 6
    1228:	0f b6       	in	r0, 0x3f	; 63
    122a:	f8 94       	cli
    122c:	de bf       	out	0x3e, r29	; 62
    122e:	0f be       	out	0x3f, r0	; 63
    1230:	cd bf       	out	0x3d, r28	; 61
    1232:	df 91       	pop	r29
    1234:	cf 91       	pop	r28
    1236:	08 95       	ret

00001238 <power_error>:
/*
    THINGS2CONSIDER:
        -Go back to Health and Safety Check
*/

void power_error(void) {
    1238:	cf 93       	push	r28
    123a:	df 93       	push	r29
    123c:	cd b7       	in	r28, 0x3d	; 61
    123e:	de b7       	in	r29, 0x3e	; 62
    return;
    1240:	00 00       	nop
}
    1242:	df 91       	pop	r29
    1244:	cf 91       	pop	r28
    1246:	08 95       	ret

00001248 <attitude_error>:

void attitude_error(void) {
    1248:	cf 93       	push	r28
    124a:	df 93       	push	r29
    124c:	cd b7       	in	r28, 0x3d	; 61
    124e:	de b7       	in	r29, 0x3e	; 62
    return;
    1250:	00 00       	nop
}
    1252:	df 91       	pop	r29
    1254:	cf 91       	pop	r28
    1256:	08 95       	ret

00001258 <run_malfunction_mode>:

void run_malfunction_mode(int error_val){     //priority hierarchy that revisits issues depending on severity (?)
    1258:	cf 93       	push	r28
    125a:	df 93       	push	r29
    125c:	00 d0       	rcall	.+0      	; 0x125e <run_malfunction_mode+0x6>
    125e:	cd b7       	in	r28, 0x3d	; 61
    1260:	de b7       	in	r29, 0x3e	; 62
    1262:	9a 83       	std	Y+2, r25	; 0x02
    1264:	89 83       	std	Y+1, r24	; 0x01
                                            //somehow indicate to SCM that spacecraft is in MFM

    //int error value or name of error
    switch ( error_val ) {
    1266:	89 81       	ldd	r24, Y+1	; 0x01
    1268:	9a 81       	ldd	r25, Y+2	; 0x02
    126a:	09 2e       	mov	r0, r25
    126c:	00 0c       	add	r0, r0
    126e:	aa 0b       	sbc	r26, r26
    1270:	bb 0b       	sbc	r27, r27
    1272:	40 e0       	ldi	r20, 0x00	; 0
    1274:	50 e0       	ldi	r21, 0x00	; 0
    1276:	26 e0       	ldi	r18, 0x06	; 6
    1278:	30 e0       	ldi	r19, 0x00	; 0
    127a:	84 1b       	sub	r24, r20
    127c:	95 0b       	sbc	r25, r21
    127e:	28 17       	cp	r18, r24
    1280:	39 07       	cpc	r19, r25
    1282:	b0 f1       	brcs	.+108    	; 0x12f0 <run_malfunction_mode+0x98>
    1284:	8a 5a       	subi	r24, 0xAA	; 170
    1286:	9f 4f       	sbci	r25, 0xFF	; 255
    1288:	fc 01       	movw	r30, r24
    128a:	0c 94 55 0f 	jmp	0x1eaa	; 0x1eaa <__tablejump2__>
        case 0 :                    //attitude error
            led_clear();
    128e:	0e 94 0a 01 	call	0x214	; 0x214 <led_clear>
            PORTB |= (1<<PB0);
    1292:	85 e2       	ldi	r24, 0x25	; 37
    1294:	90 e0       	ldi	r25, 0x00	; 0
    1296:	25 e2       	ldi	r18, 0x25	; 37
    1298:	30 e0       	ldi	r19, 0x00	; 0
    129a:	f9 01       	movw	r30, r18
    129c:	20 81       	ld	r18, Z
    129e:	21 60       	ori	r18, 0x01	; 1
    12a0:	fc 01       	movw	r30, r24
    12a2:	20 83       	st	Z, r18
            delay_ms(500);
    12a4:	84 ef       	ldi	r24, 0xF4	; 244
    12a6:	91 e0       	ldi	r25, 0x01	; 1
    12a8:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <delay_ms>
            break;
    12ac:	21 c0       	rjmp	.+66     	; 0x12f0 <run_malfunction_mode+0x98>

        case 1 :                    //tether error
            led_clear();
    12ae:	0e 94 0a 01 	call	0x214	; 0x214 <led_clear>
            PORTD |= (1<<PD7);
    12b2:	8b e2       	ldi	r24, 0x2B	; 43
    12b4:	90 e0       	ldi	r25, 0x00	; 0
    12b6:	2b e2       	ldi	r18, 0x2B	; 43
    12b8:	30 e0       	ldi	r19, 0x00	; 0
    12ba:	f9 01       	movw	r30, r18
    12bc:	20 81       	ld	r18, Z
    12be:	20 68       	ori	r18, 0x80	; 128
    12c0:	fc 01       	movw	r30, r24
    12c2:	20 83       	st	Z, r18
            delay_ms(500);
    12c4:	84 ef       	ldi	r24, 0xF4	; 244
    12c6:	91 e0       	ldi	r25, 0x01	; 1
    12c8:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <delay_ms>
            break;
    12cc:	11 c0       	rjmp	.+34     	; 0x12f0 <run_malfunction_mode+0x98>

        case 2 :
            led_clear();            //power error
    12ce:	0e 94 0a 01 	call	0x214	; 0x214 <led_clear>
            PORTD |= (1<<PD6);
    12d2:	8b e2       	ldi	r24, 0x2B	; 43
    12d4:	90 e0       	ldi	r25, 0x00	; 0
    12d6:	2b e2       	ldi	r18, 0x2B	; 43
    12d8:	30 e0       	ldi	r19, 0x00	; 0
    12da:	f9 01       	movw	r30, r18
    12dc:	20 81       	ld	r18, Z
    12de:	20 64       	ori	r18, 0x40	; 64
    12e0:	fc 01       	movw	r30, r24
    12e2:	20 83       	st	Z, r18
            delay_ms(500);
    12e4:	84 ef       	ldi	r24, 0xF4	; 244
    12e6:	91 e0       	ldi	r25, 0x01	; 1
    12e8:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <delay_ms>
            break;
    12ec:	01 c0       	rjmp	.+2      	; 0x12f0 <run_malfunction_mode+0x98>

        case 5 :
            break;

        case 6 :
            break;
    12ee:	00 00       	nop

    }
}
    12f0:	0f 90       	pop	r0
    12f2:	0f 90       	pop	r0
    12f4:	df 91       	pop	r29
    12f6:	cf 91       	pop	r28
    12f8:	08 95       	ret

000012fa <getEmField>:

#include "Em_Sensor.h"
#include <limits.h>
#include <stdio.h>

unsigned short getEmField(){
    12fa:	cf 93       	push	r28
    12fc:	df 93       	push	r29
    12fe:	00 d0       	rcall	.+0      	; 0x1300 <getEmField+0x6>
    1300:	00 d0       	rcall	.+0      	; 0x1302 <getEmField+0x8>
    1302:	cd b7       	in	r28, 0x3d	; 61
    1304:	de b7       	in	r29, 0x3e	; 62
    //Reads Electro Magnetic Field input from port Em_Sensor is on
    int emReading = 56; //will be port Name / DDR location
    1306:	88 e3       	ldi	r24, 0x38	; 56
    1308:	90 e0       	ldi	r25, 0x00	; 0
    130a:	9a 83       	std	Y+2, r25	; 0x02
    130c:	89 83       	std	Y+1, r24	; 0x01
    //We are mapping errors to 0, so if the reading is 0, we must return 1.
    if (emReading == 0) emReading = 1;
    130e:	89 81       	ldd	r24, Y+1	; 0x01
    1310:	9a 81       	ldd	r25, Y+2	; 0x02
    1312:	89 2b       	or	r24, r25
    1314:	21 f4       	brne	.+8      	; 0x131e <getEmField+0x24>
    1316:	81 e0       	ldi	r24, 0x01	; 1
    1318:	90 e0       	ldi	r25, 0x00	; 0
    131a:	9a 83       	std	Y+2, r25	; 0x02
    131c:	89 83       	std	Y+1, r24	; 0x01
    //Else if there is an error, (No Idea how to check), emeading returns 0;
    if (emReading <0) emReading = 0; // Ifsmaller/ not unsigned
    131e:	89 81       	ldd	r24, Y+1	; 0x01
    1320:	9a 81       	ldd	r25, Y+2	; 0x02
    1322:	99 23       	and	r25, r25
    1324:	14 f4       	brge	.+4      	; 0x132a <getEmField+0x30>
    1326:	1a 82       	std	Y+2, r1	; 0x02
    1328:	19 82       	std	Y+1, r1	; 0x01
    if (emReading > USHRT_MAX){ //Makes sure it is not bigger than it is supposed to
        emReading = 0;
    }

    unsigned short emValue = (unsigned short)emReading;
    132a:	89 81       	ldd	r24, Y+1	; 0x01
    132c:	9a 81       	ldd	r25, Y+2	; 0x02
    132e:	9c 83       	std	Y+4, r25	; 0x04
    1330:	8b 83       	std	Y+3, r24	; 0x03
    return emValue;
    1332:	8b 81       	ldd	r24, Y+3	; 0x03
    1334:	9c 81       	ldd	r25, Y+4	; 0x04
    1336:	0f 90       	pop	r0
    1338:	0f 90       	pop	r0
    133a:	0f 90       	pop	r0
    133c:	0f 90       	pop	r0
    133e:	df 91       	pop	r29
    1340:	cf 91       	pop	r28
    1342:	08 95       	ret

00001344 <Get_Ambient_Light>:
//

#include "Light_Sensor.h"
#include "limits.h"

unsigned short Get_Ambient_Light() {
    1344:	cf 93       	push	r28
    1346:	df 93       	push	r29
    1348:	00 d0       	rcall	.+0      	; 0x134a <Get_Ambient_Light+0x6>
    134a:	00 d0       	rcall	.+0      	; 0x134c <Get_Ambient_Light+0x8>
    134c:	cd b7       	in	r28, 0x3d	; 61
    134e:	de b7       	in	r29, 0x3e	; 62
    //Reads ambient light input from port Light_Sensor is on
    int lightReading = 8; //will be port Name / DDR location
    1350:	88 e0       	ldi	r24, 0x08	; 8
    1352:	90 e0       	ldi	r25, 0x00	; 0
    1354:	9a 83       	std	Y+2, r25	; 0x02
    1356:	89 83       	std	Y+1, r24	; 0x01
    //We are mapping errors to 0, so if the reading is 0, we must return 1.
    if (lightReading == 0) lightReading = 1;
    1358:	89 81       	ldd	r24, Y+1	; 0x01
    135a:	9a 81       	ldd	r25, Y+2	; 0x02
    135c:	89 2b       	or	r24, r25
    135e:	21 f4       	brne	.+8      	; 0x1368 <Get_Ambient_Light+0x24>
    1360:	81 e0       	ldi	r24, 0x01	; 1
    1362:	90 e0       	ldi	r25, 0x00	; 0
    1364:	9a 83       	std	Y+2, r25	; 0x02
    1366:	89 83       	std	Y+1, r24	; 0x01
    //Else if there is an error, (No Idea how to check), lightReading returns 0;
    if (lightReading <0) lightReading = 0;
    1368:	89 81       	ldd	r24, Y+1	; 0x01
    136a:	9a 81       	ldd	r25, Y+2	; 0x02
    136c:	99 23       	and	r25, r25
    136e:	14 f4       	brge	.+4      	; 0x1374 <Get_Ambient_Light+0x30>
    1370:	1a 82       	std	Y+2, r1	; 0x02
    1372:	19 82       	std	Y+1, r1	; 0x01
    if (lightReading > USHRT_MAX){ //Makes sure it is not bigger than it is supposed to
        lightReading = 0;
    }

     unsigned short lightValue = (unsigned short)lightReading;
    1374:	89 81       	ldd	r24, Y+1	; 0x01
    1376:	9a 81       	ldd	r25, Y+2	; 0x02
    1378:	9c 83       	std	Y+4, r25	; 0x04
    137a:	8b 83       	std	Y+3, r24	; 0x03
    return lightValue;
    137c:	8b 81       	ldd	r24, Y+3	; 0x03
    137e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1380:	0f 90       	pop	r0
    1382:	0f 90       	pop	r0
    1384:	0f 90       	pop	r0
    1386:	0f 90       	pop	r0
    1388:	df 91       	pop	r29
    138a:	cf 91       	pop	r28
    138c:	08 95       	ret

0000138e <getRotationX>:

#include "Rotation_Sensor.h"
#include <limits.h>
#include <stdio.h>

short getRotationX(){
    138e:	cf 93       	push	r28
    1390:	df 93       	push	r29
    1392:	00 d0       	rcall	.+0      	; 0x1394 <getRotationX+0x6>
    1394:	cd b7       	in	r28, 0x3d	; 61
    1396:	de b7       	in	r29, 0x3e	; 62
   int rotationX = 0; // Sensor Rotation Getting PORT[?]
    1398:	1a 82       	std	Y+2, r1	; 0x02
    139a:	19 82       	std	Y+1, r1	; 0x01
    if (rotationX > SHRT_MAX || rotationX < SHRT_MIN) return 0;
    if (rotationX == 0) rotationX = 1; //Same as light Sensor, 0 is mapped to 1.
    139c:	89 81       	ldd	r24, Y+1	; 0x01
    139e:	9a 81       	ldd	r25, Y+2	; 0x02
    13a0:	89 2b       	or	r24, r25
    13a2:	21 f4       	brne	.+8      	; 0x13ac <getRotationX+0x1e>
    13a4:	81 e0       	ldi	r24, 0x01	; 1
    13a6:	90 e0       	ldi	r25, 0x00	; 0
    13a8:	9a 83       	std	Y+2, r25	; 0x02
    13aa:	89 83       	std	Y+1, r24	; 0x01
    return (short)rotationX;
    13ac:	89 81       	ldd	r24, Y+1	; 0x01
    13ae:	9a 81       	ldd	r25, Y+2	; 0x02
}
    13b0:	0f 90       	pop	r0
    13b2:	0f 90       	pop	r0
    13b4:	df 91       	pop	r29
    13b6:	cf 91       	pop	r28
    13b8:	08 95       	ret

000013ba <getRotationY>:

short getRotationY(){
    13ba:	cf 93       	push	r28
    13bc:	df 93       	push	r29
    13be:	00 d0       	rcall	.+0      	; 0x13c0 <getRotationY+0x6>
    13c0:	cd b7       	in	r28, 0x3d	; 61
    13c2:	de b7       	in	r29, 0x3e	; 62
   int rotationY = -9999; //Gets rotation
    13c4:	81 ef       	ldi	r24, 0xF1	; 241
    13c6:	98 ed       	ldi	r25, 0xD8	; 216
    13c8:	9a 83       	std	Y+2, r25	; 0x02
    13ca:	89 83       	std	Y+1, r24	; 0x01
    if (rotationY > SHRT_MAX || rotationY < SHRT_MIN) return 0;
    if (rotationY == 0) rotationY = 1; //Same as light Sensor, 0 is mapped to 1.
    13cc:	89 81       	ldd	r24, Y+1	; 0x01
    13ce:	9a 81       	ldd	r25, Y+2	; 0x02
    13d0:	89 2b       	or	r24, r25
    13d2:	21 f4       	brne	.+8      	; 0x13dc <getRotationY+0x22>
    13d4:	81 e0       	ldi	r24, 0x01	; 1
    13d6:	90 e0       	ldi	r25, 0x00	; 0
    13d8:	9a 83       	std	Y+2, r25	; 0x02
    13da:	89 83       	std	Y+1, r24	; 0x01
    return (short)rotationY;
    13dc:	89 81       	ldd	r24, Y+1	; 0x01
    13de:	9a 81       	ldd	r25, Y+2	; 0x02
}
    13e0:	0f 90       	pop	r0
    13e2:	0f 90       	pop	r0
    13e4:	df 91       	pop	r29
    13e6:	cf 91       	pop	r28
    13e8:	08 95       	ret

000013ea <getRotationZ>:
short getRotationZ() {
    13ea:	cf 93       	push	r28
    13ec:	df 93       	push	r29
    13ee:	00 d0       	rcall	.+0      	; 0x13f0 <getRotationZ+0x6>
    13f0:	cd b7       	in	r28, 0x3d	; 61
    13f2:	de b7       	in	r29, 0x3e	; 62
    int  rotationZ = SHRT_MAX;
    13f4:	8f ef       	ldi	r24, 0xFF	; 255
    13f6:	9f e7       	ldi	r25, 0x7F	; 127
    13f8:	9a 83       	std	Y+2, r25	; 0x02
    13fa:	89 83       	std	Y+1, r24	; 0x01
    if (rotationZ > SHRT_MAX || rotationZ < SHRT_MIN) return 0;
    if (rotationZ == 0) rotationZ = 1; //Same as light Sensor, 0 is mapped to 1.
    13fc:	89 81       	ldd	r24, Y+1	; 0x01
    13fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1400:	89 2b       	or	r24, r25
    1402:	21 f4       	brne	.+8      	; 0x140c <getRotationZ+0x22>
    1404:	81 e0       	ldi	r24, 0x01	; 1
    1406:	90 e0       	ldi	r25, 0x00	; 0
    1408:	9a 83       	std	Y+2, r25	; 0x02
    140a:	89 83       	std	Y+1, r24	; 0x01
    return (short)rotationZ;
    140c:	89 81       	ldd	r24, Y+1	; 0x01
    140e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1410:	0f 90       	pop	r0
    1412:	0f 90       	pop	r0
    1414:	df 91       	pop	r29
    1416:	cf 91       	pop	r28
    1418:	08 95       	ret

0000141a <getWireTension>:
//

#include "Tether_Communication_Sensor'.h"
#include <limits.h>

unsigned short getWireTension(void){
    141a:	cf 93       	push	r28
    141c:	df 93       	push	r29
    141e:	00 d0       	rcall	.+0      	; 0x1420 <getWireTension+0x6>
    1420:	00 d0       	rcall	.+0      	; 0x1422 <getWireTension+0x8>
    1422:	cd b7       	in	r28, 0x3d	; 61
    1424:	de b7       	in	r29, 0x3e	; 62
        //Reads Wire tension some how from Tether sensor port
        int wireTension = -1; //will be port Name / DDR location
    1426:	8f ef       	ldi	r24, 0xFF	; 255
    1428:	9f ef       	ldi	r25, 0xFF	; 255
    142a:	9a 83       	std	Y+2, r25	; 0x02
    142c:	89 83       	std	Y+1, r24	; 0x01
        //We are mapping errors to 0, so if the reading is 0, we must return 1.
        if (wireTension == 0) wireTension = 1;
    142e:	89 81       	ldd	r24, Y+1	; 0x01
    1430:	9a 81       	ldd	r25, Y+2	; 0x02
    1432:	89 2b       	or	r24, r25
    1434:	21 f4       	brne	.+8      	; 0x143e <getWireTension+0x24>
    1436:	81 e0       	ldi	r24, 0x01	; 1
    1438:	90 e0       	ldi	r25, 0x00	; 0
    143a:	9a 83       	std	Y+2, r25	; 0x02
    143c:	89 83       	std	Y+1, r24	; 0x01
        if (wireTension <0) wireTension = 0;
    143e:	89 81       	ldd	r24, Y+1	; 0x01
    1440:	9a 81       	ldd	r25, Y+2	; 0x02
    1442:	99 23       	and	r25, r25
    1444:	14 f4       	brge	.+4      	; 0x144a <getWireTension+0x30>
    1446:	1a 82       	std	Y+2, r1	; 0x02
    1448:	19 82       	std	Y+1, r1	; 0x01
        if (wireTension > USHRT_MAX){ //Makes sure it is not bigger than it is supposed to
            wireTension = 0;
        }

        unsigned short wireTensionValue  = (unsigned short)wireTension;
    144a:	89 81       	ldd	r24, Y+1	; 0x01
    144c:	9a 81       	ldd	r25, Y+2	; 0x02
    144e:	9c 83       	std	Y+4, r25	; 0x04
    1450:	8b 83       	std	Y+3, r24	; 0x03
    return wireTensionValue;
    1452:	8b 81       	ldd	r24, Y+3	; 0x03
    1454:	9c 81       	ldd	r25, Y+4	; 0x04
    1456:	0f 90       	pop	r0
    1458:	0f 90       	pop	r0
    145a:	0f 90       	pop	r0
    145c:	0f 90       	pop	r0
    145e:	df 91       	pop	r29
    1460:	cf 91       	pop	r28
    1462:	08 95       	ret

00001464 <checkTime>:

#include "Time_Watch.h"
#include <time.h>
#include <stdio.h>

void checkTime(void){
    1464:	cf 93       	push	r28
    1466:	df 93       	push	r29
    1468:	cd b7       	in	r28, 0x3d	; 61
    146a:	de b7       	in	r29, 0x3e	; 62


    146c:	df 91       	pop	r29
    146e:	cf 91       	pop	r28
    1470:	08 95       	ret

00001472 <systmr_Init>:
#include "systmr.h"    // timekeeping support
//-----------------------------------------------------------------------------
// DATA:
//SysTicks_t elapsedTicks = 0;
//-----------------------------------------------------------------------------
Bool systmr_Init(SysTimer_t *sysTimer, SysTmr_GetTicksFunc_hook_t getticks_func){
    1472:	cf 93       	push	r28
    1474:	df 93       	push	r29
    1476:	00 d0       	rcall	.+0      	; 0x1478 <systmr_Init+0x6>
    1478:	00 d0       	rcall	.+0      	; 0x147a <systmr_Init+0x8>
    147a:	cd b7       	in	r28, 0x3d	; 61
    147c:	de b7       	in	r29, 0x3e	; 62
    147e:	9a 83       	std	Y+2, r25	; 0x02
    1480:	89 83       	std	Y+1, r24	; 0x01
    1482:	7c 83       	std	Y+4, r23	; 0x04
    1484:	6b 83       	std	Y+3, r22	; 0x03

    if(getticks_func == NULL){
    1486:	8b 81       	ldd	r24, Y+3	; 0x03
    1488:	9c 81       	ldd	r25, Y+4	; 0x04
    148a:	89 2b       	or	r24, r25
    148c:	11 f4       	brne	.+4      	; 0x1492 <systmr_Init+0x20>
        return FALSE;
    148e:	80 e0       	ldi	r24, 0x00	; 0
    1490:	08 c0       	rjmp	.+16     	; 0x14a2 <systmr_Init+0x30>
    }

    else {
        sysTimer->getTicks = getticks_func;
    1492:	89 81       	ldd	r24, Y+1	; 0x01
    1494:	9a 81       	ldd	r25, Y+2	; 0x02
    1496:	2b 81       	ldd	r18, Y+3	; 0x03
    1498:	3c 81       	ldd	r19, Y+4	; 0x04
    149a:	fc 01       	movw	r30, r24
    149c:	30 87       	std	Z+8, r19	; 0x08
    149e:	27 83       	std	Z+7, r18	; 0x07
        return TRUE;
    14a0:	81 e0       	ldi	r24, 0x01	; 1
    }

}
    14a2:	0f 90       	pop	r0
    14a4:	0f 90       	pop	r0
    14a6:	0f 90       	pop	r0
    14a8:	0f 90       	pop	r0
    14aa:	df 91       	pop	r29
    14ac:	cf 91       	pop	r28
    14ae:	08 95       	ret

000014b0 <systmr_Load>:
//-----------------------------------------------------------------------------
// load timer with current system tick value
void systmr_Load(SysTimer_t *sysTimer) {
    14b0:	cf 93       	push	r28
    14b2:	df 93       	push	r29
    14b4:	00 d0       	rcall	.+0      	; 0x14b6 <systmr_Load+0x6>
    14b6:	cd b7       	in	r28, 0x3d	; 61
    14b8:	de b7       	in	r29, 0x3e	; 62
    14ba:	9a 83       	std	Y+2, r25	; 0x02
    14bc:	89 83       	std	Y+1, r24	; 0x01

  if(sysTimer->getTicks){
    14be:	89 81       	ldd	r24, Y+1	; 0x01
    14c0:	9a 81       	ldd	r25, Y+2	; 0x02
    14c2:	fc 01       	movw	r30, r24
    14c4:	87 81       	ldd	r24, Z+7	; 0x07
    14c6:	90 85       	ldd	r25, Z+8	; 0x08
    14c8:	89 2b       	or	r24, r25
    14ca:	69 f0       	breq	.+26     	; 0x14e6 <systmr_Load+0x36>
      sysTimer->ticks = sysTimer->getTicks();// + sysTimer->offset;
    14cc:	89 81       	ldd	r24, Y+1	; 0x01
    14ce:	9a 81       	ldd	r25, Y+2	; 0x02
    14d0:	fc 01       	movw	r30, r24
    14d2:	87 81       	ldd	r24, Z+7	; 0x07
    14d4:	90 85       	ldd	r25, Z+8	; 0x08
    14d6:	fc 01       	movw	r30, r24
    14d8:	09 95       	icall
    14da:	9c 01       	movw	r18, r24
    14dc:	89 81       	ldd	r24, Y+1	; 0x01
    14de:	9a 81       	ldd	r25, Y+2	; 0x02
    14e0:	fc 01       	movw	r30, r24
    14e2:	31 83       	std	Z+1, r19	; 0x01
    14e4:	20 83       	st	Z, r18
  }
  sysTimer->latched = FALSE;
    14e6:	89 81       	ldd	r24, Y+1	; 0x01
    14e8:	9a 81       	ldd	r25, Y+2	; 0x02
    14ea:	fc 01       	movw	r30, r24
    14ec:	12 82       	std	Z+2, r1	; 0x02
}
    14ee:	0f 90       	pop	r0
    14f0:	0f 90       	pop	r0
    14f2:	df 91       	pop	r29
    14f4:	cf 91       	pop	r28
    14f6:	08 95       	ret

000014f8 <systmr_Elapsed>:
//-----------------------------------------------------------------------------
Bool systmr_Elapsed( SysTimer_t  *sysTimer, SysTicks_t  durationTicks,
                     Bool reloadTimer) {
    14f8:	cf 93       	push	r28
    14fa:	df 93       	push	r29
    14fc:	cd b7       	in	r28, 0x3d	; 61
    14fe:	de b7       	in	r29, 0x3e	; 62
    1500:	29 97       	sbiw	r28, 0x09	; 9
    1502:	0f b6       	in	r0, 0x3f	; 63
    1504:	f8 94       	cli
    1506:	de bf       	out	0x3e, r29	; 62
    1508:	0f be       	out	0x3f, r0	; 63
    150a:	cd bf       	out	0x3d, r28	; 61
    150c:	9e 83       	std	Y+6, r25	; 0x06
    150e:	8d 83       	std	Y+5, r24	; 0x05
    1510:	78 87       	std	Y+8, r23	; 0x08
    1512:	6f 83       	std	Y+7, r22	; 0x07
    1514:	49 87       	std	Y+9, r20	; 0x09

  SysTicks_t elapsedTicks = 0;
    1516:	1a 82       	std	Y+2, r1	; 0x02
    1518:	19 82       	std	Y+1, r1	; 0x01
  SysTicks_t systicks;

   // read the system tick value.
   // (do so only if the getTicks() function address is not NULL)
   if(sysTimer->getTicks){
    151a:	8d 81       	ldd	r24, Y+5	; 0x05
    151c:	9e 81       	ldd	r25, Y+6	; 0x06
    151e:	fc 01       	movw	r30, r24
    1520:	87 81       	ldd	r24, Z+7	; 0x07
    1522:	90 85       	ldd	r25, Z+8	; 0x08
    1524:	89 2b       	or	r24, r25
    1526:	81 f0       	breq	.+32     	; 0x1548 <systmr_Elapsed+0x50>

        systicks = sysTimer->getTicks();
    1528:	8d 81       	ldd	r24, Y+5	; 0x05
    152a:	9e 81       	ldd	r25, Y+6	; 0x06
    152c:	fc 01       	movw	r30, r24
    152e:	87 81       	ldd	r24, Z+7	; 0x07
    1530:	90 85       	ldd	r25, Z+8	; 0x08
    1532:	fc 01       	movw	r30, r24
    1534:	09 95       	icall
    1536:	9c 83       	std	Y+4, r25	; 0x04
    1538:	8b 83       	std	Y+3, r24	; 0x03
        return FALSE;
   }


  // Check if timer is latched.  If so, return the last elapsed state.
  if( sysTimer->latched == TRUE ) {
    153a:	8d 81       	ldd	r24, Y+5	; 0x05
    153c:	9e 81       	ldd	r25, Y+6	; 0x06
    153e:	fc 01       	movw	r30, r24
    1540:	82 81       	ldd	r24, Z+2	; 0x02
    1542:	81 30       	cpi	r24, 0x01	; 1
    1544:	41 f4       	brne	.+16     	; 0x1556 <systmr_Elapsed+0x5e>
    1546:	02 c0       	rjmp	.+4      	; 0x154c <systmr_Elapsed+0x54>
        systicks = sysTimer->getTicks();

   }
   // else, return FALSE since we don't have a valid getTicks function.
   else {
        return FALSE;
    1548:	80 e0       	ldi	r24, 0x00	; 0
    154a:	2f c0       	rjmp	.+94     	; 0x15aa <systmr_Elapsed+0xb2>

    }
    */

    // return the last elapsed state, whether TRUE or FALSE.
    return sysTimer->elapsed;
    154c:	8d 81       	ldd	r24, Y+5	; 0x05
    154e:	9e 81       	ldd	r25, Y+6	; 0x06
    1550:	fc 01       	movw	r30, r24
    1552:	84 81       	ldd	r24, Z+4	; 0x04
    1554:	2a c0       	rjmp	.+84     	; 0x15aa <systmr_Elapsed+0xb2>
  }

  // Compute the elapsed ticks
  elapsedTicks = (systicks - sysTimer->ticks);
    1556:	8d 81       	ldd	r24, Y+5	; 0x05
    1558:	9e 81       	ldd	r25, Y+6	; 0x06
    155a:	fc 01       	movw	r30, r24
    155c:	80 81       	ld	r24, Z
    155e:	91 81       	ldd	r25, Z+1	; 0x01
    1560:	2b 81       	ldd	r18, Y+3	; 0x03
    1562:	3c 81       	ldd	r19, Y+4	; 0x04
    1564:	a9 01       	movw	r20, r18
    1566:	48 1b       	sub	r20, r24
    1568:	59 0b       	sbc	r21, r25
    156a:	ca 01       	movw	r24, r20
    156c:	9a 83       	std	Y+2, r25	; 0x02
    156e:	89 83       	std	Y+1, r24	; 0x01

  // Now check if durationTicks have elapsed since the timer was last loaded.
  if ( elapsedTicks >= durationTicks) {
    1570:	29 81       	ldd	r18, Y+1	; 0x01
    1572:	3a 81       	ldd	r19, Y+2	; 0x02
    1574:	8f 81       	ldd	r24, Y+7	; 0x07
    1576:	98 85       	ldd	r25, Y+8	; 0x08
    1578:	28 17       	cp	r18, r24
    157a:	39 07       	cpc	r19, r25
    157c:	88 f0       	brcs	.+34     	; 0x15a0 <systmr_Elapsed+0xa8>

    // updated the elapsed state. (used for when the timer is latched)
    sysTimer->elapsed = TRUE;
    157e:	8d 81       	ldd	r24, Y+5	; 0x05
    1580:	9e 81       	ldd	r25, Y+6	; 0x06
    1582:	21 e0       	ldi	r18, 0x01	; 1
    1584:	fc 01       	movw	r30, r24
    1586:	24 83       	std	Z+4, r18	; 0x04

    // set the timer ticks to equal the current system ticks:
    if (reloadTimer) {
    1588:	89 85       	ldd	r24, Y+9	; 0x09
    158a:	88 23       	and	r24, r24
    158c:	39 f0       	breq	.+14     	; 0x159c <systmr_Elapsed+0xa4>
      sysTimer->ticks = systicks ;
    158e:	8d 81       	ldd	r24, Y+5	; 0x05
    1590:	9e 81       	ldd	r25, Y+6	; 0x06
    1592:	2b 81       	ldd	r18, Y+3	; 0x03
    1594:	3c 81       	ldd	r19, Y+4	; 0x04
    1596:	fc 01       	movw	r30, r24
    1598:	31 83       	std	Z+1, r19	; 0x01
    159a:	20 83       	st	Z, r18

    */
    //else {
    //  sysTimer->latched = TRUE;
    //}
    return TRUE;
    159c:	81 e0       	ldi	r24, 0x01	; 1
    159e:	05 c0       	rjmp	.+10     	; 0x15aa <systmr_Elapsed+0xb2>
  }
  else {
    sysTimer->elapsed = FALSE;
    15a0:	8d 81       	ldd	r24, Y+5	; 0x05
    15a2:	9e 81       	ldd	r25, Y+6	; 0x06
    15a4:	fc 01       	movw	r30, r24
    15a6:	14 82       	std	Z+4, r1	; 0x04
    return FALSE;
    15a8:	80 e0       	ldi	r24, 0x00	; 0
  }
}
    15aa:	29 96       	adiw	r28, 0x09	; 9
    15ac:	0f b6       	in	r0, 0x3f	; 63
    15ae:	f8 94       	cli
    15b0:	de bf       	out	0x3e, r29	; 62
    15b2:	0f be       	out	0x3f, r0	; 63
    15b4:	cd bf       	out	0x3d, r28	; 61
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	08 95       	ret

000015bc <systmr_Latch>:
//-----------------------------------------------------------------------------
// latch the result.
void systmr_Latch(SysTimer_t *sysTimer, Bool latch){
    15bc:	cf 93       	push	r28
    15be:	df 93       	push	r29
    15c0:	00 d0       	rcall	.+0      	; 0x15c2 <systmr_Latch+0x6>
    15c2:	1f 92       	push	r1
    15c4:	cd b7       	in	r28, 0x3d	; 61
    15c6:	de b7       	in	r29, 0x3e	; 62
    15c8:	9a 83       	std	Y+2, r25	; 0x02
    15ca:	89 83       	std	Y+1, r24	; 0x01
    15cc:	6b 83       	std	Y+3, r22	; 0x03
  sysTimer->latched = latch;
    15ce:	89 81       	ldd	r24, Y+1	; 0x01
    15d0:	9a 81       	ldd	r25, Y+2	; 0x02
    15d2:	2b 81       	ldd	r18, Y+3	; 0x03
    15d4:	fc 01       	movw	r30, r24
    15d6:	22 83       	std	Z+2, r18	; 0x02
}
    15d8:	0f 90       	pop	r0
    15da:	0f 90       	pop	r0
    15dc:	0f 90       	pop	r0
    15de:	df 91       	pop	r29
    15e0:	cf 91       	pop	r28
    15e2:	08 95       	ret

000015e4 <systmr_IsElapsed>:
//-----------------------------------------------------------------------------
Bool systmr_IsElapsed(  SysTimer_t *sysTimer) {
    15e4:	cf 93       	push	r28
    15e6:	df 93       	push	r29
    15e8:	00 d0       	rcall	.+0      	; 0x15ea <systmr_IsElapsed+0x6>
    15ea:	cd b7       	in	r28, 0x3d	; 61
    15ec:	de b7       	in	r29, 0x3e	; 62
    15ee:	9a 83       	std	Y+2, r25	; 0x02
    15f0:	89 83       	std	Y+1, r24	; 0x01
    return sysTimer->elapsed;
    15f2:	89 81       	ldd	r24, Y+1	; 0x01
    15f4:	9a 81       	ldd	r25, Y+2	; 0x02
    15f6:	fc 01       	movw	r30, r24
    15f8:	84 81       	ldd	r24, Z+4	; 0x04
}
    15fa:	0f 90       	pop	r0
    15fc:	0f 90       	pop	r0
    15fe:	df 91       	pop	r29
    1600:	cf 91       	pop	r28
    1602:	08 95       	ret

00001604 <systmr_AdjustForward>:
//-----------------------------------------------------------------------------
// adjust timer forward(move forward in time)
void systmr_AdjustForward(SysTimer_t *sysTimer, SysTicks_t advance_ticks) {
    1604:	cf 93       	push	r28
    1606:	df 93       	push	r29
    1608:	00 d0       	rcall	.+0      	; 0x160a <systmr_AdjustForward+0x6>
    160a:	00 d0       	rcall	.+0      	; 0x160c <systmr_AdjustForward+0x8>
    160c:	cd b7       	in	r28, 0x3d	; 61
    160e:	de b7       	in	r29, 0x3e	; 62
    1610:	9a 83       	std	Y+2, r25	; 0x02
    1612:	89 83       	std	Y+1, r24	; 0x01
    1614:	7c 83       	std	Y+4, r23	; 0x04
    1616:	6b 83       	std	Y+3, r22	; 0x03
      sysTimer->ticks -= advance_ticks;
    1618:	89 81       	ldd	r24, Y+1	; 0x01
    161a:	9a 81       	ldd	r25, Y+2	; 0x02
    161c:	fc 01       	movw	r30, r24
    161e:	20 81       	ld	r18, Z
    1620:	31 81       	ldd	r19, Z+1	; 0x01
    1622:	8b 81       	ldd	r24, Y+3	; 0x03
    1624:	9c 81       	ldd	r25, Y+4	; 0x04
    1626:	28 1b       	sub	r18, r24
    1628:	39 0b       	sbc	r19, r25
    162a:	89 81       	ldd	r24, Y+1	; 0x01
    162c:	9a 81       	ldd	r25, Y+2	; 0x02
    162e:	fc 01       	movw	r30, r24
    1630:	31 83       	std	Z+1, r19	; 0x01
    1632:	20 83       	st	Z, r18
}
    1634:	0f 90       	pop	r0
    1636:	0f 90       	pop	r0
    1638:	0f 90       	pop	r0
    163a:	0f 90       	pop	r0
    163c:	df 91       	pop	r29
    163e:	cf 91       	pop	r28
    1640:	08 95       	ret

00001642 <systmr_AdjustBack>:
//-----------------------------------------------------------------------------
// adjust timer back (move back in time, i.e. lengthen timer)
void systmr_AdjustBack(SysTimer_t *sysTimer, SysTicks_t delay_ticks) {
    1642:	cf 93       	push	r28
    1644:	df 93       	push	r29
    1646:	00 d0       	rcall	.+0      	; 0x1648 <systmr_AdjustBack+0x6>
    1648:	00 d0       	rcall	.+0      	; 0x164a <systmr_AdjustBack+0x8>
    164a:	cd b7       	in	r28, 0x3d	; 61
    164c:	de b7       	in	r29, 0x3e	; 62
    164e:	9a 83       	std	Y+2, r25	; 0x02
    1650:	89 83       	std	Y+1, r24	; 0x01
    1652:	7c 83       	std	Y+4, r23	; 0x04
    1654:	6b 83       	std	Y+3, r22	; 0x03
      sysTimer->ticks += delay_ticks;
    1656:	89 81       	ldd	r24, Y+1	; 0x01
    1658:	9a 81       	ldd	r25, Y+2	; 0x02
    165a:	fc 01       	movw	r30, r24
    165c:	20 81       	ld	r18, Z
    165e:	31 81       	ldd	r19, Z+1	; 0x01
    1660:	8b 81       	ldd	r24, Y+3	; 0x03
    1662:	9c 81       	ldd	r25, Y+4	; 0x04
    1664:	28 0f       	add	r18, r24
    1666:	39 1f       	adc	r19, r25
    1668:	89 81       	ldd	r24, Y+1	; 0x01
    166a:	9a 81       	ldd	r25, Y+2	; 0x02
    166c:	fc 01       	movw	r30, r24
    166e:	31 83       	std	Z+1, r19	; 0x01
    1670:	20 83       	st	Z, r18
}
    1672:	0f 90       	pop	r0
    1674:	0f 90       	pop	r0
    1676:	0f 90       	pop	r0
    1678:	0f 90       	pop	r0
    167a:	df 91       	pop	r29
    167c:	cf 91       	pop	r28
    167e:	08 95       	ret

00001680 <systmr_Delta>:
//-----------------------------------------------------------------------------
// compute delta between two timers (systimer1 >= sysTimer2)
SysTicks_t systmr_Delta(SysTimer_t *sysTimer1, SysTimer_t *sysTimer2) {
    1680:	cf 93       	push	r28
    1682:	df 93       	push	r29
    1684:	00 d0       	rcall	.+0      	; 0x1686 <systmr_Delta+0x6>
    1686:	00 d0       	rcall	.+0      	; 0x1688 <systmr_Delta+0x8>
    1688:	cd b7       	in	r28, 0x3d	; 61
    168a:	de b7       	in	r29, 0x3e	; 62
    168c:	9a 83       	std	Y+2, r25	; 0x02
    168e:	89 83       	std	Y+1, r24	; 0x01
    1690:	7c 83       	std	Y+4, r23	; 0x04
    1692:	6b 83       	std	Y+3, r22	; 0x03
  return sysTimer1->ticks - sysTimer2->ticks;
    1694:	89 81       	ldd	r24, Y+1	; 0x01
    1696:	9a 81       	ldd	r25, Y+2	; 0x02
    1698:	fc 01       	movw	r30, r24
    169a:	20 81       	ld	r18, Z
    169c:	31 81       	ldd	r19, Z+1	; 0x01
    169e:	8b 81       	ldd	r24, Y+3	; 0x03
    16a0:	9c 81       	ldd	r25, Y+4	; 0x04
    16a2:	fc 01       	movw	r30, r24
    16a4:	80 81       	ld	r24, Z
    16a6:	91 81       	ldd	r25, Z+1	; 0x01
    16a8:	a9 01       	movw	r20, r18
    16aa:	48 1b       	sub	r20, r24
    16ac:	59 0b       	sbc	r21, r25
    16ae:	ca 01       	movw	r24, r20
}
    16b0:	0f 90       	pop	r0
    16b2:	0f 90       	pop	r0
    16b4:	0f 90       	pop	r0
    16b6:	0f 90       	pop	r0
    16b8:	df 91       	pop	r29
    16ba:	cf 91       	pop	r28
    16bc:	08 95       	ret

000016be <systmr_Time>:
//-----------------------------------------------------------------------------
// returns elapsed time (in ticks) since timer was loaded
SysTicks_t systmr_Time(SysTimer_t *sysTimer) {
    16be:	cf 93       	push	r28
    16c0:	df 93       	push	r29
    16c2:	00 d0       	rcall	.+0      	; 0x16c4 <systmr_Time+0x6>
    16c4:	cd b7       	in	r28, 0x3d	; 61
    16c6:	de b7       	in	r29, 0x3e	; 62
    16c8:	9a 83       	std	Y+2, r25	; 0x02
    16ca:	89 83       	std	Y+1, r24	; 0x01
    return  sysTimer->getTicks() - sysTimer->ticks;
    16cc:	89 81       	ldd	r24, Y+1	; 0x01
    16ce:	9a 81       	ldd	r25, Y+2	; 0x02
    16d0:	fc 01       	movw	r30, r24
    16d2:	87 81       	ldd	r24, Z+7	; 0x07
    16d4:	90 85       	ldd	r25, Z+8	; 0x08
    16d6:	fc 01       	movw	r30, r24
    16d8:	09 95       	icall
    16da:	9c 01       	movw	r18, r24
    16dc:	89 81       	ldd	r24, Y+1	; 0x01
    16de:	9a 81       	ldd	r25, Y+2	; 0x02
    16e0:	fc 01       	movw	r30, r24
    16e2:	80 81       	ld	r24, Z
    16e4:	91 81       	ldd	r25, Z+1	; 0x01
    16e6:	a9 01       	movw	r20, r18
    16e8:	48 1b       	sub	r20, r24
    16ea:	59 0b       	sbc	r21, r25
    16ec:	ca 01       	movw	r24, r20
}
    16ee:	0f 90       	pop	r0
    16f0:	0f 90       	pop	r0
    16f2:	df 91       	pop	r29
    16f4:	cf 91       	pop	r28
    16f6:	08 95       	ret

000016f8 <delay_ms>:
//-------------------------------------------------------------------------------------------------------------------------------
/* The next few functions are delay functions. Although they are not necessary, it is helpful when debugging.
    Please note, that using a delay is wasting clock cycles, and therefore is not practical in the final system*/
void delay_ms(int delay_in_ms){
    16f8:	cf 93       	push	r28
    16fa:	df 93       	push	r29
    16fc:	cd b7       	in	r28, 0x3d	; 61
    16fe:	de b7       	in	r29, 0x3e	; 62
    1700:	2b 97       	sbiw	r28, 0x0b	; 11
    1702:	0f b6       	in	r0, 0x3f	; 63
    1704:	f8 94       	cli
    1706:	de bf       	out	0x3e, r29	; 62
    1708:	0f be       	out	0x3f, r0	; 63
    170a:	cd bf       	out	0x3d, r28	; 61
    170c:	9b 87       	std	Y+11, r25	; 0x0b
    170e:	8a 87       	std	Y+10, r24	; 0x0a
    SysTimer_t ms_timer; //Declares an instance of a new timer
    systmr_Init(&ms_timer, tmr3_Get2msTicks_u16); //We are using 16 bits, so that the timer may count to a higher value
    1710:	6d e1       	ldi	r22, 0x1D	; 29
    1712:	7e e0       	ldi	r23, 0x0E	; 14
    1714:	ce 01       	movw	r24, r28
    1716:	01 96       	adiw	r24, 0x01	; 1
    1718:	0e 94 39 0a 	call	0x1472	; 0x1472 <systmr_Init>
    systmr_Load(&ms_timer); //Load the timer before starting. This is used as a referenece point.
    171c:	ce 01       	movw	r24, r28
    171e:	01 96       	adiw	r24, 0x01	; 1
    1720:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <systmr_Load>

    while(!systmr_Elapsed(&ms_timer, delay_in_ms/2, SYSTMR_DO_NOT_RELOAD));
    1724:	00 00       	nop
    1726:	8a 85       	ldd	r24, Y+10	; 0x0a
    1728:	9b 85       	ldd	r25, Y+11	; 0x0b
    172a:	99 23       	and	r25, r25
    172c:	0c f4       	brge	.+2      	; 0x1730 <delay_ms+0x38>
    172e:	01 96       	adiw	r24, 0x01	; 1
    1730:	95 95       	asr	r25
    1732:	87 95       	ror	r24
    1734:	40 e0       	ldi	r20, 0x00	; 0
    1736:	bc 01       	movw	r22, r24
    1738:	ce 01       	movw	r24, r28
    173a:	01 96       	adiw	r24, 0x01	; 1
    173c:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <systmr_Elapsed>
    1740:	88 23       	and	r24, r24
    1742:	89 f3       	breq	.-30     	; 0x1726 <delay_ms+0x2e>
}
    1744:	2b 96       	adiw	r28, 0x0b	; 11
    1746:	0f b6       	in	r0, 0x3f	; 63
    1748:	f8 94       	cli
    174a:	de bf       	out	0x3e, r29	; 62
    174c:	0f be       	out	0x3f, r0	; 63
    174e:	cd bf       	out	0x3d, r28	; 61
    1750:	df 91       	pop	r29
    1752:	cf 91       	pop	r28
    1754:	08 95       	ret

00001756 <delay_sec>:
//-----------------------------------------------------------------------------
void delay_sec(int delay_in_sec){
    1756:	cf 93       	push	r28
    1758:	df 93       	push	r29
    175a:	cd b7       	in	r28, 0x3d	; 61
    175c:	de b7       	in	r29, 0x3e	; 62
    175e:	2c 97       	sbiw	r28, 0x0c	; 12
    1760:	0f b6       	in	r0, 0x3f	; 63
    1762:	f8 94       	cli
    1764:	de bf       	out	0x3e, r29	; 62
    1766:	0f be       	out	0x3f, r0	; 63
    1768:	cd bf       	out	0x3d, r28	; 61
    176a:	9c 87       	std	Y+12, r25	; 0x0c
    176c:	8b 87       	std	Y+11, r24	; 0x0b
    SysTimer_t sec_timer; //Declares an instance of a new timer
    systmr_Init(&sec_timer, tmr3_Get2msTicks_u16); //We are using 16 bits, so that the timer may count to a higher value
    176e:	ce 01       	movw	r24, r28
    1770:	02 96       	adiw	r24, 0x02	; 2
    1772:	6d e1       	ldi	r22, 0x1D	; 29
    1774:	7e e0       	ldi	r23, 0x0E	; 14
    1776:	0e 94 39 0a 	call	0x1472	; 0x1472 <systmr_Init>
    systmr_Load(&sec_timer); //Load the timer before starting. This is used as a referenece point.
    177a:	ce 01       	movw	r24, r28
    177c:	02 96       	adiw	r24, 0x02	; 2
    177e:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <systmr_Load>
    char i;

    for(i = 0; i < delay_in_sec; i++){
    1782:	19 82       	std	Y+1, r1	; 0x01
    1784:	07 c0       	rjmp	.+14     	; 0x1794 <delay_sec+0x3e>
        delay_ms(1000); //wait until one second has passed
    1786:	88 ee       	ldi	r24, 0xE8	; 232
    1788:	93 e0       	ldi	r25, 0x03	; 3
    178a:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <delay_ms>
    SysTimer_t sec_timer; //Declares an instance of a new timer
    systmr_Init(&sec_timer, tmr3_Get2msTicks_u16); //We are using 16 bits, so that the timer may count to a higher value
    systmr_Load(&sec_timer); //Load the timer before starting. This is used as a referenece point.
    char i;

    for(i = 0; i < delay_in_sec; i++){
    178e:	89 81       	ldd	r24, Y+1	; 0x01
    1790:	8f 5f       	subi	r24, 0xFF	; 255
    1792:	89 83       	std	Y+1, r24	; 0x01
    1794:	89 81       	ldd	r24, Y+1	; 0x01
    1796:	28 2f       	mov	r18, r24
    1798:	88 0f       	add	r24, r24
    179a:	33 0b       	sbc	r19, r19
    179c:	8b 85       	ldd	r24, Y+11	; 0x0b
    179e:	9c 85       	ldd	r25, Y+12	; 0x0c
    17a0:	28 17       	cp	r18, r24
    17a2:	39 07       	cpc	r19, r25
    17a4:	84 f3       	brlt	.-32     	; 0x1786 <delay_sec+0x30>
        delay_ms(1000); //wait until one second has passed
    }

}
    17a6:	2c 96       	adiw	r28, 0x0c	; 12
    17a8:	0f b6       	in	r0, 0x3f	; 63
    17aa:	f8 94       	cli
    17ac:	de bf       	out	0x3e, r29	; 62
    17ae:	0f be       	out	0x3f, r0	; 63
    17b0:	cd bf       	out	0x3d, r28	; 61
    17b2:	df 91       	pop	r29
    17b4:	cf 91       	pop	r28
    17b6:	08 95       	ret

000017b8 <delay_min>:
//------------------------------------------------------------------------------
void delay_min(int delay_in_min){
    17b8:	cf 93       	push	r28
    17ba:	df 93       	push	r29
    17bc:	cd b7       	in	r28, 0x3d	; 61
    17be:	de b7       	in	r29, 0x3e	; 62
    17c0:	2c 97       	sbiw	r28, 0x0c	; 12
    17c2:	0f b6       	in	r0, 0x3f	; 63
    17c4:	f8 94       	cli
    17c6:	de bf       	out	0x3e, r29	; 62
    17c8:	0f be       	out	0x3f, r0	; 63
    17ca:	cd bf       	out	0x3d, r28	; 61
    17cc:	9c 87       	std	Y+12, r25	; 0x0c
    17ce:	8b 87       	std	Y+11, r24	; 0x0b
    SysTimer_t min_timer; //Declares an instance of a new timer
    systmr_Init(&min_timer, tmr3_Get2msTicks_u16); //We are using 16 bits, so that the timer may count to a higher value
    17d0:	ce 01       	movw	r24, r28
    17d2:	02 96       	adiw	r24, 0x02	; 2
    17d4:	6d e1       	ldi	r22, 0x1D	; 29
    17d6:	7e e0       	ldi	r23, 0x0E	; 14
    17d8:	0e 94 39 0a 	call	0x1472	; 0x1472 <systmr_Init>
    systmr_Load(&min_timer); //Load the timer before starting. This is used as a referenece point.
    17dc:	ce 01       	movw	r24, r28
    17de:	02 96       	adiw	r24, 0x02	; 2
    17e0:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <systmr_Load>
    char i;

    for(i = 0; i < delay_in_min; i++){
    17e4:	19 82       	std	Y+1, r1	; 0x01
    17e6:	07 c0       	rjmp	.+14     	; 0x17f6 <delay_min+0x3e>
        delay_sec(60); //we use 60 since there are 60 seconds within each min
    17e8:	8c e3       	ldi	r24, 0x3C	; 60
    17ea:	90 e0       	ldi	r25, 0x00	; 0
    17ec:	0e 94 ab 0b 	call	0x1756	; 0x1756 <delay_sec>
    SysTimer_t min_timer; //Declares an instance of a new timer
    systmr_Init(&min_timer, tmr3_Get2msTicks_u16); //We are using 16 bits, so that the timer may count to a higher value
    systmr_Load(&min_timer); //Load the timer before starting. This is used as a referenece point.
    char i;

    for(i = 0; i < delay_in_min; i++){
    17f0:	89 81       	ldd	r24, Y+1	; 0x01
    17f2:	8f 5f       	subi	r24, 0xFF	; 255
    17f4:	89 83       	std	Y+1, r24	; 0x01
    17f6:	89 81       	ldd	r24, Y+1	; 0x01
    17f8:	28 2f       	mov	r18, r24
    17fa:	88 0f       	add	r24, r24
    17fc:	33 0b       	sbc	r19, r19
    17fe:	8b 85       	ldd	r24, Y+11	; 0x0b
    1800:	9c 85       	ldd	r25, Y+12	; 0x0c
    1802:	28 17       	cp	r18, r24
    1804:	39 07       	cpc	r19, r25
    1806:	84 f3       	brlt	.-32     	; 0x17e8 <delay_min+0x30>
        delay_sec(60); //we use 60 since there are 60 seconds within each min
    }

}
    1808:	2c 96       	adiw	r28, 0x0c	; 12
    180a:	0f b6       	in	r0, 0x3f	; 63
    180c:	f8 94       	cli
    180e:	de bf       	out	0x3e, r29	; 62
    1810:	0f be       	out	0x3f, r0	; 63
    1812:	cd bf       	out	0x3d, r28	; 61
    1814:	df 91       	pop	r29
    1816:	cf 91       	pop	r28
    1818:	08 95       	ret

0000181a <tmr0_Init>:

#include "timer0.h"

static Bool pwmB_in_use = FALSE;

void  tmr0_Init(void){
    181a:	cf 93       	push	r28
    181c:	df 93       	push	r29
    181e:	cd b7       	in	r28, 0x3d	; 61
    1820:	de b7       	in	r29, 0x3e	; 62
    cli(); // turn off global interrupts
    1822:	f8 94       	cli

    // configure OCR0B as output (for debugging, to make sure that the PWM is working:
    DDRD |= (1 << PORTD0); //OC0B <--This is what the IR LED is connected to
    1824:	8a e2       	ldi	r24, 0x2A	; 42
    1826:	90 e0       	ldi	r25, 0x00	; 0
    1828:	2a e2       	ldi	r18, 0x2A	; 42
    182a:	30 e0       	ldi	r19, 0x00	; 0
    182c:	f9 01       	movw	r30, r18
    182e:	20 81       	ld	r18, Z
    1830:	21 60       	ori	r18, 0x01	; 1
    1832:	fc 01       	movw	r30, r24
    1834:	20 83       	st	Z, r18
    PORTD &= ~(1<<PORTD0);
    1836:	8b e2       	ldi	r24, 0x2B	; 43
    1838:	90 e0       	ldi	r25, 0x00	; 0
    183a:	2b e2       	ldi	r18, 0x2B	; 43
    183c:	30 e0       	ldi	r19, 0x00	; 0
    183e:	f9 01       	movw	r30, r18
    1840:	20 81       	ld	r18, Z
    1842:	2e 7f       	andi	r18, 0xFE	; 254
    1844:	fc 01       	movw	r30, r24
    1846:	20 83       	st	Z, r18
    /*  Fast PWM 8-bit: WGM1[2:0] = 0b1110,
        set Fast PWM mode using OCR0A as TOP
        clear output on compare (in fast pwm mode): COM1A[1:0]=COM1B[1:0]=2
        note: WGM12 and WGM13 are located in TCCR1B
    */
    TCCR0A = _BV(WGM01) | _BV(WGM00);
    1848:	84 e4       	ldi	r24, 0x44	; 68
    184a:	90 e0       	ldi	r25, 0x00	; 0
    184c:	23 e0       	ldi	r18, 0x03	; 3
    184e:	fc 01       	movw	r30, r24
    1850:	20 83       	st	Z, r18
    TCCR0B = _BV(WGM02);
    1852:	85 e4       	ldi	r24, 0x45	; 69
    1854:	90 e0       	ldi	r25, 0x00	; 0
    1856:	28 e0       	ldi	r18, 0x08	; 8
    1858:	fc 01       	movw	r30, r24
    185a:	20 83       	st	Z, r18

    /*  Pre-scalar - divide by 0: CS1[2:0] = 0b001 */
    TCCR0B |= _BV(CS00);
    185c:	85 e4       	ldi	r24, 0x45	; 69
    185e:	90 e0       	ldi	r25, 0x00	; 0
    1860:	25 e4       	ldi	r18, 0x45	; 69
    1862:	30 e0       	ldi	r19, 0x00	; 0
    1864:	f9 01       	movw	r30, r18
    1866:	20 81       	ld	r18, Z
    1868:	21 60       	ori	r18, 0x01	; 1
    186a:	fc 01       	movw	r30, r24
    186c:	20 83       	st	Z, r18


    // Determine the Duty cycle to be used when in fast PWM mode...
    OCR0A = _56_KHZ; //This is set later when the IR LED is called.. This determines the frequency of the timer
    186e:	87 e4       	ldi	r24, 0x47	; 71
    1870:	90 e0       	ldi	r25, 0x00	; 0
    1872:	2f e8       	ldi	r18, 0x8F	; 143
    1874:	fc 01       	movw	r30, r24
    1876:	20 83       	st	Z, r18
    OCR0B = 30; //This is the only place where the duty cycle is set at this point***********************************************************************
    1878:	88 e4       	ldi	r24, 0x48	; 72
    187a:	90 e0       	ldi	r25, 0x00	; 0
    187c:	2e e1       	ldi	r18, 0x1E	; 30
    187e:	fc 01       	movw	r30, r24
    1880:	20 83       	st	Z, r18

    sei();
    1882:	78 94       	sei
}
    1884:	df 91       	pop	r29
    1886:	cf 91       	pop	r28
    1888:	08 95       	ret

0000188a <tmr0_PwmBOff>:

void  tmr0_PwmBOff(void){
    188a:	cf 93       	push	r28
    188c:	df 93       	push	r29
    188e:	cd b7       	in	r28, 0x3d	; 61
    1890:	de b7       	in	r29, 0x3e	; 62
    cli();
    1892:	f8 94       	cli
    TCCR0A &= ~(_BV(COM0B1));
    1894:	84 e4       	ldi	r24, 0x44	; 68
    1896:	90 e0       	ldi	r25, 0x00	; 0
    1898:	24 e4       	ldi	r18, 0x44	; 68
    189a:	30 e0       	ldi	r19, 0x00	; 0
    189c:	f9 01       	movw	r30, r18
    189e:	20 81       	ld	r18, Z
    18a0:	2f 7d       	andi	r18, 0xDF	; 223
    18a2:	fc 01       	movw	r30, r24
    18a4:	20 83       	st	Z, r18
    pwmB_in_use = FALSE;
    18a6:	10 92 de 04 	sts	0x04DE, r1	; 0x8004de <pwmB_in_use>
    sei();
    18aa:	78 94       	sei
}
    18ac:	df 91       	pop	r29
    18ae:	cf 91       	pop	r28
    18b0:	08 95       	ret

000018b2 <tmr0_PwmBOn>:

void  tmr0_PwmBOn(void){
    18b2:	cf 93       	push	r28
    18b4:	df 93       	push	r29
    18b6:	cd b7       	in	r28, 0x3d	; 61
    18b8:	de b7       	in	r29, 0x3e	; 62
    cli();
    18ba:	f8 94       	cli
    TCCR0A |= _BV(COM0B1);
    18bc:	84 e4       	ldi	r24, 0x44	; 68
    18be:	90 e0       	ldi	r25, 0x00	; 0
    18c0:	24 e4       	ldi	r18, 0x44	; 68
    18c2:	30 e0       	ldi	r19, 0x00	; 0
    18c4:	f9 01       	movw	r30, r18
    18c6:	20 81       	ld	r18, Z
    18c8:	20 62       	ori	r18, 0x20	; 32
    18ca:	fc 01       	movw	r30, r24
    18cc:	20 83       	st	Z, r18
    pwmB_in_use = TRUE;
    18ce:	81 e0       	ldi	r24, 0x01	; 1
    18d0:	80 93 de 04 	sts	0x04DE, r24	; 0x8004de <pwmB_in_use>
    sei();
    18d4:	78 94       	sei
}
    18d6:	df 91       	pop	r29
    18d8:	cf 91       	pop	r28
    18da:	08 95       	ret

000018dc <tmr0_ChangeFrequency>:

void tmr0_ChangeFrequency(Byte new_TOP){
    18dc:	cf 93       	push	r28
    18de:	df 93       	push	r29
    18e0:	1f 92       	push	r1
    18e2:	cd b7       	in	r28, 0x3d	; 61
    18e4:	de b7       	in	r29, 0x3e	; 62
    18e6:	89 83       	std	Y+1, r24	; 0x01
    if(new_TOP > 0 && new_TOP < 10000){
    18e8:	89 81       	ldd	r24, Y+1	; 0x01
    18ea:	88 23       	and	r24, r24
    18ec:	29 f0       	breq	.+10     	; 0x18f8 <tmr0_ChangeFrequency+0x1c>
        OCR0A = new_TOP;
    18ee:	87 e4       	ldi	r24, 0x47	; 71
    18f0:	90 e0       	ldi	r25, 0x00	; 0
    18f2:	29 81       	ldd	r18, Y+1	; 0x01
    18f4:	fc 01       	movw	r30, r24
    18f6:	20 83       	st	Z, r18
    }
}
    18f8:	0f 90       	pop	r0
    18fa:	df 91       	pop	r29
    18fc:	cf 91       	pop	r28
    18fe:	08 95       	ret

00001900 <tmr0_PwmB>:

void tmr0_PwmB(Byte duty){
    1900:	cf 93       	push	r28
    1902:	df 93       	push	r29
    1904:	1f 92       	push	r1
    1906:	cd b7       	in	r28, 0x3d	; 61
    1908:	de b7       	in	r29, 0x3e	; 62
    190a:	89 83       	std	Y+1, r24	; 0x01

    if(!duty){
    190c:	89 81       	ldd	r24, Y+1	; 0x01
    190e:	88 23       	and	r24, r24
    1910:	19 f4       	brne	.+6      	; 0x1918 <tmr0_PwmB+0x18>
       tmr0_PwmBOff();
    1912:	0e 94 45 0c 	call	0x188a	; 0x188a <tmr0_PwmBOff>
    1916:	07 c0       	rjmp	.+14     	; 0x1926 <tmr0_PwmB+0x26>
    }
    else {
       tmr0_PwmBOn();
    1918:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <tmr0_PwmBOn>
       OCR0A = duty;
    191c:	87 e4       	ldi	r24, 0x47	; 71
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	29 81       	ldd	r18, Y+1	; 0x01
    1922:	fc 01       	movw	r30, r24
    1924:	20 83       	st	Z, r18
    }
}
    1926:	0f 90       	pop	r0
    1928:	df 91       	pop	r29
    192a:	cf 91       	pop	r28
    192c:	08 95       	ret

0000192e <tmr0_PwmB_toggle>:

void tmr0_PwmB_toggle(Byte duty){
    192e:	cf 93       	push	r28
    1930:	df 93       	push	r29
    1932:	1f 92       	push	r1
    1934:	cd b7       	in	r28, 0x3d	; 61
    1936:	de b7       	in	r29, 0x3e	; 62
    1938:	89 83       	std	Y+1, r24	; 0x01
    if(pwmB_in_use){
    193a:	80 91 de 04 	lds	r24, 0x04DE	; 0x8004de <pwmB_in_use>
    193e:	88 23       	and	r24, r24
    1940:	19 f0       	breq	.+6      	; 0x1948 <tmr0_PwmB_toggle+0x1a>
        tmr0_PwmBOff();
    1942:	0e 94 45 0c 	call	0x188a	; 0x188a <tmr0_PwmBOff>
    1946:	07 c0       	rjmp	.+14     	; 0x1956 <tmr0_PwmB_toggle+0x28>
    }
    else{
        tmr0_PwmBOn();
    1948:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <tmr0_PwmBOn>
        OCR0A = duty;
    194c:	87 e4       	ldi	r24, 0x47	; 71
    194e:	90 e0       	ldi	r25, 0x00	; 0
    1950:	29 81       	ldd	r18, Y+1	; 0x01
    1952:	fc 01       	movw	r30, r24
    1954:	20 83       	st	Z, r18
    }
}
    1956:	0f 90       	pop	r0
    1958:	df 91       	pop	r29
    195a:	cf 91       	pop	r28
    195c:	08 95       	ret

0000195e <tmr1_Get2msTicks_u32>:

//----------------------------------------------------------------------------

/** unsigned long tmr0_Get2msTicks_u32(void)
*/
unsigned long tmr1_Get2msTicks_u32(void){
    195e:	cf 93       	push	r28
    1960:	df 93       	push	r29
    1962:	00 d0       	rcall	.+0      	; 0x1964 <tmr1_Get2msTicks_u32+0x6>
    1964:	00 d0       	rcall	.+0      	; 0x1966 <tmr1_Get2msTicks_u32+0x8>
    1966:	cd b7       	in	r28, 0x3d	; 61
    1968:	de b7       	in	r29, 0x3e	; 62
    unsigned long n;
    cli();
    196a:	f8 94       	cli
    n = tmr1_ticks;
    196c:	80 91 df 04 	lds	r24, 0x04DF	; 0x8004df <tmr1_ticks>
    1970:	90 91 e0 04 	lds	r25, 0x04E0	; 0x8004e0 <tmr1_ticks+0x1>
    1974:	a0 91 e1 04 	lds	r26, 0x04E1	; 0x8004e1 <tmr1_ticks+0x2>
    1978:	b0 91 e2 04 	lds	r27, 0x04E2	; 0x8004e2 <tmr1_ticks+0x3>
    197c:	89 83       	std	Y+1, r24	; 0x01
    197e:	9a 83       	std	Y+2, r25	; 0x02
    1980:	ab 83       	std	Y+3, r26	; 0x03
    1982:	bc 83       	std	Y+4, r27	; 0x04
    sei();
    1984:	78 94       	sei
    return n;
    1986:	89 81       	ldd	r24, Y+1	; 0x01
    1988:	9a 81       	ldd	r25, Y+2	; 0x02
    198a:	ab 81       	ldd	r26, Y+3	; 0x03
    198c:	bc 81       	ldd	r27, Y+4	; 0x04
}
    198e:	bc 01       	movw	r22, r24
    1990:	cd 01       	movw	r24, r26
    1992:	0f 90       	pop	r0
    1994:	0f 90       	pop	r0
    1996:	0f 90       	pop	r0
    1998:	0f 90       	pop	r0
    199a:	df 91       	pop	r29
    199c:	cf 91       	pop	r28
    199e:	08 95       	ret

000019a0 <tmr1_Get2msTicks_u16>:


unsigned int tmr1_Get2msTicks_u16(void){
    19a0:	cf 93       	push	r28
    19a2:	df 93       	push	r29
    19a4:	00 d0       	rcall	.+0      	; 0x19a6 <tmr1_Get2msTicks_u16+0x6>
    19a6:	cd b7       	in	r28, 0x3d	; 61
    19a8:	de b7       	in	r29, 0x3e	; 62
    unsigned int n;
    cli();
    19aa:	f8 94       	cli
    n = (unsigned int)tmr1_ticks;
    19ac:	80 91 df 04 	lds	r24, 0x04DF	; 0x8004df <tmr1_ticks>
    19b0:	90 91 e0 04 	lds	r25, 0x04E0	; 0x8004e0 <tmr1_ticks+0x1>
    19b4:	a0 91 e1 04 	lds	r26, 0x04E1	; 0x8004e1 <tmr1_ticks+0x2>
    19b8:	b0 91 e2 04 	lds	r27, 0x04E2	; 0x8004e2 <tmr1_ticks+0x3>
    19bc:	9a 83       	std	Y+2, r25	; 0x02
    19be:	89 83       	std	Y+1, r24	; 0x01
    sei();
    19c0:	78 94       	sei
    return n;
    19c2:	89 81       	ldd	r24, Y+1	; 0x01
    19c4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    19c6:	0f 90       	pop	r0
    19c8:	0f 90       	pop	r0
    19ca:	df 91       	pop	r29
    19cc:	cf 91       	pop	r28
    19ce:	08 95       	ret

000019d0 <tmr1_Get2msTicks_u8>:


unsigned char tmr1_Get2msTicks_u8(void){
    19d0:	cf 93       	push	r28
    19d2:	df 93       	push	r29
    19d4:	1f 92       	push	r1
    19d6:	cd b7       	in	r28, 0x3d	; 61
    19d8:	de b7       	in	r29, 0x3e	; 62
    unsigned char n;
    cli();
    19da:	f8 94       	cli
    n = (unsigned char)tmr1_ticks;
    19dc:	80 91 df 04 	lds	r24, 0x04DF	; 0x8004df <tmr1_ticks>
    19e0:	90 91 e0 04 	lds	r25, 0x04E0	; 0x8004e0 <tmr1_ticks+0x1>
    19e4:	a0 91 e1 04 	lds	r26, 0x04E1	; 0x8004e1 <tmr1_ticks+0x2>
    19e8:	b0 91 e2 04 	lds	r27, 0x04E2	; 0x8004e2 <tmr1_ticks+0x3>
    19ec:	89 83       	std	Y+1, r24	; 0x01
    sei();
    19ee:	78 94       	sei
    return n;
    19f0:	89 81       	ldd	r24, Y+1	; 0x01
}
    19f2:	0f 90       	pop	r0
    19f4:	df 91       	pop	r29
    19f6:	cf 91       	pop	r28
    19f8:	08 95       	ret

000019fa <tmr1_Get10msTicks_u16>:


unsigned int tmr1_Get10msTicks_u16(void){
    19fa:	cf 93       	push	r28
    19fc:	df 93       	push	r29
    19fe:	00 d0       	rcall	.+0      	; 0x1a00 <tmr1_Get10msTicks_u16+0x6>
    1a00:	cd b7       	in	r28, 0x3d	; 61
    1a02:	de b7       	in	r29, 0x3e	; 62
    unsigned int n;
    cli();
    1a04:	f8 94       	cli
    n = (unsigned int)tmr1_fifth_ticks;
    1a06:	80 91 e3 04 	lds	r24, 0x04E3	; 0x8004e3 <tmr1_fifth_ticks>
    1a0a:	90 91 e4 04 	lds	r25, 0x04E4	; 0x8004e4 <tmr1_fifth_ticks+0x1>
    1a0e:	a0 91 e5 04 	lds	r26, 0x04E5	; 0x8004e5 <tmr1_fifth_ticks+0x2>
    1a12:	b0 91 e6 04 	lds	r27, 0x04E6	; 0x8004e6 <tmr1_fifth_ticks+0x3>
    1a16:	9a 83       	std	Y+2, r25	; 0x02
    1a18:	89 83       	std	Y+1, r24	; 0x01
    sei();
    1a1a:	78 94       	sei
    return n;
    1a1c:	89 81       	ldd	r24, Y+1	; 0x01
    1a1e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1a20:	0f 90       	pop	r0
    1a22:	0f 90       	pop	r0
    1a24:	df 91       	pop	r29
    1a26:	cf 91       	pop	r28
    1a28:	08 95       	ret

00001a2a <tmr1_Init>:

/** void tck_Init(void)
* Initialize the timer hardware for the tick time base.
*/
//timer 1 PWM Configuration
void  tmr1_Init(void){
    1a2a:	cf 93       	push	r28
    1a2c:	df 93       	push	r29
    1a2e:	1f 92       	push	r1
    1a30:	cd b7       	in	r28, 0x3d	; 61
    1a32:	de b7       	in	r29, 0x3e	; 62
    //Try to disable the usb interrupt vectors
    //USBINT = 0;
        UDINT  = 0;
    1a34:	81 ee       	ldi	r24, 0xE1	; 225
    1a36:	90 e0       	ldi	r25, 0x00	; 0
    1a38:	fc 01       	movw	r30, r24
    1a3a:	10 82       	st	Z, r1
    uint8_t _i;

    //USBINT = 0;
    //UDINT  = 0;

    for ( _i = 0; _i < 6; _i++) { // For each USB endpoint
    1a3c:	19 82       	std	Y+1, r1	; 0x01
    1a3e:	11 c0       	rjmp	.+34     	; 0x1a62 <tmr1_Init+0x38>
       UENUM = _i; // select the _i-th endpoint
    1a40:	89 ee       	ldi	r24, 0xE9	; 233
    1a42:	90 e0       	ldi	r25, 0x00	; 0
    1a44:	29 81       	ldd	r18, Y+1	; 0x01
    1a46:	fc 01       	movw	r30, r24
    1a48:	20 83       	st	Z, r18
       UEINTX = UEIENX = 0; // Clear interrupt flags for that endpoint
    1a4a:	88 ee       	ldi	r24, 0xE8	; 232
    1a4c:	90 e0       	ldi	r25, 0x00	; 0
    1a4e:	20 ef       	ldi	r18, 0xF0	; 240
    1a50:	30 e0       	ldi	r19, 0x00	; 0
    1a52:	40 e0       	ldi	r20, 0x00	; 0
    1a54:	f9 01       	movw	r30, r18
    1a56:	40 83       	st	Z, r20
    1a58:	fc 01       	movw	r30, r24
    1a5a:	40 83       	st	Z, r20
    uint8_t _i;

    //USBINT = 0;
    //UDINT  = 0;

    for ( _i = 0; _i < 6; _i++) { // For each USB endpoint
    1a5c:	89 81       	ldd	r24, Y+1	; 0x01
    1a5e:	8f 5f       	subi	r24, 0xFF	; 255
    1a60:	89 83       	std	Y+1, r24	; 0x01
    1a62:	89 81       	ldd	r24, Y+1	; 0x01
    1a64:	86 30       	cpi	r24, 0x06	; 6
    1a66:	60 f3       	brcs	.-40     	; 0x1a40 <tmr1_Init+0x16>
       UEINTX = UEIENX = 0; // Clear interrupt flags for that endpoint
    }



    cli(); // turn off global interrupts
    1a68:	f8 94       	cli

    // configure OCR0A and OCR0Bas output:
    DDRD |= (1<<PORTD0)+(1<<PORTD1);
    1a6a:	8a e2       	ldi	r24, 0x2A	; 42
    1a6c:	90 e0       	ldi	r25, 0x00	; 0
    1a6e:	2a e2       	ldi	r18, 0x2A	; 42
    1a70:	30 e0       	ldi	r19, 0x00	; 0
    1a72:	f9 01       	movw	r30, r18
    1a74:	20 81       	ld	r18, Z
    1a76:	23 60       	ori	r18, 0x03	; 3
    1a78:	fc 01       	movw	r30, r24
    1a7a:	20 83       	st	Z, r18

    //CTC Mode with OCR1A as TOP
    TCCR1A = 0;
    1a7c:	80 e8       	ldi	r24, 0x80	; 128
    1a7e:	90 e0       	ldi	r25, 0x00	; 0
    1a80:	fc 01       	movw	r30, r24
    1a82:	10 82       	st	Z, r1
	TCCR1B = (1 << WGM12);
    1a84:	81 e8       	ldi	r24, 0x81	; 129
    1a86:	90 e0       	ldi	r25, 0x00	; 0
    1a88:	28 e0       	ldi	r18, 0x08	; 8
    1a8a:	fc 01       	movw	r30, r24
    1a8c:	20 83       	st	Z, r18

    //  Pre-scalar - divide by 64: CS1[2:0] = 0b011
    TCCR1B |= (1 << CS10);// | _BV(CS11);
    1a8e:	81 e8       	ldi	r24, 0x81	; 129
    1a90:	90 e0       	ldi	r25, 0x00	; 0
    1a92:	21 e8       	ldi	r18, 0x81	; 129
    1a94:	30 e0       	ldi	r19, 0x00	; 0
    1a96:	f9 01       	movw	r30, r18
    1a98:	20 81       	ld	r18, Z
    1a9a:	21 60       	ori	r18, 0x01	; 1
    1a9c:	fc 01       	movw	r30, r24
    1a9e:	20 83       	st	Z, r18

    OCR1A = 25000; //This is defined as the TOP
    1aa0:	88 e8       	ldi	r24, 0x88	; 136
    1aa2:	90 e0       	ldi	r25, 0x00	; 0
    1aa4:	28 ea       	ldi	r18, 0xA8	; 168
    1aa6:	31 e6       	ldi	r19, 0x61	; 97
    1aa8:	fc 01       	movw	r30, r24
    1aaa:	31 83       	std	Z+1, r19	; 0x01
    1aac:	20 83       	st	Z, r18
    OCR1B = 200;
    1aae:	8a e8       	ldi	r24, 0x8A	; 138
    1ab0:	90 e0       	ldi	r25, 0x00	; 0
    1ab2:	28 ec       	ldi	r18, 0xC8	; 200
    1ab4:	30 e0       	ldi	r19, 0x00	; 0
    1ab6:	fc 01       	movw	r30, r24
    1ab8:	31 83       	std	Z+1, r19	; 0x01
    1aba:	20 83       	st	Z, r18

    TCCR1C = 0; // not forcing output compare
    1abc:	82 e8       	ldi	r24, 0x82	; 130
    1abe:	90 e0       	ldi	r25, 0x00	; 0
    1ac0:	fc 01       	movw	r30, r24
    1ac2:	10 82       	st	Z, r1
    TCNT1 = 0; //The timer value is stored here, and therefore we want to reset the timer...
    1ac4:	84 e8       	ldi	r24, 0x84	; 132
    1ac6:	90 e0       	ldi	r25, 0x00	; 0
    1ac8:	fc 01       	movw	r30, r24
    1aca:	11 82       	std	Z+1, r1	; 0x01
    1acc:	10 82       	st	Z, r1

    // enable Timer1 CTCA interrupt
    TIMSK1 = (1<<OCIE1A);
    1ace:	8f e6       	ldi	r24, 0x6F	; 111
    1ad0:	90 e0       	ldi	r25, 0x00	; 0
    1ad2:	22 e0       	ldi	r18, 0x02	; 2
    1ad4:	fc 01       	movw	r30, r24
    1ad6:	20 83       	st	Z, r18

    //
    USBCON = 0;
    1ad8:	88 ed       	ldi	r24, 0xD8	; 216
    1ada:	90 e0       	ldi	r25, 0x00	; 0
    1adc:	fc 01       	movw	r30, r24
    1ade:	10 82       	st	Z, r1
    USBCON |= (1 << FRZCLK);
    1ae0:	88 ed       	ldi	r24, 0xD8	; 216
    1ae2:	90 e0       	ldi	r25, 0x00	; 0
    1ae4:	28 ed       	ldi	r18, 0xD8	; 216
    1ae6:	30 e0       	ldi	r19, 0x00	; 0
    1ae8:	f9 01       	movw	r30, r18
    1aea:	20 81       	ld	r18, Z
    1aec:	20 62       	ori	r18, 0x20	; 32
    1aee:	fc 01       	movw	r30, r24
    1af0:	20 83       	st	Z, r18
    PRR1 |= (1 << PRUSB);
    1af2:	85 e6       	ldi	r24, 0x65	; 101
    1af4:	90 e0       	ldi	r25, 0x00	; 0
    1af6:	25 e6       	ldi	r18, 0x65	; 101
    1af8:	30 e0       	ldi	r19, 0x00	; 0
    1afa:	f9 01       	movw	r30, r18
    1afc:	20 81       	ld	r18, Z
    1afe:	20 68       	ori	r18, 0x80	; 128
    1b00:	fc 01       	movw	r30, r24
    1b02:	20 83       	st	Z, r18
    UDIEN = 0;
    1b04:	82 ee       	ldi	r24, 0xE2	; 226
    1b06:	90 e0       	ldi	r25, 0x00	; 0
    1b08:	fc 01       	movw	r30, r24
    1b0a:	10 82       	st	Z, r1


    sei(); //Set global Interrupts
    1b0c:	78 94       	sei

}
    1b0e:	0f 90       	pop	r0
    1b10:	df 91       	pop	r29
    1b12:	cf 91       	pop	r28
    1b14:	08 95       	ret

00001b16 <tmr1_PwmsOff>:

void  tmr1_PwmsOff(void){
    1b16:	cf 93       	push	r28
    1b18:	df 93       	push	r29
    1b1a:	cd b7       	in	r28, 0x3d	; 61
    1b1c:	de b7       	in	r29, 0x3e	; 62
    TCCR1A &= ~(_BV(COM1B1)); //Disable PD0 toggle
    1b1e:	80 e8       	ldi	r24, 0x80	; 128
    1b20:	90 e0       	ldi	r25, 0x00	; 0
    1b22:	20 e8       	ldi	r18, 0x80	; 128
    1b24:	30 e0       	ldi	r19, 0x00	; 0
    1b26:	f9 01       	movw	r30, r18
    1b28:	20 81       	ld	r18, Z
    1b2a:	2f 7d       	andi	r18, 0xDF	; 223
    1b2c:	fc 01       	movw	r30, r24
    1b2e:	20 83       	st	Z, r18
}
    1b30:	df 91       	pop	r29
    1b32:	cf 91       	pop	r28
    1b34:	08 95       	ret

00001b36 <tmr1_PwmsOn>:

void  tmr1_PwmsOn(void){
    1b36:	cf 93       	push	r28
    1b38:	df 93       	push	r29
    1b3a:	cd b7       	in	r28, 0x3d	; 61
    1b3c:	de b7       	in	r29, 0x3e	; 62
    cli();
    1b3e:	f8 94       	cli
    TCCR1A |= (_BV(COM1B1)); //Enable PD0 toggle
    1b40:	80 e8       	ldi	r24, 0x80	; 128
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	20 e8       	ldi	r18, 0x80	; 128
    1b46:	30 e0       	ldi	r19, 0x00	; 0
    1b48:	f9 01       	movw	r30, r18
    1b4a:	20 81       	ld	r18, Z
    1b4c:	20 62       	ori	r18, 0x20	; 32
    1b4e:	fc 01       	movw	r30, r24
    1b50:	20 83       	st	Z, r18
    sei();
    1b52:	78 94       	sei
}
    1b54:	df 91       	pop	r29
    1b56:	cf 91       	pop	r28
    1b58:	08 95       	ret

00001b5a <tmr1_PwmA>:

void  tmr1_PwmA(Byte duty){
    1b5a:	cf 93       	push	r28
    1b5c:	df 93       	push	r29
    1b5e:	1f 92       	push	r1
    1b60:	cd b7       	in	r28, 0x3d	; 61
    1b62:	de b7       	in	r29, 0x3e	; 62
    1b64:	89 83       	std	Y+1, r24	; 0x01
    if(!duty){
    1b66:	89 81       	ldd	r24, Y+1	; 0x01
    1b68:	88 23       	and	r24, r24
    1b6a:	19 f4       	brne	.+6      	; 0x1b72 <tmr1_PwmA+0x18>
       tmr1_PwmsOff();
    1b6c:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <tmr1_PwmsOff>
    1b70:	18 c0       	rjmp	.+48     	; 0x1ba2 <tmr1_PwmA+0x48>
    }
    else {
       tmr1_PwmsOn();
    1b72:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <tmr1_PwmsOn>
       OCR1A = duty;
    1b76:	88 e8       	ldi	r24, 0x88	; 136
    1b78:	90 e0       	ldi	r25, 0x00	; 0
    1b7a:	29 81       	ldd	r18, Y+1	; 0x01
    1b7c:	22 2f       	mov	r18, r18
    1b7e:	30 e0       	ldi	r19, 0x00	; 0
    1b80:	fc 01       	movw	r30, r24
    1b82:	31 83       	std	Z+1, r19	; 0x01
    1b84:	20 83       	st	Z, r18
       OCR1B = 255 - duty; // just because...
    1b86:	8a e8       	ldi	r24, 0x8A	; 138
    1b88:	90 e0       	ldi	r25, 0x00	; 0
    1b8a:	29 81       	ldd	r18, Y+1	; 0x01
    1b8c:	22 2f       	mov	r18, r18
    1b8e:	30 e0       	ldi	r19, 0x00	; 0
    1b90:	4f ef       	ldi	r20, 0xFF	; 255
    1b92:	50 e0       	ldi	r21, 0x00	; 0
    1b94:	ba 01       	movw	r22, r20
    1b96:	62 1b       	sub	r22, r18
    1b98:	73 0b       	sbc	r23, r19
    1b9a:	9b 01       	movw	r18, r22
    1b9c:	fc 01       	movw	r30, r24
    1b9e:	31 83       	std	Z+1, r19	; 0x01
    1ba0:	20 83       	st	Z, r18
    }
}
    1ba2:	0f 90       	pop	r0
    1ba4:	df 91       	pop	r29
    1ba6:	cf 91       	pop	r28
    1ba8:	08 95       	ret

00001baa <__vector_17>:



//----------------------------------------------------------------------------
// TIMER1 CTC INTERRUPT:
ISR(TIMER1_COMPA_vect) {
    1baa:	1f 92       	push	r1
    1bac:	0f 92       	push	r0
    1bae:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1bb2:	0f 92       	push	r0
    1bb4:	11 24       	eor	r1, r1
    1bb6:	2f 93       	push	r18
    1bb8:	3f 93       	push	r19
    1bba:	8f 93       	push	r24
    1bbc:	9f 93       	push	r25
    1bbe:	ef 93       	push	r30
    1bc0:	ff 93       	push	r31
    1bc2:	cf 93       	push	r28
    1bc4:	df 93       	push	r29
    1bc6:	cd b7       	in	r28, 0x3d	; 61
    1bc8:	de b7       	in	r29, 0x3e	; 62

    PORTD |= (1 << PORTD5);
    1bca:	8b e2       	ldi	r24, 0x2B	; 43
    1bcc:	90 e0       	ldi	r25, 0x00	; 0
    1bce:	2b e2       	ldi	r18, 0x2B	; 43
    1bd0:	30 e0       	ldi	r19, 0x00	; 0
    1bd2:	f9 01       	movw	r30, r18
    1bd4:	20 81       	ld	r18, Z
    1bd6:	20 62       	ori	r18, 0x20	; 32
    1bd8:	fc 01       	movw	r30, r24
    1bda:	20 83       	st	Z, r18
    if(++i >= 5) {
        i = 0;
        ++tmr1_fifth_ticks;
    }
*/
}
    1bdc:	df 91       	pop	r29
    1bde:	cf 91       	pop	r28
    1be0:	ff 91       	pop	r31
    1be2:	ef 91       	pop	r30
    1be4:	9f 91       	pop	r25
    1be6:	8f 91       	pop	r24
    1be8:	3f 91       	pop	r19
    1bea:	2f 91       	pop	r18
    1bec:	0f 90       	pop	r0
    1bee:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1bf2:	0f 90       	pop	r0
    1bf4:	1f 90       	pop	r1
    1bf6:	18 95       	reti

00001bf8 <tmr3_Get2msTicks_u32>:

//----------------------------------------------------------------------------

/** unsigned long tmr0_Get2msTicks_u32(void)
*/
unsigned long tmr3_Get2msTicks_u32(void){
    1bf8:	cf 93       	push	r28
    1bfa:	df 93       	push	r29
    1bfc:	00 d0       	rcall	.+0      	; 0x1bfe <tmr3_Get2msTicks_u32+0x6>
    1bfe:	00 d0       	rcall	.+0      	; 0x1c00 <tmr3_Get2msTicks_u32+0x8>
    1c00:	cd b7       	in	r28, 0x3d	; 61
    1c02:	de b7       	in	r29, 0x3e	; 62
    unsigned long n;
    cli();
    1c04:	f8 94       	cli
    n = tmr3_ticks;
    1c06:	80 91 e7 04 	lds	r24, 0x04E7	; 0x8004e7 <tmr3_ticks>
    1c0a:	90 91 e8 04 	lds	r25, 0x04E8	; 0x8004e8 <tmr3_ticks+0x1>
    1c0e:	a0 91 e9 04 	lds	r26, 0x04E9	; 0x8004e9 <tmr3_ticks+0x2>
    1c12:	b0 91 ea 04 	lds	r27, 0x04EA	; 0x8004ea <tmr3_ticks+0x3>
    1c16:	89 83       	std	Y+1, r24	; 0x01
    1c18:	9a 83       	std	Y+2, r25	; 0x02
    1c1a:	ab 83       	std	Y+3, r26	; 0x03
    1c1c:	bc 83       	std	Y+4, r27	; 0x04
    sei();
    1c1e:	78 94       	sei
    return n;
    1c20:	89 81       	ldd	r24, Y+1	; 0x01
    1c22:	9a 81       	ldd	r25, Y+2	; 0x02
    1c24:	ab 81       	ldd	r26, Y+3	; 0x03
    1c26:	bc 81       	ldd	r27, Y+4	; 0x04
}
    1c28:	bc 01       	movw	r22, r24
    1c2a:	cd 01       	movw	r24, r26
    1c2c:	0f 90       	pop	r0
    1c2e:	0f 90       	pop	r0
    1c30:	0f 90       	pop	r0
    1c32:	0f 90       	pop	r0
    1c34:	df 91       	pop	r29
    1c36:	cf 91       	pop	r28
    1c38:	08 95       	ret

00001c3a <tmr3_Get2msTicks_u16>:


unsigned int tmr3_Get2msTicks_u16(void){
    1c3a:	cf 93       	push	r28
    1c3c:	df 93       	push	r29
    1c3e:	00 d0       	rcall	.+0      	; 0x1c40 <tmr3_Get2msTicks_u16+0x6>
    1c40:	cd b7       	in	r28, 0x3d	; 61
    1c42:	de b7       	in	r29, 0x3e	; 62
    unsigned int n;
    cli();
    1c44:	f8 94       	cli
    n = (unsigned int)tmr3_ticks;
    1c46:	80 91 e7 04 	lds	r24, 0x04E7	; 0x8004e7 <tmr3_ticks>
    1c4a:	90 91 e8 04 	lds	r25, 0x04E8	; 0x8004e8 <tmr3_ticks+0x1>
    1c4e:	a0 91 e9 04 	lds	r26, 0x04E9	; 0x8004e9 <tmr3_ticks+0x2>
    1c52:	b0 91 ea 04 	lds	r27, 0x04EA	; 0x8004ea <tmr3_ticks+0x3>
    1c56:	9a 83       	std	Y+2, r25	; 0x02
    1c58:	89 83       	std	Y+1, r24	; 0x01
    sei();
    1c5a:	78 94       	sei
    return n;
    1c5c:	89 81       	ldd	r24, Y+1	; 0x01
    1c5e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1c60:	0f 90       	pop	r0
    1c62:	0f 90       	pop	r0
    1c64:	df 91       	pop	r29
    1c66:	cf 91       	pop	r28
    1c68:	08 95       	ret

00001c6a <tmr3_Get2msTicks_u8>:


unsigned char tmr3_Get2msTicks_u8(void){
    1c6a:	cf 93       	push	r28
    1c6c:	df 93       	push	r29
    1c6e:	1f 92       	push	r1
    1c70:	cd b7       	in	r28, 0x3d	; 61
    1c72:	de b7       	in	r29, 0x3e	; 62
    unsigned char n;
    cli();
    1c74:	f8 94       	cli
    n = (unsigned char)tmr3_ticks;
    1c76:	80 91 e7 04 	lds	r24, 0x04E7	; 0x8004e7 <tmr3_ticks>
    1c7a:	90 91 e8 04 	lds	r25, 0x04E8	; 0x8004e8 <tmr3_ticks+0x1>
    1c7e:	a0 91 e9 04 	lds	r26, 0x04E9	; 0x8004e9 <tmr3_ticks+0x2>
    1c82:	b0 91 ea 04 	lds	r27, 0x04EA	; 0x8004ea <tmr3_ticks+0x3>
    1c86:	89 83       	std	Y+1, r24	; 0x01
    sei();
    1c88:	78 94       	sei
    return n;
    1c8a:	89 81       	ldd	r24, Y+1	; 0x01
}
    1c8c:	0f 90       	pop	r0
    1c8e:	df 91       	pop	r29
    1c90:	cf 91       	pop	r28
    1c92:	08 95       	ret

00001c94 <tmr3_Get10msTicks_u16>:


unsigned int tmr3_Get10msTicks_u16(void){
    1c94:	cf 93       	push	r28
    1c96:	df 93       	push	r29
    1c98:	00 d0       	rcall	.+0      	; 0x1c9a <tmr3_Get10msTicks_u16+0x6>
    1c9a:	cd b7       	in	r28, 0x3d	; 61
    1c9c:	de b7       	in	r29, 0x3e	; 62
    unsigned int n;
    cli();
    1c9e:	f8 94       	cli
    n = (unsigned int)tmr3_fifth_ticks;
    1ca0:	80 91 eb 04 	lds	r24, 0x04EB	; 0x8004eb <tmr3_fifth_ticks>
    1ca4:	90 91 ec 04 	lds	r25, 0x04EC	; 0x8004ec <tmr3_fifth_ticks+0x1>
    1ca8:	a0 91 ed 04 	lds	r26, 0x04ED	; 0x8004ed <tmr3_fifth_ticks+0x2>
    1cac:	b0 91 ee 04 	lds	r27, 0x04EE	; 0x8004ee <tmr3_fifth_ticks+0x3>
    1cb0:	9a 83       	std	Y+2, r25	; 0x02
    1cb2:	89 83       	std	Y+1, r24	; 0x01
    sei();
    1cb4:	78 94       	sei
    return n;
    1cb6:	89 81       	ldd	r24, Y+1	; 0x01
    1cb8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1cba:	0f 90       	pop	r0
    1cbc:	0f 90       	pop	r0
    1cbe:	df 91       	pop	r29
    1cc0:	cf 91       	pop	r28
    1cc2:	08 95       	ret

00001cc4 <tmr3_Init>:

/** void tck_Init(void)
* Initialize the timer hardware for the tick time base.
*/
//timer 1 PWM Configuration
void  tmr3_Init(void){
    1cc4:	cf 93       	push	r28
    1cc6:	df 93       	push	r29
    1cc8:	cd b7       	in	r28, 0x3d	; 61
    1cca:	de b7       	in	r29, 0x3e	; 62
    cli(); // turn off global interrupts
    1ccc:	f8 94       	cli

    // configure OCR3A as output:
    //DDRD |= (1<<PORTC6);

    //CTC Mode with OCR1A as TOP
    TCCR3A = 0;
    1cce:	80 e9       	ldi	r24, 0x90	; 144
    1cd0:	90 e0       	ldi	r25, 0x00	; 0
    1cd2:	fc 01       	movw	r30, r24
    1cd4:	10 82       	st	Z, r1
	TCCR3B = (1 << WGM32);
    1cd6:	81 e9       	ldi	r24, 0x91	; 145
    1cd8:	90 e0       	ldi	r25, 0x00	; 0
    1cda:	28 e0       	ldi	r18, 0x08	; 8
    1cdc:	fc 01       	movw	r30, r24
    1cde:	20 83       	st	Z, r18

    //  Pre-scalar - divide by 64: CS1[2:0] = 0b011
    TCCR3B |= (1 << CS31) | (1 << CS30);
    1ce0:	81 e9       	ldi	r24, 0x91	; 145
    1ce2:	90 e0       	ldi	r25, 0x00	; 0
    1ce4:	21 e9       	ldi	r18, 0x91	; 145
    1ce6:	30 e0       	ldi	r19, 0x00	; 0
    1ce8:	f9 01       	movw	r30, r18
    1cea:	20 81       	ld	r18, Z
    1cec:	23 60       	ori	r18, 0x03	; 3
    1cee:	fc 01       	movw	r30, r24
    1cf0:	20 83       	st	Z, r18

    OCR3A = 232; //This is defined as the TOP
    1cf2:	88 e9       	ldi	r24, 0x98	; 152
    1cf4:	90 e0       	ldi	r25, 0x00	; 0
    1cf6:	28 ee       	ldi	r18, 0xE8	; 232
    1cf8:	30 e0       	ldi	r19, 0x00	; 0
    1cfa:	fc 01       	movw	r30, r24
    1cfc:	31 83       	std	Z+1, r19	; 0x01
    1cfe:	20 83       	st	Z, r18

    TCCR3C = 0; // not forcing output compare
    1d00:	82 e9       	ldi	r24, 0x92	; 146
    1d02:	90 e0       	ldi	r25, 0x00	; 0
    1d04:	fc 01       	movw	r30, r24
    1d06:	10 82       	st	Z, r1
    TCNT3 = 0; //The timer value is stored here, and therefore we want to reset the timer...
    1d08:	84 e9       	ldi	r24, 0x94	; 148
    1d0a:	90 e0       	ldi	r25, 0x00	; 0
    1d0c:	fc 01       	movw	r30, r24
    1d0e:	11 82       	std	Z+1, r1	; 0x01
    1d10:	10 82       	st	Z, r1

    // enable Timer1 CTCA interrupt
    TIMSK3 = (1<<OCIE3A);
    1d12:	81 e7       	ldi	r24, 0x71	; 113
    1d14:	90 e0       	ldi	r25, 0x00	; 0
    1d16:	22 e0       	ldi	r18, 0x02	; 2
    1d18:	fc 01       	movw	r30, r24
    1d1a:	20 83       	st	Z, r18

    // This is just used for debugging.... Our team read on some forums that the USB can interfere with different ISRs and therefore we tried to disable everything USB
    USBCON = 0;
    1d1c:	88 ed       	ldi	r24, 0xD8	; 216
    1d1e:	90 e0       	ldi	r25, 0x00	; 0
    1d20:	fc 01       	movw	r30, r24
    1d22:	10 82       	st	Z, r1
    USBCON |= (1 << FRZCLK);
    1d24:	88 ed       	ldi	r24, 0xD8	; 216
    1d26:	90 e0       	ldi	r25, 0x00	; 0
    1d28:	28 ed       	ldi	r18, 0xD8	; 216
    1d2a:	30 e0       	ldi	r19, 0x00	; 0
    1d2c:	f9 01       	movw	r30, r18
    1d2e:	20 81       	ld	r18, Z
    1d30:	20 62       	ori	r18, 0x20	; 32
    1d32:	fc 01       	movw	r30, r24
    1d34:	20 83       	st	Z, r18
    PRR1 |= (1 << PRUSB);
    1d36:	85 e6       	ldi	r24, 0x65	; 101
    1d38:	90 e0       	ldi	r25, 0x00	; 0
    1d3a:	25 e6       	ldi	r18, 0x65	; 101
    1d3c:	30 e0       	ldi	r19, 0x00	; 0
    1d3e:	f9 01       	movw	r30, r18
    1d40:	20 81       	ld	r18, Z
    1d42:	20 68       	ori	r18, 0x80	; 128
    1d44:	fc 01       	movw	r30, r24
    1d46:	20 83       	st	Z, r18
    UDIEN = 0;
    1d48:	82 ee       	ldi	r24, 0xE2	; 226
    1d4a:	90 e0       	ldi	r25, 0x00	; 0
    1d4c:	fc 01       	movw	r30, r24
    1d4e:	10 82       	st	Z, r1


    sei(); //Set global Interrupts
    1d50:	78 94       	sei

}
    1d52:	df 91       	pop	r29
    1d54:	cf 91       	pop	r28
    1d56:	08 95       	ret

00001d58 <tmr3_PwmsOff>:


void  tmr3_PwmsOff(void){ //
    1d58:	cf 93       	push	r28
    1d5a:	df 93       	push	r29
    1d5c:	cd b7       	in	r28, 0x3d	; 61
    1d5e:	de b7       	in	r29, 0x3e	; 62
    TCCR3A &= ~(_BV(COM3A1)); //Disable PC6 toggle
    1d60:	80 e9       	ldi	r24, 0x90	; 144
    1d62:	90 e0       	ldi	r25, 0x00	; 0
    1d64:	20 e9       	ldi	r18, 0x90	; 144
    1d66:	30 e0       	ldi	r19, 0x00	; 0
    1d68:	f9 01       	movw	r30, r18
    1d6a:	20 81       	ld	r18, Z
    1d6c:	2f 77       	andi	r18, 0x7F	; 127
    1d6e:	fc 01       	movw	r30, r24
    1d70:	20 83       	st	Z, r18
}
    1d72:	df 91       	pop	r29
    1d74:	cf 91       	pop	r28
    1d76:	08 95       	ret

00001d78 <tmr3_PwmsOn>:

void  tmr3_PwmsOn(void){
    1d78:	cf 93       	push	r28
    1d7a:	df 93       	push	r29
    1d7c:	cd b7       	in	r28, 0x3d	; 61
    1d7e:	de b7       	in	r29, 0x3e	; 62
    cli();
    1d80:	f8 94       	cli
    TCCR3A |= (_BV(COM3A1)); //Enable PC6 toggle
    1d82:	80 e9       	ldi	r24, 0x90	; 144
    1d84:	90 e0       	ldi	r25, 0x00	; 0
    1d86:	20 e9       	ldi	r18, 0x90	; 144
    1d88:	30 e0       	ldi	r19, 0x00	; 0
    1d8a:	f9 01       	movw	r30, r18
    1d8c:	20 81       	ld	r18, Z
    1d8e:	20 68       	ori	r18, 0x80	; 128
    1d90:	fc 01       	movw	r30, r24
    1d92:	20 83       	st	Z, r18
    sei();
    1d94:	78 94       	sei
}
    1d96:	df 91       	pop	r29
    1d98:	cf 91       	pop	r28
    1d9a:	08 95       	ret

00001d9c <tmr3_PwmA>:

void  tmr3_PwmA(Byte duty){
    1d9c:	cf 93       	push	r28
    1d9e:	df 93       	push	r29
    1da0:	1f 92       	push	r1
    1da2:	cd b7       	in	r28, 0x3d	; 61
    1da4:	de b7       	in	r29, 0x3e	; 62
    1da6:	89 83       	std	Y+1, r24	; 0x01
    if(!duty){
    1da8:	89 81       	ldd	r24, Y+1	; 0x01
    1daa:	88 23       	and	r24, r24
    1dac:	19 f4       	brne	.+6      	; 0x1db4 <tmr3_PwmA+0x18>
       tmr3_PwmsOff();
    1dae:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <tmr3_PwmsOff>
    1db2:	18 c0       	rjmp	.+48     	; 0x1de4 <tmr3_PwmA+0x48>
    }
    else {
       tmr3_PwmsOn();
    1db4:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <tmr3_PwmsOn>
       OCR3A = duty;
    1db8:	88 e9       	ldi	r24, 0x98	; 152
    1dba:	90 e0       	ldi	r25, 0x00	; 0
    1dbc:	29 81       	ldd	r18, Y+1	; 0x01
    1dbe:	22 2f       	mov	r18, r18
    1dc0:	30 e0       	ldi	r19, 0x00	; 0
    1dc2:	fc 01       	movw	r30, r24
    1dc4:	31 83       	std	Z+1, r19	; 0x01
    1dc6:	20 83       	st	Z, r18
       OCR3B = 255 - duty; // just because...
    1dc8:	8a e9       	ldi	r24, 0x9A	; 154
    1dca:	90 e0       	ldi	r25, 0x00	; 0
    1dcc:	29 81       	ldd	r18, Y+1	; 0x01
    1dce:	22 2f       	mov	r18, r18
    1dd0:	30 e0       	ldi	r19, 0x00	; 0
    1dd2:	4f ef       	ldi	r20, 0xFF	; 255
    1dd4:	50 e0       	ldi	r21, 0x00	; 0
    1dd6:	ba 01       	movw	r22, r20
    1dd8:	62 1b       	sub	r22, r18
    1dda:	73 0b       	sbc	r23, r19
    1ddc:	9b 01       	movw	r18, r22
    1dde:	fc 01       	movw	r30, r24
    1de0:	31 83       	std	Z+1, r19	; 0x01
    1de2:	20 83       	st	Z, r18
    }
}
    1de4:	0f 90       	pop	r0
    1de6:	df 91       	pop	r29
    1de8:	cf 91       	pop	r28
    1dea:	08 95       	ret

00001dec <__vector_32>:



//----------------------------------------------------------------------------
// TIMER1 CTC INTERRUPT:
ISR(TIMER3_COMPA_vect) {
    1dec:	1f 92       	push	r1
    1dee:	0f 92       	push	r0
    1df0:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1df4:	0f 92       	push	r0
    1df6:	11 24       	eor	r1, r1
    1df8:	8f 93       	push	r24
    1dfa:	9f 93       	push	r25
    1dfc:	af 93       	push	r26
    1dfe:	bf 93       	push	r27
    1e00:	cf 93       	push	r28
    1e02:	df 93       	push	r29
    1e04:	cd b7       	in	r28, 0x3d	; 61
    1e06:	de b7       	in	r29, 0x3e	; 62
    static unsigned char i;
    ++tmr3_ticks;
    1e08:	80 91 e7 04 	lds	r24, 0x04E7	; 0x8004e7 <tmr3_ticks>
    1e0c:	90 91 e8 04 	lds	r25, 0x04E8	; 0x8004e8 <tmr3_ticks+0x1>
    1e10:	a0 91 e9 04 	lds	r26, 0x04E9	; 0x8004e9 <tmr3_ticks+0x2>
    1e14:	b0 91 ea 04 	lds	r27, 0x04EA	; 0x8004ea <tmr3_ticks+0x3>
    1e18:	01 96       	adiw	r24, 0x01	; 1
    1e1a:	a1 1d       	adc	r26, r1
    1e1c:	b1 1d       	adc	r27, r1
    1e1e:	80 93 e7 04 	sts	0x04E7, r24	; 0x8004e7 <tmr3_ticks>
    1e22:	90 93 e8 04 	sts	0x04E8, r25	; 0x8004e8 <tmr3_ticks+0x1>
    1e26:	a0 93 e9 04 	sts	0x04E9, r26	; 0x8004e9 <tmr3_ticks+0x2>
    1e2a:	b0 93 ea 04 	sts	0x04EA, r27	; 0x8004ea <tmr3_ticks+0x3>

    // increment our 1/5th tick counter
    if(++i >= 5) {
    1e2e:	80 91 ef 04 	lds	r24, 0x04EF	; 0x8004ef <i.1551>
    1e32:	8f 5f       	subi	r24, 0xFF	; 255
    1e34:	80 93 ef 04 	sts	0x04EF, r24	; 0x8004ef <i.1551>
    1e38:	80 91 ef 04 	lds	r24, 0x04EF	; 0x8004ef <i.1551>
    1e3c:	85 30       	cpi	r24, 0x05	; 5
    1e3e:	a8 f0       	brcs	.+42     	; 0x1e6a <__vector_32+0x7e>
        i = 0;
    1e40:	10 92 ef 04 	sts	0x04EF, r1	; 0x8004ef <i.1551>
        ++tmr3_fifth_ticks;
    1e44:	80 91 eb 04 	lds	r24, 0x04EB	; 0x8004eb <tmr3_fifth_ticks>
    1e48:	90 91 ec 04 	lds	r25, 0x04EC	; 0x8004ec <tmr3_fifth_ticks+0x1>
    1e4c:	a0 91 ed 04 	lds	r26, 0x04ED	; 0x8004ed <tmr3_fifth_ticks+0x2>
    1e50:	b0 91 ee 04 	lds	r27, 0x04EE	; 0x8004ee <tmr3_fifth_ticks+0x3>
    1e54:	01 96       	adiw	r24, 0x01	; 1
    1e56:	a1 1d       	adc	r26, r1
    1e58:	b1 1d       	adc	r27, r1
    1e5a:	80 93 eb 04 	sts	0x04EB, r24	; 0x8004eb <tmr3_fifth_ticks>
    1e5e:	90 93 ec 04 	sts	0x04EC, r25	; 0x8004ec <tmr3_fifth_ticks+0x1>
    1e62:	a0 93 ed 04 	sts	0x04ED, r26	; 0x8004ed <tmr3_fifth_ticks+0x2>
    1e66:	b0 93 ee 04 	sts	0x04EE, r27	; 0x8004ee <tmr3_fifth_ticks+0x3>
    }

}
    1e6a:	df 91       	pop	r29
    1e6c:	cf 91       	pop	r28
    1e6e:	bf 91       	pop	r27
    1e70:	af 91       	pop	r26
    1e72:	9f 91       	pop	r25
    1e74:	8f 91       	pop	r24
    1e76:	0f 90       	pop	r0
    1e78:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1e7c:	0f 90       	pop	r0
    1e7e:	1f 90       	pop	r1
    1e80:	18 95       	reti

00001e82 <__divmodhi4>:
    1e82:	97 fb       	bst	r25, 7
    1e84:	07 2e       	mov	r0, r23
    1e86:	16 f4       	brtc	.+4      	; 0x1e8c <__divmodhi4+0xa>
    1e88:	00 94       	com	r0
    1e8a:	07 d0       	rcall	.+14     	; 0x1e9a <__divmodhi4_neg1>
    1e8c:	77 fd       	sbrc	r23, 7
    1e8e:	09 d0       	rcall	.+18     	; 0x1ea2 <__divmodhi4_neg2>
    1e90:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <__udivmodhi4>
    1e94:	07 fc       	sbrc	r0, 7
    1e96:	05 d0       	rcall	.+10     	; 0x1ea2 <__divmodhi4_neg2>
    1e98:	3e f4       	brtc	.+14     	; 0x1ea8 <__divmodhi4_exit>

00001e9a <__divmodhi4_neg1>:
    1e9a:	90 95       	com	r25
    1e9c:	81 95       	neg	r24
    1e9e:	9f 4f       	sbci	r25, 0xFF	; 255
    1ea0:	08 95       	ret

00001ea2 <__divmodhi4_neg2>:
    1ea2:	70 95       	com	r23
    1ea4:	61 95       	neg	r22
    1ea6:	7f 4f       	sbci	r23, 0xFF	; 255

00001ea8 <__divmodhi4_exit>:
    1ea8:	08 95       	ret

00001eaa <__tablejump2__>:
    1eaa:	ee 0f       	add	r30, r30
    1eac:	ff 1f       	adc	r31, r31
    1eae:	05 90       	lpm	r0, Z+
    1eb0:	f4 91       	lpm	r31, Z
    1eb2:	e0 2d       	mov	r30, r0
    1eb4:	09 94       	ijmp

00001eb6 <__udivmodhi4>:
    1eb6:	aa 1b       	sub	r26, r26
    1eb8:	bb 1b       	sub	r27, r27
    1eba:	51 e1       	ldi	r21, 0x11	; 17
    1ebc:	07 c0       	rjmp	.+14     	; 0x1ecc <__udivmodhi4_ep>

00001ebe <__udivmodhi4_loop>:
    1ebe:	aa 1f       	adc	r26, r26
    1ec0:	bb 1f       	adc	r27, r27
    1ec2:	a6 17       	cp	r26, r22
    1ec4:	b7 07       	cpc	r27, r23
    1ec6:	10 f0       	brcs	.+4      	; 0x1ecc <__udivmodhi4_ep>
    1ec8:	a6 1b       	sub	r26, r22
    1eca:	b7 0b       	sbc	r27, r23

00001ecc <__udivmodhi4_ep>:
    1ecc:	88 1f       	adc	r24, r24
    1ece:	99 1f       	adc	r25, r25
    1ed0:	5a 95       	dec	r21
    1ed2:	a9 f7       	brne	.-22     	; 0x1ebe <__udivmodhi4_loop>
    1ed4:	80 95       	com	r24
    1ed6:	90 95       	com	r25
    1ed8:	bc 01       	movw	r22, r24
    1eda:	cd 01       	movw	r24, r26
    1edc:	08 95       	ret

00001ede <do_rand>:
    1ede:	8f 92       	push	r8
    1ee0:	9f 92       	push	r9
    1ee2:	af 92       	push	r10
    1ee4:	bf 92       	push	r11
    1ee6:	cf 92       	push	r12
    1ee8:	df 92       	push	r13
    1eea:	ef 92       	push	r14
    1eec:	ff 92       	push	r15
    1eee:	cf 93       	push	r28
    1ef0:	df 93       	push	r29
    1ef2:	ec 01       	movw	r28, r24
    1ef4:	68 81       	ld	r22, Y
    1ef6:	79 81       	ldd	r23, Y+1	; 0x01
    1ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    1efa:	9b 81       	ldd	r25, Y+3	; 0x03
    1efc:	61 15       	cp	r22, r1
    1efe:	71 05       	cpc	r23, r1
    1f00:	81 05       	cpc	r24, r1
    1f02:	91 05       	cpc	r25, r1
    1f04:	21 f4       	brne	.+8      	; 0x1f0e <do_rand+0x30>
    1f06:	64 e2       	ldi	r22, 0x24	; 36
    1f08:	79 ed       	ldi	r23, 0xD9	; 217
    1f0a:	8b e5       	ldi	r24, 0x5B	; 91
    1f0c:	97 e0       	ldi	r25, 0x07	; 7
    1f0e:	2d e1       	ldi	r18, 0x1D	; 29
    1f10:	33 ef       	ldi	r19, 0xF3	; 243
    1f12:	41 e0       	ldi	r20, 0x01	; 1
    1f14:	50 e0       	ldi	r21, 0x00	; 0
    1f16:	0e 94 8f 12 	call	0x251e	; 0x251e <__divmodsi4>
    1f1a:	49 01       	movw	r8, r18
    1f1c:	5a 01       	movw	r10, r20
    1f1e:	9b 01       	movw	r18, r22
    1f20:	ac 01       	movw	r20, r24
    1f22:	a7 ea       	ldi	r26, 0xA7	; 167
    1f24:	b1 e4       	ldi	r27, 0x41	; 65
    1f26:	0e 94 ae 12 	call	0x255c	; 0x255c <__muluhisi3>
    1f2a:	6b 01       	movw	r12, r22
    1f2c:	7c 01       	movw	r14, r24
    1f2e:	ac ee       	ldi	r26, 0xEC	; 236
    1f30:	b4 ef       	ldi	r27, 0xF4	; 244
    1f32:	a5 01       	movw	r20, r10
    1f34:	94 01       	movw	r18, r8
    1f36:	0e 94 bc 12 	call	0x2578	; 0x2578 <__mulohisi3>
    1f3a:	dc 01       	movw	r26, r24
    1f3c:	cb 01       	movw	r24, r22
    1f3e:	8c 0d       	add	r24, r12
    1f40:	9d 1d       	adc	r25, r13
    1f42:	ae 1d       	adc	r26, r14
    1f44:	bf 1d       	adc	r27, r15
    1f46:	b7 ff       	sbrs	r27, 7
    1f48:	03 c0       	rjmp	.+6      	; 0x1f50 <do_rand+0x72>
    1f4a:	01 97       	sbiw	r24, 0x01	; 1
    1f4c:	a1 09       	sbc	r26, r1
    1f4e:	b0 48       	sbci	r27, 0x80	; 128
    1f50:	88 83       	st	Y, r24
    1f52:	99 83       	std	Y+1, r25	; 0x01
    1f54:	aa 83       	std	Y+2, r26	; 0x02
    1f56:	bb 83       	std	Y+3, r27	; 0x03
    1f58:	9f 77       	andi	r25, 0x7F	; 127
    1f5a:	df 91       	pop	r29
    1f5c:	cf 91       	pop	r28
    1f5e:	ff 90       	pop	r15
    1f60:	ef 90       	pop	r14
    1f62:	df 90       	pop	r13
    1f64:	cf 90       	pop	r12
    1f66:	bf 90       	pop	r11
    1f68:	af 90       	pop	r10
    1f6a:	9f 90       	pop	r9
    1f6c:	8f 90       	pop	r8
    1f6e:	08 95       	ret

00001f70 <rand_r>:
    1f70:	0e 94 6f 0f 	call	0x1ede	; 0x1ede <do_rand>
    1f74:	08 95       	ret

00001f76 <rand>:
    1f76:	89 e0       	ldi	r24, 0x09	; 9
    1f78:	91 e0       	ldi	r25, 0x01	; 1
    1f7a:	0e 94 6f 0f 	call	0x1ede	; 0x1ede <do_rand>
    1f7e:	08 95       	ret

00001f80 <srand>:
    1f80:	a0 e0       	ldi	r26, 0x00	; 0
    1f82:	b0 e0       	ldi	r27, 0x00	; 0
    1f84:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <next>
    1f88:	90 93 0a 01 	sts	0x010A, r25	; 0x80010a <next+0x1>
    1f8c:	a0 93 0b 01 	sts	0x010B, r26	; 0x80010b <next+0x2>
    1f90:	b0 93 0c 01 	sts	0x010C, r27	; 0x80010c <next+0x3>
    1f94:	08 95       	ret

00001f96 <printf>:
    1f96:	a0 e0       	ldi	r26, 0x00	; 0
    1f98:	b0 e0       	ldi	r27, 0x00	; 0
    1f9a:	e1 ed       	ldi	r30, 0xD1	; 209
    1f9c:	ff e0       	ldi	r31, 0x0F	; 15
    1f9e:	0c 94 d1 12 	jmp	0x25a2	; 0x25a2 <__prologue_saves__+0x20>
    1fa2:	ae 01       	movw	r20, r28
    1fa4:	4b 5f       	subi	r20, 0xFB	; 251
    1fa6:	5f 4f       	sbci	r21, 0xFF	; 255
    1fa8:	fa 01       	movw	r30, r20
    1faa:	61 91       	ld	r22, Z+
    1fac:	71 91       	ld	r23, Z+
    1fae:	af 01       	movw	r20, r30
    1fb0:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <__iob+0x2>
    1fb4:	90 91 03 05 	lds	r25, 0x0503	; 0x800503 <__iob+0x3>
    1fb8:	0e 94 11 10 	call	0x2022	; 0x2022 <vfprintf>
    1fbc:	e2 e0       	ldi	r30, 0x02	; 2
    1fbe:	0c 94 ed 12 	jmp	0x25da	; 0x25da <__epilogue_restores__+0x20>

00001fc2 <puts>:
    1fc2:	0f 93       	push	r16
    1fc4:	1f 93       	push	r17
    1fc6:	cf 93       	push	r28
    1fc8:	df 93       	push	r29
    1fca:	e0 91 02 05 	lds	r30, 0x0502	; 0x800502 <__iob+0x2>
    1fce:	f0 91 03 05 	lds	r31, 0x0503	; 0x800503 <__iob+0x3>
    1fd2:	23 81       	ldd	r18, Z+3	; 0x03
    1fd4:	21 ff       	sbrs	r18, 1
    1fd6:	1b c0       	rjmp	.+54     	; 0x200e <puts+0x4c>
    1fd8:	8c 01       	movw	r16, r24
    1fda:	d0 e0       	ldi	r29, 0x00	; 0
    1fdc:	c0 e0       	ldi	r28, 0x00	; 0
    1fde:	f8 01       	movw	r30, r16
    1fe0:	81 91       	ld	r24, Z+
    1fe2:	8f 01       	movw	r16, r30
    1fe4:	60 91 02 05 	lds	r22, 0x0502	; 0x800502 <__iob+0x2>
    1fe8:	70 91 03 05 	lds	r23, 0x0503	; 0x800503 <__iob+0x3>
    1fec:	db 01       	movw	r26, r22
    1fee:	18 96       	adiw	r26, 0x08	; 8
    1ff0:	ed 91       	ld	r30, X+
    1ff2:	fc 91       	ld	r31, X
    1ff4:	19 97       	sbiw	r26, 0x09	; 9
    1ff6:	88 23       	and	r24, r24
    1ff8:	31 f0       	breq	.+12     	; 0x2006 <puts+0x44>
    1ffa:	09 95       	icall
    1ffc:	89 2b       	or	r24, r25
    1ffe:	79 f3       	breq	.-34     	; 0x1fde <puts+0x1c>
    2000:	df ef       	ldi	r29, 0xFF	; 255
    2002:	cf ef       	ldi	r28, 0xFF	; 255
    2004:	ec cf       	rjmp	.-40     	; 0x1fde <puts+0x1c>
    2006:	8a e0       	ldi	r24, 0x0A	; 10
    2008:	09 95       	icall
    200a:	89 2b       	or	r24, r25
    200c:	19 f0       	breq	.+6      	; 0x2014 <puts+0x52>
    200e:	8f ef       	ldi	r24, 0xFF	; 255
    2010:	9f ef       	ldi	r25, 0xFF	; 255
    2012:	02 c0       	rjmp	.+4      	; 0x2018 <puts+0x56>
    2014:	8d 2f       	mov	r24, r29
    2016:	9c 2f       	mov	r25, r28
    2018:	df 91       	pop	r29
    201a:	cf 91       	pop	r28
    201c:	1f 91       	pop	r17
    201e:	0f 91       	pop	r16
    2020:	08 95       	ret

00002022 <vfprintf>:
    2022:	ac e0       	ldi	r26, 0x0C	; 12
    2024:	b0 e0       	ldi	r27, 0x00	; 0
    2026:	e7 e1       	ldi	r30, 0x17	; 23
    2028:	f0 e1       	ldi	r31, 0x10	; 16
    202a:	0c 94 c1 12 	jmp	0x2582	; 0x2582 <__prologue_saves__>
    202e:	7c 01       	movw	r14, r24
    2030:	6b 01       	movw	r12, r22
    2032:	8a 01       	movw	r16, r20
    2034:	fc 01       	movw	r30, r24
    2036:	17 82       	std	Z+7, r1	; 0x07
    2038:	16 82       	std	Z+6, r1	; 0x06
    203a:	83 81       	ldd	r24, Z+3	; 0x03
    203c:	81 ff       	sbrs	r24, 1
    203e:	bd c1       	rjmp	.+890    	; 0x23ba <vfprintf+0x398>
    2040:	ce 01       	movw	r24, r28
    2042:	01 96       	adiw	r24, 0x01	; 1
    2044:	4c 01       	movw	r8, r24
    2046:	f7 01       	movw	r30, r14
    2048:	93 81       	ldd	r25, Z+3	; 0x03
    204a:	f6 01       	movw	r30, r12
    204c:	93 fd       	sbrc	r25, 3
    204e:	85 91       	lpm	r24, Z+
    2050:	93 ff       	sbrs	r25, 3
    2052:	81 91       	ld	r24, Z+
    2054:	6f 01       	movw	r12, r30
    2056:	88 23       	and	r24, r24
    2058:	09 f4       	brne	.+2      	; 0x205c <vfprintf+0x3a>
    205a:	ab c1       	rjmp	.+854    	; 0x23b2 <vfprintf+0x390>
    205c:	85 32       	cpi	r24, 0x25	; 37
    205e:	39 f4       	brne	.+14     	; 0x206e <vfprintf+0x4c>
    2060:	93 fd       	sbrc	r25, 3
    2062:	85 91       	lpm	r24, Z+
    2064:	93 ff       	sbrs	r25, 3
    2066:	81 91       	ld	r24, Z+
    2068:	6f 01       	movw	r12, r30
    206a:	85 32       	cpi	r24, 0x25	; 37
    206c:	29 f4       	brne	.+10     	; 0x2078 <vfprintf+0x56>
    206e:	b7 01       	movw	r22, r14
    2070:	90 e0       	ldi	r25, 0x00	; 0
    2072:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <fputc>
    2076:	e7 cf       	rjmp	.-50     	; 0x2046 <vfprintf+0x24>
    2078:	51 2c       	mov	r5, r1
    207a:	31 2c       	mov	r3, r1
    207c:	20 e0       	ldi	r18, 0x00	; 0
    207e:	20 32       	cpi	r18, 0x20	; 32
    2080:	a0 f4       	brcc	.+40     	; 0x20aa <vfprintf+0x88>
    2082:	8b 32       	cpi	r24, 0x2B	; 43
    2084:	69 f0       	breq	.+26     	; 0x20a0 <vfprintf+0x7e>
    2086:	30 f4       	brcc	.+12     	; 0x2094 <vfprintf+0x72>
    2088:	80 32       	cpi	r24, 0x20	; 32
    208a:	59 f0       	breq	.+22     	; 0x20a2 <vfprintf+0x80>
    208c:	83 32       	cpi	r24, 0x23	; 35
    208e:	69 f4       	brne	.+26     	; 0x20aa <vfprintf+0x88>
    2090:	20 61       	ori	r18, 0x10	; 16
    2092:	2c c0       	rjmp	.+88     	; 0x20ec <vfprintf+0xca>
    2094:	8d 32       	cpi	r24, 0x2D	; 45
    2096:	39 f0       	breq	.+14     	; 0x20a6 <vfprintf+0x84>
    2098:	80 33       	cpi	r24, 0x30	; 48
    209a:	39 f4       	brne	.+14     	; 0x20aa <vfprintf+0x88>
    209c:	21 60       	ori	r18, 0x01	; 1
    209e:	26 c0       	rjmp	.+76     	; 0x20ec <vfprintf+0xca>
    20a0:	22 60       	ori	r18, 0x02	; 2
    20a2:	24 60       	ori	r18, 0x04	; 4
    20a4:	23 c0       	rjmp	.+70     	; 0x20ec <vfprintf+0xca>
    20a6:	28 60       	ori	r18, 0x08	; 8
    20a8:	21 c0       	rjmp	.+66     	; 0x20ec <vfprintf+0xca>
    20aa:	27 fd       	sbrc	r18, 7
    20ac:	27 c0       	rjmp	.+78     	; 0x20fc <vfprintf+0xda>
    20ae:	30 ed       	ldi	r19, 0xD0	; 208
    20b0:	38 0f       	add	r19, r24
    20b2:	3a 30       	cpi	r19, 0x0A	; 10
    20b4:	78 f4       	brcc	.+30     	; 0x20d4 <vfprintf+0xb2>
    20b6:	26 ff       	sbrs	r18, 6
    20b8:	06 c0       	rjmp	.+12     	; 0x20c6 <vfprintf+0xa4>
    20ba:	fa e0       	ldi	r31, 0x0A	; 10
    20bc:	5f 9e       	mul	r5, r31
    20be:	30 0d       	add	r19, r0
    20c0:	11 24       	eor	r1, r1
    20c2:	53 2e       	mov	r5, r19
    20c4:	13 c0       	rjmp	.+38     	; 0x20ec <vfprintf+0xca>
    20c6:	8a e0       	ldi	r24, 0x0A	; 10
    20c8:	38 9e       	mul	r3, r24
    20ca:	30 0d       	add	r19, r0
    20cc:	11 24       	eor	r1, r1
    20ce:	33 2e       	mov	r3, r19
    20d0:	20 62       	ori	r18, 0x20	; 32
    20d2:	0c c0       	rjmp	.+24     	; 0x20ec <vfprintf+0xca>
    20d4:	8e 32       	cpi	r24, 0x2E	; 46
    20d6:	21 f4       	brne	.+8      	; 0x20e0 <vfprintf+0xbe>
    20d8:	26 fd       	sbrc	r18, 6
    20da:	6b c1       	rjmp	.+726    	; 0x23b2 <vfprintf+0x390>
    20dc:	20 64       	ori	r18, 0x40	; 64
    20de:	06 c0       	rjmp	.+12     	; 0x20ec <vfprintf+0xca>
    20e0:	8c 36       	cpi	r24, 0x6C	; 108
    20e2:	11 f4       	brne	.+4      	; 0x20e8 <vfprintf+0xc6>
    20e4:	20 68       	ori	r18, 0x80	; 128
    20e6:	02 c0       	rjmp	.+4      	; 0x20ec <vfprintf+0xca>
    20e8:	88 36       	cpi	r24, 0x68	; 104
    20ea:	41 f4       	brne	.+16     	; 0x20fc <vfprintf+0xda>
    20ec:	f6 01       	movw	r30, r12
    20ee:	93 fd       	sbrc	r25, 3
    20f0:	85 91       	lpm	r24, Z+
    20f2:	93 ff       	sbrs	r25, 3
    20f4:	81 91       	ld	r24, Z+
    20f6:	6f 01       	movw	r12, r30
    20f8:	81 11       	cpse	r24, r1
    20fa:	c1 cf       	rjmp	.-126    	; 0x207e <vfprintf+0x5c>
    20fc:	98 2f       	mov	r25, r24
    20fe:	9f 7d       	andi	r25, 0xDF	; 223
    2100:	95 54       	subi	r25, 0x45	; 69
    2102:	93 30       	cpi	r25, 0x03	; 3
    2104:	28 f4       	brcc	.+10     	; 0x2110 <vfprintf+0xee>
    2106:	0c 5f       	subi	r16, 0xFC	; 252
    2108:	1f 4f       	sbci	r17, 0xFF	; 255
    210a:	ff e3       	ldi	r31, 0x3F	; 63
    210c:	f9 83       	std	Y+1, r31	; 0x01
    210e:	0d c0       	rjmp	.+26     	; 0x212a <vfprintf+0x108>
    2110:	83 36       	cpi	r24, 0x63	; 99
    2112:	31 f0       	breq	.+12     	; 0x2120 <vfprintf+0xfe>
    2114:	83 37       	cpi	r24, 0x73	; 115
    2116:	71 f0       	breq	.+28     	; 0x2134 <vfprintf+0x112>
    2118:	83 35       	cpi	r24, 0x53	; 83
    211a:	09 f0       	breq	.+2      	; 0x211e <vfprintf+0xfc>
    211c:	5b c0       	rjmp	.+182    	; 0x21d4 <vfprintf+0x1b2>
    211e:	22 c0       	rjmp	.+68     	; 0x2164 <vfprintf+0x142>
    2120:	f8 01       	movw	r30, r16
    2122:	80 81       	ld	r24, Z
    2124:	89 83       	std	Y+1, r24	; 0x01
    2126:	0e 5f       	subi	r16, 0xFE	; 254
    2128:	1f 4f       	sbci	r17, 0xFF	; 255
    212a:	44 24       	eor	r4, r4
    212c:	43 94       	inc	r4
    212e:	51 2c       	mov	r5, r1
    2130:	54 01       	movw	r10, r8
    2132:	15 c0       	rjmp	.+42     	; 0x215e <vfprintf+0x13c>
    2134:	38 01       	movw	r6, r16
    2136:	f2 e0       	ldi	r31, 0x02	; 2
    2138:	6f 0e       	add	r6, r31
    213a:	71 1c       	adc	r7, r1
    213c:	f8 01       	movw	r30, r16
    213e:	a0 80       	ld	r10, Z
    2140:	b1 80       	ldd	r11, Z+1	; 0x01
    2142:	26 ff       	sbrs	r18, 6
    2144:	03 c0       	rjmp	.+6      	; 0x214c <vfprintf+0x12a>
    2146:	65 2d       	mov	r22, r5
    2148:	70 e0       	ldi	r23, 0x00	; 0
    214a:	02 c0       	rjmp	.+4      	; 0x2150 <vfprintf+0x12e>
    214c:	6f ef       	ldi	r22, 0xFF	; 255
    214e:	7f ef       	ldi	r23, 0xFF	; 255
    2150:	c5 01       	movw	r24, r10
    2152:	2c 87       	std	Y+12, r18	; 0x0c
    2154:	0e 94 ee 11 	call	0x23dc	; 0x23dc <strnlen>
    2158:	2c 01       	movw	r4, r24
    215a:	83 01       	movw	r16, r6
    215c:	2c 85       	ldd	r18, Y+12	; 0x0c
    215e:	2f 77       	andi	r18, 0x7F	; 127
    2160:	22 2e       	mov	r2, r18
    2162:	17 c0       	rjmp	.+46     	; 0x2192 <vfprintf+0x170>
    2164:	38 01       	movw	r6, r16
    2166:	f2 e0       	ldi	r31, 0x02	; 2
    2168:	6f 0e       	add	r6, r31
    216a:	71 1c       	adc	r7, r1
    216c:	f8 01       	movw	r30, r16
    216e:	a0 80       	ld	r10, Z
    2170:	b1 80       	ldd	r11, Z+1	; 0x01
    2172:	26 ff       	sbrs	r18, 6
    2174:	03 c0       	rjmp	.+6      	; 0x217c <vfprintf+0x15a>
    2176:	65 2d       	mov	r22, r5
    2178:	70 e0       	ldi	r23, 0x00	; 0
    217a:	02 c0       	rjmp	.+4      	; 0x2180 <vfprintf+0x15e>
    217c:	6f ef       	ldi	r22, 0xFF	; 255
    217e:	7f ef       	ldi	r23, 0xFF	; 255
    2180:	c5 01       	movw	r24, r10
    2182:	2c 87       	std	Y+12, r18	; 0x0c
    2184:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <strnlen_P>
    2188:	2c 01       	movw	r4, r24
    218a:	2c 85       	ldd	r18, Y+12	; 0x0c
    218c:	20 68       	ori	r18, 0x80	; 128
    218e:	22 2e       	mov	r2, r18
    2190:	83 01       	movw	r16, r6
    2192:	23 fc       	sbrc	r2, 3
    2194:	1b c0       	rjmp	.+54     	; 0x21cc <vfprintf+0x1aa>
    2196:	83 2d       	mov	r24, r3
    2198:	90 e0       	ldi	r25, 0x00	; 0
    219a:	48 16       	cp	r4, r24
    219c:	59 06       	cpc	r5, r25
    219e:	b0 f4       	brcc	.+44     	; 0x21cc <vfprintf+0x1aa>
    21a0:	b7 01       	movw	r22, r14
    21a2:	80 e2       	ldi	r24, 0x20	; 32
    21a4:	90 e0       	ldi	r25, 0x00	; 0
    21a6:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <fputc>
    21aa:	3a 94       	dec	r3
    21ac:	f4 cf       	rjmp	.-24     	; 0x2196 <vfprintf+0x174>
    21ae:	f5 01       	movw	r30, r10
    21b0:	27 fc       	sbrc	r2, 7
    21b2:	85 91       	lpm	r24, Z+
    21b4:	27 fe       	sbrs	r2, 7
    21b6:	81 91       	ld	r24, Z+
    21b8:	5f 01       	movw	r10, r30
    21ba:	b7 01       	movw	r22, r14
    21bc:	90 e0       	ldi	r25, 0x00	; 0
    21be:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <fputc>
    21c2:	31 10       	cpse	r3, r1
    21c4:	3a 94       	dec	r3
    21c6:	f1 e0       	ldi	r31, 0x01	; 1
    21c8:	4f 1a       	sub	r4, r31
    21ca:	51 08       	sbc	r5, r1
    21cc:	41 14       	cp	r4, r1
    21ce:	51 04       	cpc	r5, r1
    21d0:	71 f7       	brne	.-36     	; 0x21ae <vfprintf+0x18c>
    21d2:	e5 c0       	rjmp	.+458    	; 0x239e <vfprintf+0x37c>
    21d4:	84 36       	cpi	r24, 0x64	; 100
    21d6:	11 f0       	breq	.+4      	; 0x21dc <vfprintf+0x1ba>
    21d8:	89 36       	cpi	r24, 0x69	; 105
    21da:	39 f5       	brne	.+78     	; 0x222a <vfprintf+0x208>
    21dc:	f8 01       	movw	r30, r16
    21de:	27 ff       	sbrs	r18, 7
    21e0:	07 c0       	rjmp	.+14     	; 0x21f0 <vfprintf+0x1ce>
    21e2:	60 81       	ld	r22, Z
    21e4:	71 81       	ldd	r23, Z+1	; 0x01
    21e6:	82 81       	ldd	r24, Z+2	; 0x02
    21e8:	93 81       	ldd	r25, Z+3	; 0x03
    21ea:	0c 5f       	subi	r16, 0xFC	; 252
    21ec:	1f 4f       	sbci	r17, 0xFF	; 255
    21ee:	08 c0       	rjmp	.+16     	; 0x2200 <vfprintf+0x1de>
    21f0:	60 81       	ld	r22, Z
    21f2:	71 81       	ldd	r23, Z+1	; 0x01
    21f4:	07 2e       	mov	r0, r23
    21f6:	00 0c       	add	r0, r0
    21f8:	88 0b       	sbc	r24, r24
    21fa:	99 0b       	sbc	r25, r25
    21fc:	0e 5f       	subi	r16, 0xFE	; 254
    21fe:	1f 4f       	sbci	r17, 0xFF	; 255
    2200:	2f 76       	andi	r18, 0x6F	; 111
    2202:	72 2e       	mov	r7, r18
    2204:	97 ff       	sbrs	r25, 7
    2206:	09 c0       	rjmp	.+18     	; 0x221a <vfprintf+0x1f8>
    2208:	90 95       	com	r25
    220a:	80 95       	com	r24
    220c:	70 95       	com	r23
    220e:	61 95       	neg	r22
    2210:	7f 4f       	sbci	r23, 0xFF	; 255
    2212:	8f 4f       	sbci	r24, 0xFF	; 255
    2214:	9f 4f       	sbci	r25, 0xFF	; 255
    2216:	20 68       	ori	r18, 0x80	; 128
    2218:	72 2e       	mov	r7, r18
    221a:	2a e0       	ldi	r18, 0x0A	; 10
    221c:	30 e0       	ldi	r19, 0x00	; 0
    221e:	a4 01       	movw	r20, r8
    2220:	0e 94 31 12 	call	0x2462	; 0x2462 <__ultoa_invert>
    2224:	a8 2e       	mov	r10, r24
    2226:	a8 18       	sub	r10, r8
    2228:	44 c0       	rjmp	.+136    	; 0x22b2 <vfprintf+0x290>
    222a:	85 37       	cpi	r24, 0x75	; 117
    222c:	29 f4       	brne	.+10     	; 0x2238 <vfprintf+0x216>
    222e:	2f 7e       	andi	r18, 0xEF	; 239
    2230:	b2 2e       	mov	r11, r18
    2232:	2a e0       	ldi	r18, 0x0A	; 10
    2234:	30 e0       	ldi	r19, 0x00	; 0
    2236:	25 c0       	rjmp	.+74     	; 0x2282 <vfprintf+0x260>
    2238:	f2 2f       	mov	r31, r18
    223a:	f9 7f       	andi	r31, 0xF9	; 249
    223c:	bf 2e       	mov	r11, r31
    223e:	8f 36       	cpi	r24, 0x6F	; 111
    2240:	c1 f0       	breq	.+48     	; 0x2272 <vfprintf+0x250>
    2242:	18 f4       	brcc	.+6      	; 0x224a <vfprintf+0x228>
    2244:	88 35       	cpi	r24, 0x58	; 88
    2246:	79 f0       	breq	.+30     	; 0x2266 <vfprintf+0x244>
    2248:	b4 c0       	rjmp	.+360    	; 0x23b2 <vfprintf+0x390>
    224a:	80 37       	cpi	r24, 0x70	; 112
    224c:	19 f0       	breq	.+6      	; 0x2254 <vfprintf+0x232>
    224e:	88 37       	cpi	r24, 0x78	; 120
    2250:	21 f0       	breq	.+8      	; 0x225a <vfprintf+0x238>
    2252:	af c0       	rjmp	.+350    	; 0x23b2 <vfprintf+0x390>
    2254:	2f 2f       	mov	r18, r31
    2256:	20 61       	ori	r18, 0x10	; 16
    2258:	b2 2e       	mov	r11, r18
    225a:	b4 fe       	sbrs	r11, 4
    225c:	0d c0       	rjmp	.+26     	; 0x2278 <vfprintf+0x256>
    225e:	8b 2d       	mov	r24, r11
    2260:	84 60       	ori	r24, 0x04	; 4
    2262:	b8 2e       	mov	r11, r24
    2264:	09 c0       	rjmp	.+18     	; 0x2278 <vfprintf+0x256>
    2266:	24 ff       	sbrs	r18, 4
    2268:	0a c0       	rjmp	.+20     	; 0x227e <vfprintf+0x25c>
    226a:	9f 2f       	mov	r25, r31
    226c:	96 60       	ori	r25, 0x06	; 6
    226e:	b9 2e       	mov	r11, r25
    2270:	06 c0       	rjmp	.+12     	; 0x227e <vfprintf+0x25c>
    2272:	28 e0       	ldi	r18, 0x08	; 8
    2274:	30 e0       	ldi	r19, 0x00	; 0
    2276:	05 c0       	rjmp	.+10     	; 0x2282 <vfprintf+0x260>
    2278:	20 e1       	ldi	r18, 0x10	; 16
    227a:	30 e0       	ldi	r19, 0x00	; 0
    227c:	02 c0       	rjmp	.+4      	; 0x2282 <vfprintf+0x260>
    227e:	20 e1       	ldi	r18, 0x10	; 16
    2280:	32 e0       	ldi	r19, 0x02	; 2
    2282:	f8 01       	movw	r30, r16
    2284:	b7 fe       	sbrs	r11, 7
    2286:	07 c0       	rjmp	.+14     	; 0x2296 <vfprintf+0x274>
    2288:	60 81       	ld	r22, Z
    228a:	71 81       	ldd	r23, Z+1	; 0x01
    228c:	82 81       	ldd	r24, Z+2	; 0x02
    228e:	93 81       	ldd	r25, Z+3	; 0x03
    2290:	0c 5f       	subi	r16, 0xFC	; 252
    2292:	1f 4f       	sbci	r17, 0xFF	; 255
    2294:	06 c0       	rjmp	.+12     	; 0x22a2 <vfprintf+0x280>
    2296:	60 81       	ld	r22, Z
    2298:	71 81       	ldd	r23, Z+1	; 0x01
    229a:	80 e0       	ldi	r24, 0x00	; 0
    229c:	90 e0       	ldi	r25, 0x00	; 0
    229e:	0e 5f       	subi	r16, 0xFE	; 254
    22a0:	1f 4f       	sbci	r17, 0xFF	; 255
    22a2:	a4 01       	movw	r20, r8
    22a4:	0e 94 31 12 	call	0x2462	; 0x2462 <__ultoa_invert>
    22a8:	a8 2e       	mov	r10, r24
    22aa:	a8 18       	sub	r10, r8
    22ac:	fb 2d       	mov	r31, r11
    22ae:	ff 77       	andi	r31, 0x7F	; 127
    22b0:	7f 2e       	mov	r7, r31
    22b2:	76 fe       	sbrs	r7, 6
    22b4:	0b c0       	rjmp	.+22     	; 0x22cc <vfprintf+0x2aa>
    22b6:	37 2d       	mov	r19, r7
    22b8:	3e 7f       	andi	r19, 0xFE	; 254
    22ba:	a5 14       	cp	r10, r5
    22bc:	50 f4       	brcc	.+20     	; 0x22d2 <vfprintf+0x2b0>
    22be:	74 fe       	sbrs	r7, 4
    22c0:	0a c0       	rjmp	.+20     	; 0x22d6 <vfprintf+0x2b4>
    22c2:	72 fc       	sbrc	r7, 2
    22c4:	08 c0       	rjmp	.+16     	; 0x22d6 <vfprintf+0x2b4>
    22c6:	37 2d       	mov	r19, r7
    22c8:	3e 7e       	andi	r19, 0xEE	; 238
    22ca:	05 c0       	rjmp	.+10     	; 0x22d6 <vfprintf+0x2b4>
    22cc:	ba 2c       	mov	r11, r10
    22ce:	37 2d       	mov	r19, r7
    22d0:	03 c0       	rjmp	.+6      	; 0x22d8 <vfprintf+0x2b6>
    22d2:	ba 2c       	mov	r11, r10
    22d4:	01 c0       	rjmp	.+2      	; 0x22d8 <vfprintf+0x2b6>
    22d6:	b5 2c       	mov	r11, r5
    22d8:	34 ff       	sbrs	r19, 4
    22da:	0d c0       	rjmp	.+26     	; 0x22f6 <vfprintf+0x2d4>
    22dc:	fe 01       	movw	r30, r28
    22de:	ea 0d       	add	r30, r10
    22e0:	f1 1d       	adc	r31, r1
    22e2:	80 81       	ld	r24, Z
    22e4:	80 33       	cpi	r24, 0x30	; 48
    22e6:	11 f4       	brne	.+4      	; 0x22ec <vfprintf+0x2ca>
    22e8:	39 7e       	andi	r19, 0xE9	; 233
    22ea:	09 c0       	rjmp	.+18     	; 0x22fe <vfprintf+0x2dc>
    22ec:	32 ff       	sbrs	r19, 2
    22ee:	06 c0       	rjmp	.+12     	; 0x22fc <vfprintf+0x2da>
    22f0:	b3 94       	inc	r11
    22f2:	b3 94       	inc	r11
    22f4:	04 c0       	rjmp	.+8      	; 0x22fe <vfprintf+0x2dc>
    22f6:	83 2f       	mov	r24, r19
    22f8:	86 78       	andi	r24, 0x86	; 134
    22fa:	09 f0       	breq	.+2      	; 0x22fe <vfprintf+0x2dc>
    22fc:	b3 94       	inc	r11
    22fe:	33 fd       	sbrc	r19, 3
    2300:	13 c0       	rjmp	.+38     	; 0x2328 <vfprintf+0x306>
    2302:	30 ff       	sbrs	r19, 0
    2304:	06 c0       	rjmp	.+12     	; 0x2312 <vfprintf+0x2f0>
    2306:	5a 2c       	mov	r5, r10
    2308:	b3 14       	cp	r11, r3
    230a:	18 f4       	brcc	.+6      	; 0x2312 <vfprintf+0x2f0>
    230c:	53 0c       	add	r5, r3
    230e:	5b 18       	sub	r5, r11
    2310:	b3 2c       	mov	r11, r3
    2312:	b3 14       	cp	r11, r3
    2314:	68 f4       	brcc	.+26     	; 0x2330 <vfprintf+0x30e>
    2316:	b7 01       	movw	r22, r14
    2318:	80 e2       	ldi	r24, 0x20	; 32
    231a:	90 e0       	ldi	r25, 0x00	; 0
    231c:	3c 87       	std	Y+12, r19	; 0x0c
    231e:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <fputc>
    2322:	b3 94       	inc	r11
    2324:	3c 85       	ldd	r19, Y+12	; 0x0c
    2326:	f5 cf       	rjmp	.-22     	; 0x2312 <vfprintf+0x2f0>
    2328:	b3 14       	cp	r11, r3
    232a:	10 f4       	brcc	.+4      	; 0x2330 <vfprintf+0x30e>
    232c:	3b 18       	sub	r3, r11
    232e:	01 c0       	rjmp	.+2      	; 0x2332 <vfprintf+0x310>
    2330:	31 2c       	mov	r3, r1
    2332:	34 ff       	sbrs	r19, 4
    2334:	12 c0       	rjmp	.+36     	; 0x235a <vfprintf+0x338>
    2336:	b7 01       	movw	r22, r14
    2338:	80 e3       	ldi	r24, 0x30	; 48
    233a:	90 e0       	ldi	r25, 0x00	; 0
    233c:	3c 87       	std	Y+12, r19	; 0x0c
    233e:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <fputc>
    2342:	3c 85       	ldd	r19, Y+12	; 0x0c
    2344:	32 ff       	sbrs	r19, 2
    2346:	17 c0       	rjmp	.+46     	; 0x2376 <vfprintf+0x354>
    2348:	31 fd       	sbrc	r19, 1
    234a:	03 c0       	rjmp	.+6      	; 0x2352 <vfprintf+0x330>
    234c:	88 e7       	ldi	r24, 0x78	; 120
    234e:	90 e0       	ldi	r25, 0x00	; 0
    2350:	02 c0       	rjmp	.+4      	; 0x2356 <vfprintf+0x334>
    2352:	88 e5       	ldi	r24, 0x58	; 88
    2354:	90 e0       	ldi	r25, 0x00	; 0
    2356:	b7 01       	movw	r22, r14
    2358:	0c c0       	rjmp	.+24     	; 0x2372 <vfprintf+0x350>
    235a:	83 2f       	mov	r24, r19
    235c:	86 78       	andi	r24, 0x86	; 134
    235e:	59 f0       	breq	.+22     	; 0x2376 <vfprintf+0x354>
    2360:	31 ff       	sbrs	r19, 1
    2362:	02 c0       	rjmp	.+4      	; 0x2368 <vfprintf+0x346>
    2364:	8b e2       	ldi	r24, 0x2B	; 43
    2366:	01 c0       	rjmp	.+2      	; 0x236a <vfprintf+0x348>
    2368:	80 e2       	ldi	r24, 0x20	; 32
    236a:	37 fd       	sbrc	r19, 7
    236c:	8d e2       	ldi	r24, 0x2D	; 45
    236e:	b7 01       	movw	r22, r14
    2370:	90 e0       	ldi	r25, 0x00	; 0
    2372:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <fputc>
    2376:	a5 14       	cp	r10, r5
    2378:	38 f4       	brcc	.+14     	; 0x2388 <vfprintf+0x366>
    237a:	b7 01       	movw	r22, r14
    237c:	80 e3       	ldi	r24, 0x30	; 48
    237e:	90 e0       	ldi	r25, 0x00	; 0
    2380:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <fputc>
    2384:	5a 94       	dec	r5
    2386:	f7 cf       	rjmp	.-18     	; 0x2376 <vfprintf+0x354>
    2388:	aa 94       	dec	r10
    238a:	f4 01       	movw	r30, r8
    238c:	ea 0d       	add	r30, r10
    238e:	f1 1d       	adc	r31, r1
    2390:	80 81       	ld	r24, Z
    2392:	b7 01       	movw	r22, r14
    2394:	90 e0       	ldi	r25, 0x00	; 0
    2396:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <fputc>
    239a:	a1 10       	cpse	r10, r1
    239c:	f5 cf       	rjmp	.-22     	; 0x2388 <vfprintf+0x366>
    239e:	33 20       	and	r3, r3
    23a0:	09 f4       	brne	.+2      	; 0x23a4 <vfprintf+0x382>
    23a2:	51 ce       	rjmp	.-862    	; 0x2046 <vfprintf+0x24>
    23a4:	b7 01       	movw	r22, r14
    23a6:	80 e2       	ldi	r24, 0x20	; 32
    23a8:	90 e0       	ldi	r25, 0x00	; 0
    23aa:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <fputc>
    23ae:	3a 94       	dec	r3
    23b0:	f6 cf       	rjmp	.-20     	; 0x239e <vfprintf+0x37c>
    23b2:	f7 01       	movw	r30, r14
    23b4:	86 81       	ldd	r24, Z+6	; 0x06
    23b6:	97 81       	ldd	r25, Z+7	; 0x07
    23b8:	02 c0       	rjmp	.+4      	; 0x23be <vfprintf+0x39c>
    23ba:	8f ef       	ldi	r24, 0xFF	; 255
    23bc:	9f ef       	ldi	r25, 0xFF	; 255
    23be:	2c 96       	adiw	r28, 0x0c	; 12
    23c0:	e2 e1       	ldi	r30, 0x12	; 18
    23c2:	0c 94 dd 12 	jmp	0x25ba	; 0x25ba <__epilogue_restores__>

000023c6 <strnlen_P>:
    23c6:	fc 01       	movw	r30, r24
    23c8:	05 90       	lpm	r0, Z+
    23ca:	61 50       	subi	r22, 0x01	; 1
    23cc:	70 40       	sbci	r23, 0x00	; 0
    23ce:	01 10       	cpse	r0, r1
    23d0:	d8 f7       	brcc	.-10     	; 0x23c8 <strnlen_P+0x2>
    23d2:	80 95       	com	r24
    23d4:	90 95       	com	r25
    23d6:	8e 0f       	add	r24, r30
    23d8:	9f 1f       	adc	r25, r31
    23da:	08 95       	ret

000023dc <strnlen>:
    23dc:	fc 01       	movw	r30, r24
    23de:	61 50       	subi	r22, 0x01	; 1
    23e0:	70 40       	sbci	r23, 0x00	; 0
    23e2:	01 90       	ld	r0, Z+
    23e4:	01 10       	cpse	r0, r1
    23e6:	d8 f7       	brcc	.-10     	; 0x23de <strnlen+0x2>
    23e8:	80 95       	com	r24
    23ea:	90 95       	com	r25
    23ec:	8e 0f       	add	r24, r30
    23ee:	9f 1f       	adc	r25, r31
    23f0:	08 95       	ret

000023f2 <fputc>:
    23f2:	0f 93       	push	r16
    23f4:	1f 93       	push	r17
    23f6:	cf 93       	push	r28
    23f8:	df 93       	push	r29
    23fa:	fb 01       	movw	r30, r22
    23fc:	23 81       	ldd	r18, Z+3	; 0x03
    23fe:	21 fd       	sbrc	r18, 1
    2400:	03 c0       	rjmp	.+6      	; 0x2408 <fputc+0x16>
    2402:	8f ef       	ldi	r24, 0xFF	; 255
    2404:	9f ef       	ldi	r25, 0xFF	; 255
    2406:	28 c0       	rjmp	.+80     	; 0x2458 <fputc+0x66>
    2408:	22 ff       	sbrs	r18, 2
    240a:	16 c0       	rjmp	.+44     	; 0x2438 <fputc+0x46>
    240c:	46 81       	ldd	r20, Z+6	; 0x06
    240e:	57 81       	ldd	r21, Z+7	; 0x07
    2410:	24 81       	ldd	r18, Z+4	; 0x04
    2412:	35 81       	ldd	r19, Z+5	; 0x05
    2414:	42 17       	cp	r20, r18
    2416:	53 07       	cpc	r21, r19
    2418:	44 f4       	brge	.+16     	; 0x242a <fputc+0x38>
    241a:	a0 81       	ld	r26, Z
    241c:	b1 81       	ldd	r27, Z+1	; 0x01
    241e:	9d 01       	movw	r18, r26
    2420:	2f 5f       	subi	r18, 0xFF	; 255
    2422:	3f 4f       	sbci	r19, 0xFF	; 255
    2424:	31 83       	std	Z+1, r19	; 0x01
    2426:	20 83       	st	Z, r18
    2428:	8c 93       	st	X, r24
    242a:	26 81       	ldd	r18, Z+6	; 0x06
    242c:	37 81       	ldd	r19, Z+7	; 0x07
    242e:	2f 5f       	subi	r18, 0xFF	; 255
    2430:	3f 4f       	sbci	r19, 0xFF	; 255
    2432:	37 83       	std	Z+7, r19	; 0x07
    2434:	26 83       	std	Z+6, r18	; 0x06
    2436:	10 c0       	rjmp	.+32     	; 0x2458 <fputc+0x66>
    2438:	eb 01       	movw	r28, r22
    243a:	09 2f       	mov	r16, r25
    243c:	18 2f       	mov	r17, r24
    243e:	00 84       	ldd	r0, Z+8	; 0x08
    2440:	f1 85       	ldd	r31, Z+9	; 0x09
    2442:	e0 2d       	mov	r30, r0
    2444:	09 95       	icall
    2446:	89 2b       	or	r24, r25
    2448:	e1 f6       	brne	.-72     	; 0x2402 <fputc+0x10>
    244a:	8e 81       	ldd	r24, Y+6	; 0x06
    244c:	9f 81       	ldd	r25, Y+7	; 0x07
    244e:	01 96       	adiw	r24, 0x01	; 1
    2450:	9f 83       	std	Y+7, r25	; 0x07
    2452:	8e 83       	std	Y+6, r24	; 0x06
    2454:	81 2f       	mov	r24, r17
    2456:	90 2f       	mov	r25, r16
    2458:	df 91       	pop	r29
    245a:	cf 91       	pop	r28
    245c:	1f 91       	pop	r17
    245e:	0f 91       	pop	r16
    2460:	08 95       	ret

00002462 <__ultoa_invert>:
    2462:	fa 01       	movw	r30, r20
    2464:	aa 27       	eor	r26, r26
    2466:	28 30       	cpi	r18, 0x08	; 8
    2468:	51 f1       	breq	.+84     	; 0x24be <__ultoa_invert+0x5c>
    246a:	20 31       	cpi	r18, 0x10	; 16
    246c:	81 f1       	breq	.+96     	; 0x24ce <__ultoa_invert+0x6c>
    246e:	e8 94       	clt
    2470:	6f 93       	push	r22
    2472:	6e 7f       	andi	r22, 0xFE	; 254
    2474:	6e 5f       	subi	r22, 0xFE	; 254
    2476:	7f 4f       	sbci	r23, 0xFF	; 255
    2478:	8f 4f       	sbci	r24, 0xFF	; 255
    247a:	9f 4f       	sbci	r25, 0xFF	; 255
    247c:	af 4f       	sbci	r26, 0xFF	; 255
    247e:	b1 e0       	ldi	r27, 0x01	; 1
    2480:	3e d0       	rcall	.+124    	; 0x24fe <__ultoa_invert+0x9c>
    2482:	b4 e0       	ldi	r27, 0x04	; 4
    2484:	3c d0       	rcall	.+120    	; 0x24fe <__ultoa_invert+0x9c>
    2486:	67 0f       	add	r22, r23
    2488:	78 1f       	adc	r23, r24
    248a:	89 1f       	adc	r24, r25
    248c:	9a 1f       	adc	r25, r26
    248e:	a1 1d       	adc	r26, r1
    2490:	68 0f       	add	r22, r24
    2492:	79 1f       	adc	r23, r25
    2494:	8a 1f       	adc	r24, r26
    2496:	91 1d       	adc	r25, r1
    2498:	a1 1d       	adc	r26, r1
    249a:	6a 0f       	add	r22, r26
    249c:	71 1d       	adc	r23, r1
    249e:	81 1d       	adc	r24, r1
    24a0:	91 1d       	adc	r25, r1
    24a2:	a1 1d       	adc	r26, r1
    24a4:	20 d0       	rcall	.+64     	; 0x24e6 <__ultoa_invert+0x84>
    24a6:	09 f4       	brne	.+2      	; 0x24aa <__ultoa_invert+0x48>
    24a8:	68 94       	set
    24aa:	3f 91       	pop	r19
    24ac:	2a e0       	ldi	r18, 0x0A	; 10
    24ae:	26 9f       	mul	r18, r22
    24b0:	11 24       	eor	r1, r1
    24b2:	30 19       	sub	r19, r0
    24b4:	30 5d       	subi	r19, 0xD0	; 208
    24b6:	31 93       	st	Z+, r19
    24b8:	de f6       	brtc	.-74     	; 0x2470 <__ultoa_invert+0xe>
    24ba:	cf 01       	movw	r24, r30
    24bc:	08 95       	ret
    24be:	46 2f       	mov	r20, r22
    24c0:	47 70       	andi	r20, 0x07	; 7
    24c2:	40 5d       	subi	r20, 0xD0	; 208
    24c4:	41 93       	st	Z+, r20
    24c6:	b3 e0       	ldi	r27, 0x03	; 3
    24c8:	0f d0       	rcall	.+30     	; 0x24e8 <__ultoa_invert+0x86>
    24ca:	c9 f7       	brne	.-14     	; 0x24be <__ultoa_invert+0x5c>
    24cc:	f6 cf       	rjmp	.-20     	; 0x24ba <__ultoa_invert+0x58>
    24ce:	46 2f       	mov	r20, r22
    24d0:	4f 70       	andi	r20, 0x0F	; 15
    24d2:	40 5d       	subi	r20, 0xD0	; 208
    24d4:	4a 33       	cpi	r20, 0x3A	; 58
    24d6:	18 f0       	brcs	.+6      	; 0x24de <__ultoa_invert+0x7c>
    24d8:	49 5d       	subi	r20, 0xD9	; 217
    24da:	31 fd       	sbrc	r19, 1
    24dc:	40 52       	subi	r20, 0x20	; 32
    24de:	41 93       	st	Z+, r20
    24e0:	02 d0       	rcall	.+4      	; 0x24e6 <__ultoa_invert+0x84>
    24e2:	a9 f7       	brne	.-22     	; 0x24ce <__ultoa_invert+0x6c>
    24e4:	ea cf       	rjmp	.-44     	; 0x24ba <__ultoa_invert+0x58>
    24e6:	b4 e0       	ldi	r27, 0x04	; 4
    24e8:	a6 95       	lsr	r26
    24ea:	97 95       	ror	r25
    24ec:	87 95       	ror	r24
    24ee:	77 95       	ror	r23
    24f0:	67 95       	ror	r22
    24f2:	ba 95       	dec	r27
    24f4:	c9 f7       	brne	.-14     	; 0x24e8 <__ultoa_invert+0x86>
    24f6:	00 97       	sbiw	r24, 0x00	; 0
    24f8:	61 05       	cpc	r22, r1
    24fa:	71 05       	cpc	r23, r1
    24fc:	08 95       	ret
    24fe:	9b 01       	movw	r18, r22
    2500:	ac 01       	movw	r20, r24
    2502:	0a 2e       	mov	r0, r26
    2504:	06 94       	lsr	r0
    2506:	57 95       	ror	r21
    2508:	47 95       	ror	r20
    250a:	37 95       	ror	r19
    250c:	27 95       	ror	r18
    250e:	ba 95       	dec	r27
    2510:	c9 f7       	brne	.-14     	; 0x2504 <__ultoa_invert+0xa2>
    2512:	62 0f       	add	r22, r18
    2514:	73 1f       	adc	r23, r19
    2516:	84 1f       	adc	r24, r20
    2518:	95 1f       	adc	r25, r21
    251a:	a0 1d       	adc	r26, r0
    251c:	08 95       	ret

0000251e <__divmodsi4>:
    251e:	05 2e       	mov	r0, r21
    2520:	97 fb       	bst	r25, 7
    2522:	1e f4       	brtc	.+6      	; 0x252a <__divmodsi4+0xc>
    2524:	00 94       	com	r0
    2526:	0e 94 a6 12 	call	0x254c	; 0x254c <__negsi2>
    252a:	57 fd       	sbrc	r21, 7
    252c:	07 d0       	rcall	.+14     	; 0x253c <__divmodsi4_neg2>
    252e:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <__udivmodsi4>
    2532:	07 fc       	sbrc	r0, 7
    2534:	03 d0       	rcall	.+6      	; 0x253c <__divmodsi4_neg2>
    2536:	4e f4       	brtc	.+18     	; 0x254a <__divmodsi4_exit>
    2538:	0c 94 a6 12 	jmp	0x254c	; 0x254c <__negsi2>

0000253c <__divmodsi4_neg2>:
    253c:	50 95       	com	r21
    253e:	40 95       	com	r20
    2540:	30 95       	com	r19
    2542:	21 95       	neg	r18
    2544:	3f 4f       	sbci	r19, 0xFF	; 255
    2546:	4f 4f       	sbci	r20, 0xFF	; 255
    2548:	5f 4f       	sbci	r21, 0xFF	; 255

0000254a <__divmodsi4_exit>:
    254a:	08 95       	ret

0000254c <__negsi2>:
    254c:	90 95       	com	r25
    254e:	80 95       	com	r24
    2550:	70 95       	com	r23
    2552:	61 95       	neg	r22
    2554:	7f 4f       	sbci	r23, 0xFF	; 255
    2556:	8f 4f       	sbci	r24, 0xFF	; 255
    2558:	9f 4f       	sbci	r25, 0xFF	; 255
    255a:	08 95       	ret

0000255c <__muluhisi3>:
    255c:	0e 94 1a 13 	call	0x2634	; 0x2634 <__umulhisi3>
    2560:	a5 9f       	mul	r26, r21
    2562:	90 0d       	add	r25, r0
    2564:	b4 9f       	mul	r27, r20
    2566:	90 0d       	add	r25, r0
    2568:	a4 9f       	mul	r26, r20
    256a:	80 0d       	add	r24, r0
    256c:	91 1d       	adc	r25, r1
    256e:	11 24       	eor	r1, r1
    2570:	08 95       	ret

00002572 <__mulshisi3>:
    2572:	b7 ff       	sbrs	r27, 7
    2574:	0c 94 ae 12 	jmp	0x255c	; 0x255c <__muluhisi3>

00002578 <__mulohisi3>:
    2578:	0e 94 ae 12 	call	0x255c	; 0x255c <__muluhisi3>
    257c:	82 1b       	sub	r24, r18
    257e:	93 0b       	sbc	r25, r19
    2580:	08 95       	ret

00002582 <__prologue_saves__>:
    2582:	2f 92       	push	r2
    2584:	3f 92       	push	r3
    2586:	4f 92       	push	r4
    2588:	5f 92       	push	r5
    258a:	6f 92       	push	r6
    258c:	7f 92       	push	r7
    258e:	8f 92       	push	r8
    2590:	9f 92       	push	r9
    2592:	af 92       	push	r10
    2594:	bf 92       	push	r11
    2596:	cf 92       	push	r12
    2598:	df 92       	push	r13
    259a:	ef 92       	push	r14
    259c:	ff 92       	push	r15
    259e:	0f 93       	push	r16
    25a0:	1f 93       	push	r17
    25a2:	cf 93       	push	r28
    25a4:	df 93       	push	r29
    25a6:	cd b7       	in	r28, 0x3d	; 61
    25a8:	de b7       	in	r29, 0x3e	; 62
    25aa:	ca 1b       	sub	r28, r26
    25ac:	db 0b       	sbc	r29, r27
    25ae:	0f b6       	in	r0, 0x3f	; 63
    25b0:	f8 94       	cli
    25b2:	de bf       	out	0x3e, r29	; 62
    25b4:	0f be       	out	0x3f, r0	; 63
    25b6:	cd bf       	out	0x3d, r28	; 61
    25b8:	09 94       	ijmp

000025ba <__epilogue_restores__>:
    25ba:	2a 88       	ldd	r2, Y+18	; 0x12
    25bc:	39 88       	ldd	r3, Y+17	; 0x11
    25be:	48 88       	ldd	r4, Y+16	; 0x10
    25c0:	5f 84       	ldd	r5, Y+15	; 0x0f
    25c2:	6e 84       	ldd	r6, Y+14	; 0x0e
    25c4:	7d 84       	ldd	r7, Y+13	; 0x0d
    25c6:	8c 84       	ldd	r8, Y+12	; 0x0c
    25c8:	9b 84       	ldd	r9, Y+11	; 0x0b
    25ca:	aa 84       	ldd	r10, Y+10	; 0x0a
    25cc:	b9 84       	ldd	r11, Y+9	; 0x09
    25ce:	c8 84       	ldd	r12, Y+8	; 0x08
    25d0:	df 80       	ldd	r13, Y+7	; 0x07
    25d2:	ee 80       	ldd	r14, Y+6	; 0x06
    25d4:	fd 80       	ldd	r15, Y+5	; 0x05
    25d6:	0c 81       	ldd	r16, Y+4	; 0x04
    25d8:	1b 81       	ldd	r17, Y+3	; 0x03
    25da:	aa 81       	ldd	r26, Y+2	; 0x02
    25dc:	b9 81       	ldd	r27, Y+1	; 0x01
    25de:	ce 0f       	add	r28, r30
    25e0:	d1 1d       	adc	r29, r1
    25e2:	0f b6       	in	r0, 0x3f	; 63
    25e4:	f8 94       	cli
    25e6:	de bf       	out	0x3e, r29	; 62
    25e8:	0f be       	out	0x3f, r0	; 63
    25ea:	cd bf       	out	0x3d, r28	; 61
    25ec:	ed 01       	movw	r28, r26
    25ee:	08 95       	ret

000025f0 <__udivmodsi4>:
    25f0:	a1 e2       	ldi	r26, 0x21	; 33
    25f2:	1a 2e       	mov	r1, r26
    25f4:	aa 1b       	sub	r26, r26
    25f6:	bb 1b       	sub	r27, r27
    25f8:	fd 01       	movw	r30, r26
    25fa:	0d c0       	rjmp	.+26     	; 0x2616 <__udivmodsi4_ep>

000025fc <__udivmodsi4_loop>:
    25fc:	aa 1f       	adc	r26, r26
    25fe:	bb 1f       	adc	r27, r27
    2600:	ee 1f       	adc	r30, r30
    2602:	ff 1f       	adc	r31, r31
    2604:	a2 17       	cp	r26, r18
    2606:	b3 07       	cpc	r27, r19
    2608:	e4 07       	cpc	r30, r20
    260a:	f5 07       	cpc	r31, r21
    260c:	20 f0       	brcs	.+8      	; 0x2616 <__udivmodsi4_ep>
    260e:	a2 1b       	sub	r26, r18
    2610:	b3 0b       	sbc	r27, r19
    2612:	e4 0b       	sbc	r30, r20
    2614:	f5 0b       	sbc	r31, r21

00002616 <__udivmodsi4_ep>:
    2616:	66 1f       	adc	r22, r22
    2618:	77 1f       	adc	r23, r23
    261a:	88 1f       	adc	r24, r24
    261c:	99 1f       	adc	r25, r25
    261e:	1a 94       	dec	r1
    2620:	69 f7       	brne	.-38     	; 0x25fc <__udivmodsi4_loop>
    2622:	60 95       	com	r22
    2624:	70 95       	com	r23
    2626:	80 95       	com	r24
    2628:	90 95       	com	r25
    262a:	9b 01       	movw	r18, r22
    262c:	ac 01       	movw	r20, r24
    262e:	bd 01       	movw	r22, r26
    2630:	cf 01       	movw	r24, r30
    2632:	08 95       	ret

00002634 <__umulhisi3>:
    2634:	a2 9f       	mul	r26, r18
    2636:	b0 01       	movw	r22, r0
    2638:	b3 9f       	mul	r27, r19
    263a:	c0 01       	movw	r24, r0
    263c:	a3 9f       	mul	r26, r19
    263e:	70 0d       	add	r23, r0
    2640:	81 1d       	adc	r24, r1
    2642:	11 24       	eor	r1, r1
    2644:	91 1d       	adc	r25, r1
    2646:	b2 9f       	mul	r27, r18
    2648:	70 0d       	add	r23, r0
    264a:	81 1d       	adc	r24, r1
    264c:	11 24       	eor	r1, r1
    264e:	91 1d       	adc	r25, r1
    2650:	08 95       	ret

00002652 <_exit>:
    2652:	f8 94       	cli

00002654 <__stop_program>:
    2654:	ff cf       	rjmp	.-2      	; 0x2654 <__stop_program>
